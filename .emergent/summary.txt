<analysis>**original_problem_statement:** The user wants to build a full-stack, monorepo application called Narvo, a precision-engineered, audio-first news broadcast platform.

**PRODUCT REQUIREMENTS:**

The project has evolved significantly. The current high-priority requirements are:
-   **Core Feature:** Integrate YarnGPT () as the primary text-to-speech (TTS) engine, with OpenAI TTS as a fallback.
-   **Bug Fixes:**
    -   Address mismatches between voice cards and languages on the  page.
    -   Fix the news detail page's autoplay feature, which is still not working correctly or is too slow.
    -   Ensure the  page inherits the shared application layout (sidebar, header).
-   **Feature Implementation:**
    -   Implement push notifications for a daily digest.
    -   Add selectable sound themes for broadcasts.
    -   Remove all mock data and replace it with real, dynamic data (e.g., user stats, fact-check sources, podcast feeds).
    -   Implement a Listening History feature.
    -   Make voice previews on the  page play automatically on selection.
-   **Performance:** Improve the loading speed of audio broadcasts.
-   **Accessibility:** Apply accessibility enhancements based on the provided design system.

**User's preferred language**: English

**what currently exists?**
The application is a functional full-stack news platform using React, FastAPI, and MongoDB. Key features include user authentication (Supabase with Google OAuth), news aggregation from RSS feeds, a podcast discovery section with real data from RSS feeds, and a persistent user settings system that syncs between localStorage and MongoDB. In this session, the agent implemented a vast number of features, including a full accessibility overhaul, persistent settings, clickable hashtags, a Listening History page, real-time data integration for podcasts and fact-checking, and numerous mobile UI fixes. The agent has also started integrating YarnGPT as the new primary TTS provider and is in the middle of implementing push notifications and broadcast sound themes.

**Last working item**:
    - Last item agent was working: The agent was in the final stages of a large feature batch. The immediate last action was creating the frontend component  to handle the UI for push notification subscriptions. This is part of the larger task to implement a daily digest push notification system.
    - Status: IN PROGRESS
    - Agent Testing Done: N
    - Which testing method agent to use? both
    - User Testing Done: N

**All Pending/In progress Issue list**:
  - Issue 1: The autoplay feature on the news detail page is still not functioning as requested; it's either not working or too slow. (P0)
  - Issue 2: The voice cards on the  page do not correctly match the voice languages after the YarnGPT integration. (P1)
  
  Issues Detail:
  - Issue 1: 
     - Attempted fixes: The agent has tried multiple approaches. The latest attempt involves pre-generating the TTS audio as soon as the news data loads on the  ( hook) to ensure the audio is cached and ready for immediate playback when the user navigates.
     - Next debug checklist: 
        1. Verify that the  hook in  is correctly calling the pre-generation endpoint.
        2. Check browser network logs to confirm the TTS audio request is being sent on page load, not on play button click.
        3. Ensure the  function in  correctly retrieves the pre-cached audio.
        4. If it's still slow, investigate the backend TTS generation time for YarnGPT.
     - Why fix this issue and what will be achieved with the fix? This is a core UX feature for an audio-first app and a persistent user request.
     - Status:  IN PROGRESS
     - Is recurring issue? Y
     - Should Test frontend/backend/both after fix? both
     - Blocked on other issue: None
  - Issue 2: 
     - Attempted fixes: The agent updated the  constant in  to reflect the new voices from YarnGPT. However, the user reports a mismatch.
     - Next debug checklist: 
        1. Cross-reference the voice data being sent from the  endpoint with the  constant in .
        2. Ensure the mapping of  to language metadata (flag, language name) is correct.
        3. Manually test a few voices on the page to confirm the spoken language matches the displayed language.
     - Why fix this issue and what will be achieved with the fix? Ensures users can accurately select their desired broadcast voice and language.
     - Status:  IN PROGRESS
     - Is recurring issue? N
     - Should Test frontend/backend/both after fix? frontend
     - Blocked on other issue: None

**In progress Task List**:
  - Task 1: Complete Push Notification Implementation (P1)
     - Where to resume: The file  has just been created. The agent needs to implement the UI and logic for this component and integrate it into the dashboard. The backend endpoints (, ) are in place.
     - What will be achieved with this? A user-facing feature allowing them to subscribe to daily news digest push notifications.
     - Status:  IN PROGRESS
     - Should Test frontend/backend/both after fix? both
     - Blocked on something: No
  - Task 2: Complete Broadcast Sound Themes Feature (P2)
     - Where to resume: The backend  is created. The agent was adding the  component to . This UI implementation needs to be completed, along with state management and API calls.
     - What will be achieved with this? Users will be able to select a sound theme for their audio broadcasts.
     - Status:  IN PROGRESS
     - Should Test frontend/backend/both after fix? both
     - Blocked on something: No
  - Task 3: Finalize and Verify YarnGPT Integration (P0)
     - Where to resume: The backend is integrated with YarnGPT as the primary TTS. The frontend voice list has been updated. The entire flow needs comprehensive testing to ensure it's faster, stable, and that the voice/language mapping is correct (see Issue #2).
     - What will be achieved with this? Fulfills a core user requirement for a new, primary voice engine.
     - Status:  IN PROGRESS
     - Should Test frontend/backend/both after fix? both
     - Blocked on something: No

**Upcoming and Future Tasks**
**Upcoming Tasks:**
-   **P1: Backend Unit/Integration Tests:** Write ============================= test session starts ==============================
platform linux -- Python 3.11.14, pytest-9.0.2, pluggy-1.6.0
rootdir: /app
plugins: asyncio-1.3.0, anyio-4.12.1
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 430 items

backend/tests/test_admin_factcheck_api.py FFFFFFFFFFFFFFFFFFFFFFFFFFFF   [  6%]
backend/tests/test_aggregator_integration_v33.py FFFFFFFFFFFFFF          [  9%]
backend/tests/test_ai_sanitizer_v37.py FFFFFFFFFFFFFFF                   [ 13%]
backend/tests/test_emptystate_truthtag_share.py FFFFFFFFFFFFFFFFF        [ 17%]
backend/tests/test_health_monitoring_v30.py FFFFFFFFFFFF                 [ 20%]
backend/tests/test_i18n_settings_v16.py FFFFFFFFFFFF                     [ 22%]
backend/tests/test_iteration42.py FFFFFFF                                [ 24%]
backend/tests/test_iteration_17.py FFFFFFFFFFFF                          [ 27%]
backend/tests/test_iteration_18.py FFFFFFFFFFFFFFFFFFFF                  [ 31%]
backend/tests/test_iteration_19.py FFFFFFFFFFFFFFFFFFFF                  [ 36%]
backend/tests/test_iteration_20.py FFFFFFFFFFFFFF                        [ 39%]
backend/tests/test_iteration_22.py FFFFFFFFFFF                           [ 42%]
backend/tests/test_iteration_23.py FFFFFFFFFF                            [ 44%]
backend/tests/test_iteration_24.py FFFFFFFFFFFF                          [ 47%]
backend/tests/test_iteration_25.py FFFFFFFFFFFFFFFF                      [ 51%]
backend/tests/test_iteration_34.py FFFFFFFFFFFFFFFFFFFFFF                [ 56%]
backend/tests/test_iteration_35.py FFFFFFFFFFFFFFFF                      [ 60%]
backend/tests/test_iteration_38.py FFFFFFFFFFFFF                         [ 63%]
backend/tests/test_narvo_api.py FFFFFFFFFFFF                             [ 65%]
backend/tests/test_narvo_api_v2.py FFFFFFFFFFFFFFF                       [ 69%]
backend/tests/test_narvo_v8.py FFFFFFFFFFFFFFFFFF                        [ 73%]
backend/tests/test_persistence_v7.py FFFFFFFFFFFFFFFFFF                  [ 77%]
backend/tests/test_services.py FFFFFFFFFFFFFFFFFFF                       [ 82%]
backend/tests/test_services_v2.py FFFFFFFFFF                             [ 84%]
backend/tests/test_translation_factcheck.py FFFFFFFFFFFFFFFFF            [ 88%]
backend/tests/test_tts_podcast_aggregator.py FFFFFFFFFFFFFFFF            [ 92%]
backend/tests/test_user_profile_radio.py FFFFFFFFF                       [ 94%]
backend/tests/test_voice_mapping_v31.py FFFFFFFFFFFFFFFFFFFFFFFFF        [100%]

=================================== FAILURES ===================================
_____________________ TestHealthCheck.test_health_endpoint _____________________

self = <test_admin_factcheck_api.TestHealthCheck object at 0xfd9f68a0a9d0>

    def test_health_endpoint(self):
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestAdminMetricsAPI.test_metrics_returns_200 _________________

self = <test_admin_factcheck_api.TestAdminMetricsAPI object at 0xfd9f68a0b690>

    def test_metrics_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/admin/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/metrics'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/metrics': No scheme supplied. Perhaps you meant https:///api/admin/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestAdminMetricsAPI.test_metrics_has_required_fields _____________

self = <test_admin_factcheck_api.TestAdminMetricsAPI object at 0xfd9f68a0bdd0>

    def test_metrics_has_required_fields(self):
>       response = requests.get(f"{BASE_URL}/api/admin/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/metrics'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/metrics': No scheme supplied. Perhaps you meant https:///api/admin/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestAdminMetricsAPI.test_metrics_values_are_valid _______________

self = <test_admin_factcheck_api.TestAdminMetricsAPI object at 0xfd9f68a28450>

    def test_metrics_values_are_valid(self):
>       response = requests.get(f"{BASE_URL}/api/admin/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/metrics'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/metrics': No scheme supplied. Perhaps you meant https:///api/admin/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestAdminAlertsAPI.test_alerts_returns_200 __________________

self = <test_admin_factcheck_api.TestAdminAlertsAPI object at 0xfd9f68a28cd0>

    def test_alerts_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/admin/alerts")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/alerts'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/alerts': No scheme supplied. Perhaps you meant https:///api/admin/alerts?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestAdminAlertsAPI.test_alerts_returns_list __________________

self = <test_admin_factcheck_api.TestAdminAlertsAPI object at 0xfd9f68a29310>

    def test_alerts_returns_list(self):
>       response = requests.get(f"{BASE_URL}/api/admin/alerts")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/alerts'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/alerts': No scheme supplied. Perhaps you meant https:///api/admin/alerts?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestAdminAlertsAPI.test_alert_structure ____________________

self = <test_admin_factcheck_api.TestAdminAlertsAPI object at 0xfd9f68a29950>

    def test_alert_structure(self):
>       response = requests.get(f"{BASE_URL}/api/admin/alerts")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/alerts'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/alerts': No scheme supplied. Perhaps you meant https:///api/admin/alerts?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestAdminStreamsAPI.test_streams_returns_200 _________________

self = <test_admin_factcheck_api.TestAdminStreamsAPI object at 0xfd9f68a29b90>

    def test_streams_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/admin/streams")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/streams'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/streams': No scheme supplied. Perhaps you meant https:///api/admin/streams?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestAdminStreamsAPI.test_streams_returns_list _________________

self = <test_admin_factcheck_api.TestAdminStreamsAPI object at 0xfd9f68a29ed0>

    def test_streams_returns_list(self):
>       response = requests.get(f"{BASE_URL}/api/admin/streams")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/streams'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/streams': No scheme supplied. Perhaps you meant https:///api/admin/streams?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestAdminStreamsAPI.test_stream_structure ___________________

self = <test_admin_factcheck_api.TestAdminStreamsAPI object at 0xfd9f68a2a210>

    def test_stream_structure(self):
>       response = requests.get(f"{BASE_URL}/api/admin/streams")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/streams'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/streams': No scheme supplied. Perhaps you meant https:///api/admin/streams?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestAdminVoicesAPI.test_voices_returns_200 __________________

self = <test_admin_factcheck_api.TestAdminVoicesAPI object at 0xfd9f68a2aa50>

    def test_voices_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/admin/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/voices'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/voices': No scheme supplied. Perhaps you meant https:///api/admin/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestAdminVoicesAPI.test_voices_returns_list __________________

self = <test_admin_factcheck_api.TestAdminVoicesAPI object at 0xfd9f68a2b090>

    def test_voices_returns_list(self):
>       response = requests.get(f"{BASE_URL}/api/admin/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/voices'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/voices': No scheme supplied. Perhaps you meant https:///api/admin/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestAdminVoicesAPI.test_voice_structure ____________________

self = <test_admin_factcheck_api.TestAdminVoicesAPI object at 0xfd9f68a2b710>

    def test_voice_structure(self):
>       response = requests.get(f"{BASE_URL}/api/admin/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/voices'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/voices': No scheme supplied. Perhaps you meant https:///api/admin/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestAdminModerationAPI.test_moderation_returns_200 ______________

self = <test_admin_factcheck_api.TestAdminModerationAPI object at 0xfd9f68a2bf90>

    def test_moderation_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/admin/moderation")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/moderation'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/moderation': No scheme supplied. Perhaps you meant https:///api/admin/moderation?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestAdminModerationAPI.test_moderation_returns_list ______________

self = <test_admin_factcheck_api.TestAdminModerationAPI object at 0xfd9f68a34610>

    def test_moderation_returns_list(self):
>       response = requests.get(f"{BASE_URL}/api/admin/moderation")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/moderation'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/moderation': No scheme supplied. Perhaps you meant https:///api/admin/moderation?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestAdminModerationAPI.test_moderation_item_structure _____________

self = <test_admin_factcheck_api.TestAdminModerationAPI object at 0xfd9f68a34c50>

    def test_moderation_item_structure(self):
>       response = requests.get(f"{BASE_URL}/api/admin/moderation")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/moderation'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/moderation': No scheme supplied. Perhaps you meant https:///api/admin/moderation?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestAdminStatsAPI.test_stats_returns_200 ___________________

self = <test_admin_factcheck_api.TestAdminStatsAPI object at 0xfd9f68a35490>

    def test_stats_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/admin/stats")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/stats', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/stats': No scheme supplied. Perhaps you meant https:///api/admin/stats?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestAdminStatsAPI.test_stats_has_required_fields _______________

self = <test_admin_factcheck_api.TestAdminStatsAPI object at 0xfd9f68a35ad0>

    def test_stats_has_required_fields(self):
>       response = requests.get(f"{BASE_URL}/api/admin/stats")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/stats', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/stats': No scheme supplied. Perhaps you meant https:///api/admin/stats?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestAdminStatsAPI.test_stats_dubawa_status __________________

self = <test_admin_factcheck_api.TestAdminStatsAPI object at 0xfd9f68a36110>

    def test_stats_dubawa_status(self):
>       response = requests.get(f"{BASE_URL}/api/admin/stats")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/admin/stats', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/admin/stats': No scheme supplied. Perhaps you meant https:///api/admin/stats?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestFactCheckStoryAPI.test_factcheck_story_returns_200 ____________

self = <test_admin_factcheck_api.TestFactCheckStoryAPI object at 0xfd9f68a36990>

    def test_factcheck_story_returns_200(self):
>       response = requests.get(f"{BASE_URL}/api/factcheck/test-story-123")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/test-story-123'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/test-story-123': No scheme supplied. Perhaps you meant https:///api/factcheck/test-story-123?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestFactCheckStoryAPI.test_factcheck_story_structure _____________

self = <test_admin_factcheck_api.TestFactCheckStoryAPI object at 0xfd9f68a36fd0>

    def test_factcheck_story_structure(self):
>       response = requests.get(f"{BASE_URL}/api/factcheck/test-story-123")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/test-story-123'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/test-story-123': No scheme supplied. Perhaps you meant https:///api/factcheck/test-story-123?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestFactCheckStoryAPI.test_factcheck_different_stories_may_vary ________

self = <test_admin_factcheck_api.TestFactCheckStoryAPI object at 0xfd9f68a37610>

    def test_factcheck_different_stories_may_vary(self):
        # Different story IDs should produce consistent but potentially different results
>       response1 = requests.get(f"{BASE_URL}/api/factcheck/story-abc")
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/story-abc'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/story-abc': No scheme supplied. Perhaps you meant https:///api/factcheck/story-abc?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestFactCheckAnalyzeAPI.test_analyze_confirmed_text ______________

self = <test_admin_factcheck_api.TestFactCheckAnalyzeAPI object at 0xfd9f68a2a0d0>

    def test_analyze_confirmed_text(self):
>       response = requests.post(f"{BASE_URL}/api/factcheck/analyze?text=This%20is%20a%20confirmed%20report")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/factcheck/analyze?text=This%20is%20a%20confirmed%20report'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze?text=This%20is%20a%20confirmed%20report': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?text=This%20is%20a%20confirmed%20report?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestFactCheckAnalyzeAPI.test_analyze_disputed_text ______________

self = <test_admin_factcheck_api.TestFactCheckAnalyzeAPI object at 0xfd9f68a37790>

    def test_analyze_disputed_text(self):
>       response = requests.post(f"{BASE_URL}/api/factcheck/analyze?text=This%20is%20a%20disputed%20claim")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/factcheck/analyze?text=This%20is%20a%20disputed%20claim'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze?text=This%20is%20a%20disputed%20claim': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?text=This%20is%20a%20disputed%20claim?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestFactCheckAnalyzeAPI.test_analyze_rumor_text ________________

self = <test_admin_factcheck_api.TestFactCheckAnalyzeAPI object at 0xfd9f68a36c10>

    def test_analyze_rumor_text(self):
>       response = requests.post(f"{BASE_URL}/api/factcheck/analyze?text=This%20is%20a%20rumor%20spreading")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/factcheck/analyze?text=This%20is%20a%20rumor%20spreading'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze?text=This%20is%20a%20rumor%20spreading': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?text=This%20is%20a%20rumor%20spreading?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestFactCheckAnalyzeAPI.test_analyze_neutral_text _______________

self = <test_admin_factcheck_api.TestFactCheckAnalyzeAPI object at 0xfd9f68a34390>

    def test_analyze_neutral_text(self):
>       response = requests.post(f"{BASE_URL}/api/factcheck/analyze?text=This%20is%20a%20neutral%20statement")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/factcheck/analyze?text=This%20is%20a%20neutral%20statement'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze?text=This%20is%20a%20neutral%20statement': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?text=This%20is%20a%20neutral%20statement?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestFactCheckAnalyzeAPI.test_analyze_false_text ________________

self = <test_admin_factcheck_api.TestFactCheckAnalyzeAPI object at 0xfd9f68a37d90>

    def test_analyze_false_text(self):
>       response = requests.post(f"{BASE_URL}/api/factcheck/analyze?text=This%20is%20a%20false%20claim")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/factcheck/analyze?text=This%20is%20a%20false%20claim'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze?text=This%20is%20a%20false%20claim': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?text=This%20is%20a%20false%20claim?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestFactCheckAnalyzeAPI.test_analyze_response_structure ____________

self = <test_admin_factcheck_api.TestFactCheckAnalyzeAPI object at 0xfd9f68a38110>

    def test_analyze_response_structure(self):
>       response = requests.post(f"{BASE_URL}/api/factcheck/analyze?text=test%20text")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_admin_factcheck_api.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/factcheck/analyze?text=test%20text'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze?text=test%20text': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?text=test%20text?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_ TestNewsWithAggregators.test_news_with_include_aggregators_returns_aggregator_field _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestNewsWithAggregators object at 0xfd9f6838a210>
client = <httpx.Client object at 0xfd9f67fc0890>

    def test_news_with_include_aggregators_returns_aggregator_field(self, client):
        """GET /api/news?include_aggregators=true should return articles with 'aggregator' field"""
>       r = client.get("/api/news?limit=50&include_aggregators=true")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_ TestNewsWithAggregators.test_news_without_include_aggregators_no_aggregator_field _

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestNewsWithAggregators object at 0xfd9f6838a990>
client = <httpx.Client object at 0xfd9f67a3db10>

    def test_news_without_include_aggregators_no_aggregator_field(self, client):
        """GET /api/news without include_aggregators returns only RSS articles (no aggregator field)"""
>       r = client.get("/api/news?limit=20")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________ TestNewsWithAggregators.test_news_include_aggregators_false __________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestNewsWithAggregators object at 0xfd9f6838b0d0>
client = <httpx.Client object at 0xfd9f67db3ad0>

    def test_news_include_aggregators_false(self, client):
        """GET /api/news?include_aggregators=false should not return aggregator articles"""
>       r = client.get("/api/news?limit=20&include_aggregators=false")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____ TestMetricsWithAggregators.test_metrics_includes_aggregators_object ______

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestMetricsWithAggregators object at 0xfd9f6838b9d0>
client = <httpx.Client object at 0xfd9f67d0c250>

    def test_metrics_includes_aggregators_object(self, client):
        """GET /api/metrics should include aggregators status object"""
>       r = client.get("/api/metrics")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______ TestMetricsWithAggregators.test_metrics_aggregators_cached_count _______

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestMetricsWithAggregators object at 0xfd9f68394110>
client = <httpx.Client object at 0xfd9f67bea310>

    def test_metrics_aggregators_cached_count(self, client):
        """After fetching, aggregators should have cached_count > 0"""
        # First trigger a fetch to populate cache
>       client.get("/api/aggregators/fetch?keywords=Nigeria")

backend/tests/test_aggregator_integration_v33.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
___________ TestAggregatorsStatus.test_aggregators_status_configured ___________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestAggregatorsStatus object at 0xfd9f683949d0>
client = <httpx.Client object at 0xfd9f67ab7550>

    def test_aggregators_status_configured(self, client):
        """GET /api/aggregators/status shows configured:true for both"""
>       r = client.get("/api/aggregators/status")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__________ TestAggregatorsStatus.test_aggregators_status_after_fetch ___________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestAggregatorsStatus object at 0xfd9f683950d0>
client = <httpx.Client object at 0xfd9f67a4cb90>

    def test_aggregators_status_after_fetch(self, client):
        """After fetching, cached_count should be > 0"""
        # Trigger fetch first
>       client.get("/api/aggregators/fetch?keywords=Nigeria+Africa")

backend/tests/test_aggregator_integration_v33.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__ TestAggregatorArticleFields.test_mediastack_articles_have_aggregator_field __

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestAggregatorArticleFields object at 0xfd9f68395990>
client = <httpx.Client object at 0xfd9f67dae790>

    def test_mediastack_articles_have_aggregator_field(self, client):
        """Mediastack articles should have aggregator='mediastack'"""
>       r = client.get("/api/aggregators/mediastack?keywords=Nigeria&limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
___ TestAggregatorArticleFields.test_newsdata_articles_have_aggregator_field ___

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestAggregatorArticleFields object at 0xfd9f68389e50>
client = <httpx.Client object at 0xfd9f67c29ad0>

    def test_newsdata_articles_have_aggregator_field(self, client):
        """NewsData articles should have aggregator='newsdata'"""
>       r = client.get("/api/aggregators/newsdata?query=Nigeria&limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestRegressionFeatures.test_health_endpoint __________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestRegressionFeatures object at 0xfd9f68396010>
client = <httpx.Client object at 0xfd9f67aace90>

    def test_health_endpoint(self, client):
        """Health endpoint should return online status"""
>       r = client.get("/api/health")
            ^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________ TestRegressionFeatures.test_sources_health_39_feeds ______________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestRegressionFeatures object at 0xfd9f68396390>
client = <httpx.Client object at 0xfd9f67c7fcd0>

    def test_sources_health_39_feeds(self, client):
        """Sources health should report 39 feeds"""
>       r = client.get("/api/sources/health")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestRegressionFeatures.test_sources_count_39 _________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestRegressionFeatures object at 0xfd9f68396710>
client = <httpx.Client object at 0xfd9f67a55e10>

    def test_sources_count_39(self, client):
        """Sources endpoint should report 39 total sources"""
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestRegressionFeatures.test_voices_endpoint __________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestRegressionFeatures object at 0xfd9f68396c90>
client = <httpx.Client object at 0xfd9f67c56950>

    def test_voices_endpoint(self, client):
        """Voices endpoint should return 5 voices with gender"""
>       r = client.get("/api/voices")
            ^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________ TestRegressionFeatures.test_news_basic_endpoint ________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_aggregator_integration_v33.TestRegressionFeatures object at 0xfd9f68397310>
client = <httpx.Client object at 0xfd9f67affe90>

    def test_news_basic_endpoint(self, client):
        """News endpoint should return articles from RSS feeds"""
>       r = client.get("/api/news?limit=10")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_aggregator_integration_v33.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
________________ TestHealthAndBasicEndpoints.test_health_check _________________

self = <test_ai_sanitizer_v37.TestHealthAndBasicEndpoints object at 0xfd9f6839d8d0>

    def test_health_check(self):
        """GET /api/health should return status online"""
>       response = requests.get(f"{BASE_URL}/api/health", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestHealthAndBasicEndpoints.test_news_endpoint ________________

self = <test_ai_sanitizer_v37.TestHealthAndBasicEndpoints object at 0xfd9f6839df10>

    def test_news_endpoint(self):
        """GET /api/news should return news articles"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestHealthAndBasicEndpoints.test_search_endpoint _______________

self = <test_ai_sanitizer_v37.TestHealthAndBasicEndpoints object at 0xfd9f6839e550>

    def test_search_endpoint(self):
        """GET /api/search?q=Nigeria should return search results"""
>       response = requests.get(f"{BASE_URL}/api/search?q=Nigeria&limit=10", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search?q=Nigeria&limit=10'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search?q=Nigeria&limit=10': No scheme supplied. Perhaps you meant https:///api/search?q=Nigeria&limit=10?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestParaphraseSanitizer.test_paraphrase_basic _________________

self = <test_ai_sanitizer_v37.TestParaphraseSanitizer object at 0xfd9f6839edd0>

    def test_paraphrase_basic(self):
        """POST /api/paraphrase should return sanitized narrative"""
        payload = {
            "text": "Breaking News: The Nigerian government has announced new economic reforms aimed at stabilizing the Naira and reducing inflation. Finance Minister stated the reforms would take effect next month.",
            "style": "broadcast"
        }
>       response = requests.post(f"{BASE_URL}/api/paraphrase", json=payload, timeout=60)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/paraphrase', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/paraphrase': No scheme supplied. Perhaps you meant https:///api/paraphrase?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestParaphraseSanitizer.test_paraphrase_strips_brackets ____________

self = <test_ai_sanitizer_v37.TestParaphraseSanitizer object at 0xfd9f6839f490>

    def test_paraphrase_strips_brackets(self):
        """Verify sanitizer strips bracketed text like [Sound of music fades]"""
        # This tests with text that might prompt LLM to add stage directions
        payload = {
            "text": "A dramatic announcement was made today. The president gave a rousing speech about national unity. The crowd cheered enthusiastically as the music played.",
            "style": "broadcast"
        }
>       response = requests.post(f"{BASE_URL}/api/paraphrase", json=payload, timeout=60)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/paraphrase', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/paraphrase': No scheme supplied. Perhaps you meant https:///api/paraphrase?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestTranslationSanitizer.test_translate_to_pidgin _______________

self = <test_ai_sanitizer_v37.TestTranslationSanitizer object at 0xfd9f6839fd90>

    def test_translate_to_pidgin(self):
        """POST /api/translate/text with target_language='pcm' should return clean translation"""
        payload = {
            "text": "The government has announced new policies to help small businesses grow. These reforms include tax breaks and easier access to loans.",
            "target_language": "pcm",
            "source_language": "en"
        }
>       response = requests.post(f"{BASE_URL}/api/translate/text", json=payload, timeout=60)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/translate/text'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/text': No scheme supplied. Perhaps you meant https:///api/translate/text?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestTranslationSanitizer.test_translate_to_yoruba _______________

self = <test_ai_sanitizer_v37.TestTranslationSanitizer object at 0xfd9f683b4490>

    def test_translate_to_yoruba(self):
        """POST /api/translate/text with target_language='yo' returns clean translation"""
        payload = {
            "text": "Breaking news from Lagos. The state government is building new roads to reduce traffic.",
            "target_language": "yo",
            "source_language": "en"
        }
>       response = requests.post(f"{BASE_URL}/api/translate/text", json=payload, timeout=60)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/translate/text'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/text': No scheme supplied. Perhaps you meant https:///api/translate/text?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestTranslationSanitizer.test_supported_languages_endpoint __________

self = <test_ai_sanitizer_v37.TestTranslationSanitizer object at 0xfd9f6839e090>

    def test_supported_languages_endpoint(self):
        """GET /api/translate/languages should return supported languages"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestBriefingScriptSanitizer.test_briefing_generate ______________

self = <test_ai_sanitizer_v37.TestBriefingScriptSanitizer object at 0xfd9f683b4850>

    def test_briefing_generate(self):
        """GET /api/briefing/generate should return script without sound effects"""
        # First, try to get latest briefing (may already exist)
>       response = requests.get(f"{BASE_URL}/api/briefing/latest", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/briefing/latest'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/briefing/latest': No scheme supplied. Perhaps you meant https:///api/briefing/latest?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestBriefingScriptSanitizer.test_briefing_history _______________

self = <test_ai_sanitizer_v37.TestBriefingScriptSanitizer object at 0xfd9f683b4b90>

    def test_briefing_history(self):
        """GET /api/briefing/history should return briefing list"""
>       response = requests.get(f"{BASE_URL}/api/briefing/history?limit=5", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/briefing/history?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/briefing/history?limit=5': No scheme supplied. Perhaps you meant https:///api/briefing/history?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestSanitizerIntegration.test_multiple_paraphrases_no_sfx ___________

self = <test_ai_sanitizer_v37.TestSanitizerIntegration object at 0xfd9f683b5090>

    def test_multiple_paraphrases_no_sfx(self):
        """Test multiple paraphrase calls to verify consistent sanitization"""
        test_texts = [
            "The president gave an emotional speech today, with the crowd erupting in applause.",
            "Dramatic scenes at the stadium as the team won the championship with a last-minute goal.",
            "The ceremony opened with traditional music and cultural performances."
        ]
    
        all_clean = True
        for i, text in enumerate(test_texts):
>           response = requests.post(
                f"{BASE_URL}/api/paraphrase",
                json={"text": text, "style": "broadcast"},
                timeout=60
            )

backend/tests/test_ai_sanitizer_v37.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/paraphrase', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/paraphrase': No scheme supplied. Perhaps you meant https:///api/paraphrase?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestRegressionEndpoints.test_voices_endpoint _________________

self = <test_ai_sanitizer_v37.TestRegressionEndpoints object at 0xfd9f683b55d0>

    def test_voices_endpoint(self):
        """GET /api/voices should return voice profiles"""
>       response = requests.get(f"{BASE_URL}/api/voices", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestRegressionEndpoints.test_categories_endpoint _______________

self = <test_ai_sanitizer_v37.TestRegressionEndpoints object at 0xfd9f683b5910>

    def test_categories_endpoint(self):
        """GET /api/categories should return news categories"""
>       response = requests.get(f"{BASE_URL}/api/categories", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/categories', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/categories': No scheme supplied. Perhaps you meant https:///api/categories?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestRegressionEndpoints.test_regions_endpoint _________________

self = <test_ai_sanitizer_v37.TestRegressionEndpoints object at 0xfd9f683b5f10>

    def test_regions_endpoint(self):
        """GET /api/regions should return available regions"""
>       response = requests.get(f"{BASE_URL}/api/regions", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/regions', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/regions': No scheme supplied. Perhaps you meant https:///api/regions?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestRegressionEndpoints.test_metrics_endpoint _________________

self = <test_ai_sanitizer_v37.TestRegressionEndpoints object at 0xfd9f683b6590>

    def test_metrics_endpoint(self):
        """GET /api/metrics should return platform metrics"""
>       response = requests.get(f"{BASE_URL}/api/metrics", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_ai_sanitizer_v37.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestSettingsAPI.test_get_default_settings ___________________

self = <test_emptystate_truthtag_share.TestSettingsAPI object at 0xfd9f683bcd10>

    def test_get_default_settings(self):
        """Test getting default settings for new user"""
>       response = requests.get(f"{BASE_URL}/api/settings/new-test-user-001")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/settings/new-test-user-001'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/new-test-user-001': No scheme supplied. Perhaps you meant https:///api/settings/new-test-user-001?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestSettingsAPI.test_save_user_settings ____________________

self = <test_emptystate_truthtag_share.TestSettingsAPI object at 0xfd9f683bd210>

    def test_save_user_settings(self):
        """Test saving user settings"""
        settings = {
            "voice_model": "echo",
            "voice_dialect": "yoruba",
            "voice_region": "africa",
            "high_contrast": True,
            "interface_scale": "125%",
            "haptic_sync": False,
            "alert_volume": 80,
            "data_limit": 5.0,
            "bandwidth_priority": "quality",
            "display_density": "compact",
            "font_scale": 110,
            "gestural_swipe": True,
            "gestural_pinch": True,
            "voice_commands": True
        }
>       response = requests.post(
            f"{BASE_URL}/api/settings/test-settings-user-002",
            json=settings
        )

backend/tests/test_emptystate_truthtag_share.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/settings/test-settings-user-002'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/test-settings-user-002': No scheme supplied. Perhaps you meant https:///api/settings/test-settings-user-002?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestVoiceSettingsAPI.test_get_voice_settings _________________

self = <test_emptystate_truthtag_share.TestVoiceSettingsAPI object at 0xfd9f683bdc10>

    def test_get_voice_settings(self):
        """Test getting voice settings"""
>       response = requests.get(f"{BASE_URL}/api/settings/voice-test-user-003/voice")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/settings/voice-test-user-003/voice'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/voice-test-user-003/voice': No scheme supplied. Perhaps you meant https:///api/settings/voice-test-user-003/voice?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestVoiceSettingsAPI.test_save_voice_settings _________________

self = <test_emptystate_truthtag_share.TestVoiceSettingsAPI object at 0xfd9f683be250>

    def test_save_voice_settings(self):
        """Test saving voice settings via query params"""
>       response = requests.post(
            f"{BASE_URL}/api/settings/voice-test-user-004/voice",
            params={
                "voice_model": "shimmer",
                "voice_dialect": "igbo",
                "voice_region": "africa"
            }
        )

backend/tests/test_emptystate_truthtag_share.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/settings/voice-test-user-004/voice'
params = OrderedDict([('voice_model', 'shimmer'), ('voice_dialect', 'igbo'), ('voice_region', 'africa')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/voice-test-user-004/voice': No scheme supplied. Perhaps you meant https:///api/settings/voice-test-user-004/voice?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestVoiceSettingsAPI.test_voice_settings_persistence _____________

self = <test_emptystate_truthtag_share.TestVoiceSettingsAPI object at 0xfd9f683be890>

    def test_voice_settings_persistence(self):
        """Test that voice settings persist correctly"""
        user_id = "voice-persist-test-005"
    
        # Save settings
>       requests.post(
            f"{BASE_URL}/api/settings/{user_id}/voice",
            params={
                "voice_model": "alloy",
                "voice_dialect": "hausa",
                "voice_region": "africa"
            }
        )

backend/tests/test_emptystate_truthtag_share.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/settings/voice-persist-test-005/voice'
params = OrderedDict([('voice_model', 'alloy'), ('voice_dialect', 'hausa'), ('voice_region', 'africa')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/voice-persist-test-005/voice': No scheme supplied. Perhaps you meant https:///api/settings/voice-persist-test-005/voice?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestFactCheckAPI.test_factcheck_story _____________________

self = <test_emptystate_truthtag_share.TestFactCheckAPI object at 0xfd9f683b4f50>

    def test_factcheck_story(self):
        """Test fact-checking a story by ID"""
>       response = requests.get(f"{BASE_URL}/api/factcheck/test-story-id-001")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/test-story-id-001'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/test-story-id-001': No scheme supplied. Perhaps you meant https:///api/factcheck/test-story-id-001?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestFactCheckAPI.test_factcheck_different_stories _______________

self = <test_emptystate_truthtag_share.TestFactCheckAPI object at 0xfd9f683be0d0>

    def test_factcheck_different_stories(self):
        """Test that different story IDs return different results"""
        story_ids = ["story-a", "story-b", "story-c", "story-d", "story-e"]
        results = []
    
        for story_id in story_ids:
>           response = requests.get(f"{BASE_URL}/api/factcheck/{story_id}")
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/story-a'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/story-a': No scheme supplied. Perhaps you meant https:///api/factcheck/story-a?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestFactCheckAPI.test_factcheck_analyze_verified _______________

self = <test_emptystate_truthtag_share.TestFactCheckAPI object at 0xfd9f683bdb10>

    def test_factcheck_analyze_verified(self):
        """Test analyze endpoint with verified keywords"""
>       response = requests.post(
            f"{BASE_URL}/api/factcheck/analyze",
            params={"text": "The government has confirmed the new policy changes"}
        )

backend/tests/test_emptystate_truthtag_share.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/factcheck/analyze'
params = OrderedDict([('text', 'The government has confirmed the new policy changes')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestFactCheckAPI.test_factcheck_analyze_disputed _______________

self = <test_emptystate_truthtag_share.TestFactCheckAPI object at 0xfd9f683bd750>

    def test_factcheck_analyze_disputed(self):
        """Test analyze endpoint with disputed keywords"""
>       response = requests.post(
            f"{BASE_URL}/api/factcheck/analyze",
            params={"text": "This disputed claim has been circulating online"}
        )

backend/tests/test_emptystate_truthtag_share.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/factcheck/analyze'
params = OrderedDict([('text', 'This disputed claim has been circulating online')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestFactCheckAPI.test_factcheck_analyze_neutral ________________

self = <test_emptystate_truthtag_share.TestFactCheckAPI object at 0xfd9f683bef50>

    def test_factcheck_analyze_neutral(self):
        """Test analyze endpoint with neutral text"""
>       response = requests.post(
            f"{BASE_URL}/api/factcheck/analyze",
            params={"text": "The weather today is sunny and warm"}
        )

backend/tests/test_emptystate_truthtag_share.py:173: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/factcheck/analyze'
params = OrderedDict([('text', 'The weather today is sunny and warm')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________________ TestVoicesAPI.test_get_voices _________________________

self = <test_emptystate_truthtag_share.TestVoicesAPI object at 0xfd9f683bf450>

    def test_get_voices(self):
        """Test getting available voice profiles"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________________ TestVoicesAPI.test_voice_ids_valid ______________________

self = <test_emptystate_truthtag_share.TestVoicesAPI object at 0xfd9f683bf890>

    def test_voice_ids_valid(self):
        """Test that voice IDs are valid OpenAI voices"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________________ TestNewsAPI.test_get_news_list ________________________

self = <test_emptystate_truthtag_share.TestNewsAPI object at 0xfd9f683cc110>

    def test_get_news_list(self):
        """Test getting news list"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestNewsAPI.test_news_has_id_for_truthtag ___________________

self = <test_emptystate_truthtag_share.TestNewsAPI object at 0xfd9f683cc750>

    def test_news_has_id_for_truthtag(self):
        """Test that news items have IDs for TruthTag lookup"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=3")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=3'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=3': No scheme supplied. Perhaps you meant https:///api/news?limit=3?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestBookmarksAPI.test_get_empty_bookmarks ___________________

self = <test_emptystate_truthtag_share.TestBookmarksAPI object at 0xfd9f683ccfd0>

    def test_get_empty_bookmarks(self):
        """Test getting bookmarks for user with no bookmarks"""
>       response = requests.get(
            f"{BASE_URL}/api/bookmarks",
            params={"user_id": "empty-bookmarks-user-001"}
        )

backend/tests/test_emptystate_truthtag_share.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/bookmarks'
params = OrderedDict([('user_id', 'empty-bookmarks-user-001')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestBookmarksAPI.test_add_and_get_bookmark __________________

self = <test_emptystate_truthtag_share.TestBookmarksAPI object at 0xfd9f683cd610>

    def test_add_and_get_bookmark(self):
        """Test adding and retrieving a bookmark"""
        user_id = "bookmark-test-user-002"
    
        # Add bookmark
        bookmark_data = {
            "user_id": user_id,
            "story_id": "test-story-bookmark-001",
            "title": "Test Story Title",
            "summary": "Test story summary",
            "source": "Test Source",
            "category": "Tech"
        }
>       add_response = requests.post(f"{BASE_URL}/api/bookmarks", json=bookmark_data)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_emptystate_truthtag_share.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/bookmarks', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestBookmarksAPI.test_remove_bookmark _____________________

self = <test_emptystate_truthtag_share.TestBookmarksAPI object at 0xfd9f683cdc50>

    def test_remove_bookmark(self):
        """Test removing a bookmark"""
        user_id = "bookmark-remove-user-003"
        story_id = "test-story-remove-001"
    
        # Add bookmark first
>       requests.post(f"{BASE_URL}/api/bookmarks", json={
            "user_id": user_id,
            "story_id": story_id,
            "title": "Story to Remove"
        })

backend/tests/test_emptystate_truthtag_share.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/bookmarks', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestHealthMonitoringAPI.test_sources_health_endpoint_returns_200 _______

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683cf5d0>

    def test_sources_health_endpoint_returns_200(self):
        """Test GET /api/sources/health returns 200 OK"""
>       response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________ TestHealthMonitoringAPI.test_sources_health_has_summary_counts ________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683cfc10>

    def test_sources_health_has_summary_counts(self):
        """Test /api/sources/health returns total, green, amber, red counts"""
>       response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________ TestHealthMonitoringAPI.test_sources_health_has_sources_array _________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683d8290>

    def test_sources_health_has_sources_array(self):
        """Test /api/sources/health has sources array with required fields"""
>       response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestHealthMonitoringAPI.test_sources_health_refresh_endpoint _________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683cfdd0>

    def test_sources_health_refresh_endpoint(self):
        """Test POST /api/sources/health/refresh triggers health check"""
>       response = requests.post(f"{BASE_URL}/api/sources/health/refresh", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/sources/health/refresh'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health/refresh': No scheme supplied. Perhaps you meant https:///api/sources/health/refresh?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestHealthMonitoringAPI.test_sources_health_regions_covered __________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683bfe50>

    def test_sources_health_regions_covered(self):
        """Test /api/sources/health covers all 3 regions"""
>       response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestHealthMonitoringAPI.test_health_refresh_then_verify_updated ________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f6838bb50>

    def test_health_refresh_then_verify_updated(self):
        """Test that refresh triggers update and data changes"""
        # Get initial health state
>       initial_response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestHealthMonitoringAPI.test_health_sources_latency_values __________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683d8810>

    def test_health_sources_latency_values(self):
        """Test that sources have reasonable latency values"""
>       response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestHealthMonitoringAPI.test_health_last_checked_format ____________

self = <test_health_monitoring_v30.TestHealthMonitoringAPI object at 0xfd9f683d8b50>

    def test_health_last_checked_format(self):
        """Test that last_checked is ISO format timestamp or None"""
>       response = requests.get(f"{BASE_URL}/api/sources/health", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestExistingFeaturesRegression.test_api_sources_still_returns_39 _______

self = <test_health_monitoring_v30.TestExistingFeaturesRegression object at 0xfd9f683d9190>

    def test_api_sources_still_returns_39(self):
        """Test /api/sources still returns 39 total sources"""
>       response = requests.get(f"{BASE_URL}/api/sources", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources': No scheme supplied. Perhaps you meant https:///api/sources?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestExistingFeaturesRegression.test_api_metrics_endpoint ___________

self = <test_health_monitoring_v30.TestExistingFeaturesRegression object at 0xfd9f683d95d0>

    def test_api_metrics_endpoint(self):
        """Test /api/metrics endpoint still works"""
>       response = requests.get(f"{BASE_URL}/api/metrics", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestExistingFeaturesRegression.test_api_news_endpoint _____________

self = <test_health_monitoring_v30.TestExistingFeaturesRegression object at 0xfd9f683d9c10>

    def test_api_news_endpoint(self):
        """Test /api/news endpoint still works"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestExistingFeaturesRegression.test_api_health_endpoint ____________

self = <test_health_monitoring_v30.TestExistingFeaturesRegression object at 0xfd9f683da290>

    def test_api_health_endpoint(self):
        """Test /api/health endpoint still works"""
>       response = requests.get(f"{BASE_URL}/api/health", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_health_monitoring_v30.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestSettingsAPI.test_get_default_settings_for_guest ______________

self = <test_i18n_settings_v16.TestSettingsAPI object at 0xfd9f683e0690>

    def test_get_default_settings_for_guest(self):
        """GET /api/settings/guest returns default settings"""
>       response = requests.get(f"{BASE_URL}/api/settings/guest")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/settings/guest'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/guest': No scheme supplied. Perhaps you meant https:///api/settings/guest?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestSettingsAPI.test_save_system_settings ___________________

self = <test_i18n_settings_v16.TestSettingsAPI object at 0xfd9f683e0cd0>

    def test_save_system_settings(self):
        """POST /api/settings/test_user saves system settings"""
        test_user = "TEST_user_system_123"
        payload = {
            "high_contrast": True,
            "interface_scale": "compact",
            "haptic_sync": False,
            "alert_volume": 75,
            "data_limit": 3.0,
            "bandwidth_priority": "ingest"
        }
    
>       response = requests.post(
            f"{BASE_URL}/api/settings/{test_user}",
            json=payload
        )

backend/tests/test_i18n_settings_v16.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/settings/TEST_user_system_123'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/TEST_user_system_123': No scheme supplied. Perhaps you meant https:///api/settings/TEST_user_system_123?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestSettingsAPI.test_save_accessibility_settings _______________

self = <test_i18n_settings_v16.TestSettingsAPI object at 0xfd9f683e1310>

    def test_save_accessibility_settings(self):
        """POST /api/settings/test_user saves accessibility settings"""
        test_user = "TEST_user_accessibility_456"
        payload = {
            "display_density": "compact",
            "font_scale": 125,
            "gestural_swipe": False,
            "gestural_pinch": True
        }
    
>       response = requests.post(
            f"{BASE_URL}/api/settings/{test_user}",
            json=payload
        )

backend/tests/test_i18n_settings_v16.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>
url = '/api/settings/TEST_user_accessibility_456', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/TEST_user_accessibility_456': No scheme supplied. Perhaps you meant https:///api/settings/TEST_user_accessibility_456?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestSettingsAPI.test_settings_merge_behavior _________________

self = <test_i18n_settings_v16.TestSettingsAPI object at 0xfd9f683e1990>

    def test_settings_merge_behavior(self):
        """Settings should merge, not overwrite"""
        test_user = "TEST_user_merge_789"
    
        # First save system settings
>       requests.post(f"{BASE_URL}/api/settings/{test_user}", json={
            "high_contrast": True,
            "alert_volume": 80
        })

backend/tests/test_i18n_settings_v16.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/settings/TEST_user_merge_789'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/TEST_user_merge_789': No scheme supplied. Perhaps you meant https:///api/settings/TEST_user_merge_789?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________________ TestNewsDetailAPI.test_get_news_list _____________________

self = <test_i18n_settings_v16.TestNewsDetailAPI object at 0xfd9f683e2250>

    def test_get_news_list(self):
        """GET /api/news returns list of news items"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestNewsDetailAPI.test_get_news_detail_with_narrative _____________

self = <test_i18n_settings_v16.TestNewsDetailAPI object at 0xfd9f683d88d0>

    def test_get_news_detail_with_narrative(self):
        """GET /api/news/{id} returns detailed news with narrative"""
        # First get a valid news ID
>       list_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestNewsDetailAPI.test_factcheck_api_for_truthtag _______________

self = <test_i18n_settings_v16.TestNewsDetailAPI object at 0xfd9f683e20d0>

    def test_factcheck_api_for_truthtag(self):
        """GET /api/factcheck/{story_id} returns verification status for TruthTag"""
        # Get a news ID first
>       list_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestRadioAPI.test_get_radio_countries _____________________

self = <test_i18n_settings_v16.TestRadioAPI object at 0xfd9f683e0810>

    def test_get_radio_countries(self):
        """GET /api/radio/countries returns African countries"""
>       response = requests.get(f"{BASE_URL}/api/radio/countries")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/countries'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/countries': No scheme supplied. Perhaps you meant https:///api/radio/countries?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestRadioAPI.test_get_radio_stations_by_country ________________

self = <test_i18n_settings_v16.TestRadioAPI object at 0xfd9f683e2810>

    def test_get_radio_stations_by_country(self):
        """GET /api/radio/stations?country=NG returns Nigerian stations"""
>       response = requests.get(f"{BASE_URL}/api/radio/stations?country=NG&limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/stations?country=NG&limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/stations?country=NG&limit=5': No scheme supplied. Perhaps you meant https:///api/radio/stations?country=NG&limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________________ TestVoicesAPI.test_get_voices _________________________

self = <test_i18n_settings_v16.TestVoicesAPI object at 0xfd9f683e2d50>

    def test_get_voices(self):
        """GET /api/voices returns voice profiles"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:222: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestVoicesAPI.test_save_voice_settings ____________________

self = <test_i18n_settings_v16.TestVoicesAPI object at 0xfd9f683e3090>

    def test_save_voice_settings(self):
        """POST /api/settings/{user_id}/voice saves voice preferences"""
        test_user = "TEST_voice_user_111"
    
>       response = requests.post(
            f"{BASE_URL}/api/settings/{test_user}/voice",
            params={
                "voice_model": "onyx",
                "voice_dialect": "pidgin",
                "voice_region": "west_africa"
            }
        )

backend/tests/test_i18n_settings_v16.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/settings/TEST_voice_user_111/voice'
params = OrderedDict([('voice_model', 'onyx'), ('voice_dialect', 'pidgin'), ('voice_region', 'west_africa')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/TEST_voice_user_111/voice': No scheme supplied. Perhaps you meant https:///api/settings/TEST_voice_user_111/voice?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________________ TestHealthAPI.test_health_endpoint ______________________

self = <test_i18n_settings_v16.TestHealthAPI object at 0xfd9f683e3790>

    def test_health_endpoint(self):
        """GET /api/health returns status"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_i18n_settings_v16.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______ TestPodcastEndpoints.test_podcast_categories_returns_8_categories _______

self = <test_iteration42.TestPodcastEndpoints object at 0xfd9f682b8690>

    def test_podcast_categories_returns_8_categories(self):
        """Test 11: GET /api/podcasts/categories returns array of 8 categories"""
        response = requests.get(f"{BASE_URL}/api/podcasts/categories")
    
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration42.py:22: AssertionError
__________ TestPodcastEndpoints.test_podcast_search_with_arctic_query __________

self = <test_iteration42.TestPodcastEndpoints object at 0xfd9f682b8790>

    def test_podcast_search_with_arctic_query(self):
        """Test 12: GET /api/podcasts/search?q=arctic returns results"""
        response = requests.get(f"{BASE_URL}/api/podcasts/search", params={"q": "arctic"})
    
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration42.py:43: AssertionError
___________ TestPodcastEndpoints.test_podcast_list_returns_episodes ____________

self = <test_iteration42.TestPodcastEndpoints object at 0xfd9f682b8d10>

    def test_podcast_list_returns_episodes(self):
        """Test podcasts list endpoint"""
        response = requests.get(f"{BASE_URL}/api/podcasts", params={"limit": 6})
    
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration42.py:60: AssertionError
________ TestSettingsPersistence.test_save_and_retrieve_guest_settings _________

self = <test_iteration42.TestSettingsPersistence object at 0xfd9f682b9410>

    def test_save_and_retrieve_guest_settings(self):
        """Test 13: POST /api/settings/guest saves and GET /api/settings/guest retrieves settings"""
        # Save settings
        test_settings = {
            "voice_model": "echo",
            "broadcast_language": "pcm",
            "theme": "dark"
        }
    
        save_response = requests.post(
            f"{BASE_URL}/api/settings/guest",
            json=test_settings,
            headers={"Content-Type": "application/json"}
        )
    
>       assert save_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration42.py:90: AssertionError
_____________ TestSettingsPersistence.test_settings_merge_behavior _____________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration42.TestSettingsPersistence object at 0xfd9f682b9b90>

    def test_settings_merge_behavior(self):
        """Test that settings merge correctly without overwriting all fields"""
        # First, get current settings
>       initial = requests.get(f"{BASE_URL}/api/settings/guest").json()
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration42.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
_____________ TestVoicesEndpoint.test_voices_returns_all_profiles ______________

self = <test_iteration42.TestVoicesEndpoint object at 0xfd9f682bb950>

    def test_voices_returns_all_profiles(self):
        """Test voices endpoint returns voice profiles"""
        response = requests.get(f"{BASE_URL}/api/voices")
    
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration42.py:128: AssertionError
______________________ TestHealthEndpoint.test_api_health ______________________

self = <test_iteration42.TestHealthEndpoint object at 0xfd9f682ba650>

    def test_api_health(self):
        """Test API health endpoint"""
        response = requests.get(f"{BASE_URL}/api/health")
    
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration42.py:150: AssertionError
______________ TestBreakingNewsAPI.test_breaking_news_returns_200 ______________

self = <test_iteration_17.TestBreakingNewsAPI object at 0xfd9f68219550>

    def test_breaking_news_returns_200(self):
        """Breaking news endpoint should return 200"""
        response = requests.get(f"{BASE_URL}/api/news/breaking", timeout=30)
>       assert response.status_code == 200, f"Expected 200, got {response.status_code}"
E       AssertionError: Expected 200, got 502
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_17.py:20: AssertionError
_____________ TestBreakingNewsAPI.test_breaking_news_returns_list ______________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_17.TestBreakingNewsAPI object at 0xfd9f68219690>

    def test_breaking_news_returns_list(self):
        """Breaking news should return a list"""
        response = requests.get(f"{BASE_URL}/api/news/breaking", timeout=30)
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_17.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
________ TestBreakingNewsAPI.test_breaking_news_has_at_least_one_story _________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_17.TestBreakingNewsAPI object at 0xfd9f68219990>

    def test_breaking_news_has_at_least_one_story(self):
        """Breaking news should return at least 1 story (most recent if no natural breaking)"""
        response = requests.get(f"{BASE_URL}/api/news/breaking", timeout=30)
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_17.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
____________ TestBreakingNewsAPI.test_breaking_news_story_structure ____________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_17.TestBreakingNewsAPI object at 0xfd9f68219ed0>

    def test_breaking_news_story_structure(self):
        """Breaking news stories should have required fields"""
        response = requests.get(f"{BASE_URL}/api/news/breaking", timeout=30)
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_17.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
______________________ TestNewsAPI.test_news_returns_200 _______________________

self = <test_iteration_17.TestNewsAPI object at 0xfd9f6821a290>

    def test_news_returns_200(self):
        """News endpoint should return 200"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=30)
>       assert response.status_code == 200, f"Expected 200, got {response.status_code}"
E       AssertionError: Expected 200, got 502
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_17.py:58: AssertionError
________________ TestNewsAPI.test_news_returns_list_with_items _________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_17.TestNewsAPI object at 0xfd9f6821ad50>

    def test_news_returns_list_with_items(self):
        """News endpoint should return a list with items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=30)
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_17.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
___________________ TestNewsAPI.test_news_has_category_field ___________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_17.TestNewsAPI object at 0xfd9f68218d50>

    def test_news_has_category_field(self):
        """News items should have category field for category images"""
        response = requests.get(f"{BASE_URL}/api/news?limit=10", timeout=30)
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_17.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
_____________________ TestNewsAPI.test_news_has_tags_field _____________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_17.TestNewsAPI object at 0xfd9f6821bc90>

    def test_news_has_tags_field(self):
        """News items should have tags field"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=30)
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_17.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
________________ TestRouteOrdering.test_breaking_before_news_id ________________

self = <test_iteration_17.TestRouteOrdering object at 0xfd9f68219390>

    def test_breaking_before_news_id(self):
        """Ensure /api/news/breaking works (route ordering correct)"""
        # This verifies that "breaking" is not interpreted as a news_id
        response = requests.get(f"{BASE_URL}/api/news/breaking", timeout=30)
        # Should NOT return 404 for news_id "breaking"
>       assert response.status_code == 200, f"Route ordering issue: /api/news/breaking got {response.status_code}"
E       AssertionError: Route ordering issue: /api/news/breaking got 502
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_17.py:97: AssertionError
____________________ TestHealthAndMetrics.test_health_check ____________________

self = <test_iteration_17.TestHealthAndMetrics object at 0xfd9f68219090>

    def test_health_check(self):
        """Health endpoint should return online status"""
        response = requests.get(f"{BASE_URL}/api/health", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_17.py:110: AssertionError
__________________ TestHealthAndMetrics.test_metrics_endpoint __________________

self = <test_iteration_17.TestHealthAndMetrics object at 0xfd9f683ee7d0>

    def test_metrics_endpoint(self):
        """Metrics endpoint should return data for dashboard"""
        response = requests.get(f"{BASE_URL}/api/metrics", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_17.py:118: AssertionError
__________________ TestCategoriesAPI.test_categories_endpoint __________________

self = <test_iteration_17.TestCategoriesAPI object at 0xfd9f683eea90>

    def test_categories_endpoint(self):
        """Categories endpoint should return category list"""
        response = requests.get(f"{BASE_URL}/api/categories", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_17.py:131: AssertionError
___________________ TestHealthAndBasics.test_health_endpoint ___________________

self = <test_iteration_18.TestHealthAndBasics object at 0xfd9f6821b110>

    def test_health_endpoint(self):
        """Test /api/health returns online status"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestBreakingNewsAPI.test_breaking_news_endpoint_returns_200 __________

self = <test_iteration_18.TestBreakingNewsAPI object at 0xfd9f683ee910>

    def test_breaking_news_endpoint_returns_200(self):
        """Test /api/news/breaking returns 200"""
>       response = requests.get(f"{BASE_URL}/api/news/breaking")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/breaking'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/breaking': No scheme supplied. Perhaps you meant https:///api/news/breaking?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestBreakingNewsAPI.test_breaking_news_returns_list ______________

self = <test_iteration_18.TestBreakingNewsAPI object at 0xfd9f683ee6d0>

    def test_breaking_news_returns_list(self):
        """Test /api/news/breaking returns a list"""
>       response = requests.get(f"{BASE_URL}/api/news/breaking")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/breaking'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/breaking': No scheme supplied. Perhaps you meant https:///api/news/breaking?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestBreakingNewsAPI.test_breaking_news_has_stories ______________

self = <test_iteration_18.TestBreakingNewsAPI object at 0xfd9f683eef90>

    def test_breaking_news_has_stories(self):
        """Test /api/news/breaking returns at least 1 story"""
>       response = requests.get(f"{BASE_URL}/api/news/breaking")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/breaking'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/breaking': No scheme supplied. Perhaps you meant https:///api/news/breaking?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestBreakingNewsAPI.test_breaking_news_story_structure ____________

self = <test_iteration_18.TestBreakingNewsAPI object at 0xfd9f683edf10>

    def test_breaking_news_story_structure(self):
        """Test breaking news stories have required fields"""
>       response = requests.get(f"{BASE_URL}/api/news/breaking")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/breaking'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/breaking': No scheme supplied. Perhaps you meant https:///api/news/breaking?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestBreakingNewsAPI.test_breaking_news_max_3_stories _____________

self = <test_iteration_18.TestBreakingNewsAPI object at 0xfd9f683edd50>

    def test_breaking_news_max_3_stories(self):
        """Test /api/news/breaking returns max 3 stories"""
>       response = requests.get(f"{BASE_URL}/api/news/breaking")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/breaking'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/breaking': No scheme supplied. Perhaps you meant https:///api/news/breaking?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestMetricsAPI.test_metrics_endpoint_returns_200 _______________

self = <test_iteration_18.TestMetricsAPI object at 0xfd9f68210b90>

    def test_metrics_endpoint_returns_200(self):
        """Test /api/metrics returns 200"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestMetricsAPI.test_metrics_has_required_fields ________________

self = <test_iteration_18.TestMetricsAPI object at 0xfd9f68213510>

    def test_metrics_has_required_fields(self):
        """Test /api/metrics returns required fields"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestMetricsAPI.test_metrics_values_are_valid _________________

self = <test_iteration_18.TestMetricsAPI object at 0xfd9f68213290>

    def test_metrics_values_are_valid(self):
        """Test /api/metrics returns valid values"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestOGImageEndpoint.test_og_endpoint_returns_html _______________

self = <test_iteration_18.TestOGImageEndpoint object at 0xfd9f68212d10>

    def test_og_endpoint_returns_html(self):
        """Test /api/og/{news_id} returns HTML"""
        # First get a valid news_id
>       news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestOGImageEndpoint.test_og_endpoint_has_og_title _______________

self = <test_iteration_18.TestOGImageEndpoint object at 0xfd9f68213b10>

    def test_og_endpoint_has_og_title(self):
        """Test /api/og/{news_id} has og:title meta tag"""
>       news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestOGImageEndpoint.test_og_endpoint_has_og_description ____________

self = <test_iteration_18.TestOGImageEndpoint object at 0xfd9f68210b10>

    def test_og_endpoint_has_og_description(self):
        """Test /api/og/{news_id} has og:description meta tag"""
>       news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestOGImageEndpoint.test_og_endpoint_has_twitter_card _____________

self = <test_iteration_18.TestOGImageEndpoint object at 0xfd9f68210150>

    def test_og_endpoint_has_twitter_card(self):
        """Test /api/og/{news_id} has twitter:card meta tag"""
>       news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestOGImageEndpoint.test_og_endpoint_invalid_id_returns_404 __________

self = <test_iteration_18.TestOGImageEndpoint object at 0xfd9f68211650>

    def test_og_endpoint_invalid_id_returns_404(self):
        """Test /api/og/{invalid_id} returns 404"""
>       response = requests.get(f"{BASE_URL}/api/og/invalid_nonexistent_id_12345")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/og/invalid_nonexistent_id_12345'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/og/invalid_nonexistent_id_12345': No scheme supplied. Perhaps you meant https:///api/og/invalid_nonexistent_id_12345?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestNewsAPI.test_news_endpoint_returns_200 __________________

self = <test_iteration_18.TestNewsAPI object at 0xfd9f68211890>

    def test_news_endpoint_returns_200(self):
        """Test /api/news returns 200"""
>       response = requests.get(f"{BASE_URL}/api/news")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news': No scheme supplied. Perhaps you meant https:///api/news?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________________ TestNewsAPI.test_news_returns_list ______________________

self = <test_iteration_18.TestNewsAPI object at 0xfd9f6827c510>

    def test_news_returns_list(self):
        """Test /api/news returns a list"""
>       response = requests.get(f"{BASE_URL}/api/news")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news': No scheme supplied. Perhaps you meant https:///api/news?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestNewsAPI.test_news_limit_parameter _____________________

self = <test_iteration_18.TestNewsAPI object at 0xfd9f6827cf10>

    def test_news_limit_parameter(self):
        """Test /api/news respects limit parameter"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________________ TestNewsAPI.test_news_item_structure _____________________

self = <test_iteration_18.TestNewsAPI object at 0xfd9f68211b10>

    def test_news_item_structure(self):
        """Test news items have required fields"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=1")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestNewsDetailAPI.test_news_detail_returns_200 ________________

self = <test_iteration_18.TestNewsDetailAPI object at 0xfd9f68211410>

    def test_news_detail_returns_200(self):
        """Test /api/news/{id} returns 200 for valid id"""
        # First get a valid news_id
>       news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestNewsDetailAPI.test_news_detail_invalid_id_returns_404 ___________

self = <test_iteration_18.TestNewsDetailAPI object at 0xfd9f682138d0>

    def test_news_detail_invalid_id_returns_404(self):
        """Test /api/news/{invalid_id} returns 404"""
>       response = requests.get(f"{BASE_URL}/api/news/invalid_nonexistent_id_12345")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_18.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/invalid_nonexistent_id_12345'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/invalid_nonexistent_id_12345': No scheme supplied. Perhaps you meant https:///api/news/invalid_nonexistent_id_12345?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestHealthAndBasicAPIs.test_health_endpoint __________________

self = <test_iteration_19.TestHealthAndBasicAPIs object at 0xfd9f67fd0690>

    def test_health_endpoint(self):
        """Test /api/health returns 200"""
        response = requests.get(f"{BASE_URL}/api/health", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:18: AssertionError
__________________ TestHealthAndBasicAPIs.test_news_endpoint ___________________

self = <test_iteration_19.TestHealthAndBasicAPIs object at 0xfd9f67fd10d0>

    def test_news_endpoint(self):
        """Test /api/news returns news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:26: AssertionError
_______________ TestHealthAndBasicAPIs.test_categories_endpoint ________________

self = <test_iteration_19.TestHealthAndBasicAPIs object at 0xfd9f67fd1450>

    def test_categories_endpoint(self):
        """Test /api/categories returns categories"""
        response = requests.get(f"{BASE_URL}/api/categories", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:35: AssertionError
_____________________ TestSearchAPI.test_search_with_query _____________________

self = <test_iteration_19.TestSearchAPI object at 0xfd9f67fd1cd0>

    def test_search_with_query(self):
        """Test /api/search?q=africa returns results"""
        response = requests.get(f"{BASE_URL}/api/search?q=africa", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:48: AssertionError
________________ TestSearchAPI.test_search_with_category_filter ________________

self = <test_iteration_19.TestSearchAPI object at 0xfd9f67fd21d0>

    def test_search_with_category_filter(self):
        """Test /api/search with category filter"""
        response = requests.get(f"{BASE_URL}/api/search?q=news&category=politics", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:59: AssertionError
____________________ TestSearchAPI.test_search_empty_query _____________________

self = <test_iteration_19.TestSearchAPI object at 0xfd9f67fd2710>

    def test_search_empty_query(self):
        """Test /api/search with empty query returns error or empty"""
        response = requests.get(f"{BASE_URL}/api/search?q=", timeout=10)
        # Should either return 422 (validation error) or empty results
>       assert response.status_code in [200, 422]
E       assert 502 in [200, 422]
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:70: AssertionError
_____________________ TestSearchAPI.test_search_pagination _____________________

self = <test_iteration_19.TestSearchAPI object at 0xfd9f67fd1f10>

    def test_search_pagination(self):
        """Test /api/search pagination with skip and limit"""
        response = requests.get(f"{BASE_URL}/api/search?q=nigeria&limit=5&skip=0", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:79: AssertionError
____________________ TestTrendingAPI.test_trending_endpoint ____________________

self = <test_iteration_19.TestTrendingAPI object at 0xfd9f67fd3ad0>

    def test_trending_endpoint(self):
        """Test /api/trending returns tags and topics"""
        response = requests.get(f"{BASE_URL}/api/trending", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:92: AssertionError
__________________ TestTrendingAPI.test_trending_tags_format ___________________

self = <test_iteration_19.TestTrendingAPI object at 0xfd9f67fddd50>

    def test_trending_tags_format(self):
        """Test trending tags are in correct format (hashtags)"""
        response = requests.get(f"{BASE_URL}/api/trending", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:103: AssertionError
____________________ TestBriefingAPI.test_briefing_history _____________________

self = <test_iteration_19.TestBriefingAPI object at 0xfd9f67fde510>

    def test_briefing_history(self):
        """Test /api/briefing/history returns briefings list"""
        response = requests.get(f"{BASE_URL}/api/briefing/history?limit=14", timeout=15)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:117: AssertionError
_____________________ TestBriefingAPI.test_briefing_latest _____________________

self = <test_iteration_19.TestBriefingAPI object at 0xfd9f67fde950>

    def test_briefing_latest(self):
        """Test /api/briefing/latest returns latest briefing or 404"""
        response = requests.get(f"{BASE_URL}/api/briefing/latest", timeout=15)
        # May return 404 if no briefing exists yet
>       assert response.status_code in [200, 404]
E       assert 502 in [200, 404]
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:128: AssertionError
________________ TestBriefingAPI.test_briefing_by_date_invalid _________________

self = <test_iteration_19.TestBriefingAPI object at 0xfd9f67fdf010>

    def test_briefing_by_date_invalid(self):
        """Test /api/briefing/{date} with invalid date returns 404"""
        response = requests.get(f"{BASE_URL}/api/briefing/1900-01-01", timeout=10)
>       assert response.status_code == 404
E       assert 502 == 404
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:139: AssertionError
______________________ TestVoicesAPI.test_voices_endpoint ______________________

self = <test_iteration_19.TestVoicesAPI object at 0xfd9f67fdf650>

    def test_voices_endpoint(self):
        """Test /api/voices returns voice profiles"""
        response = requests.get(f"{BASE_URL}/api/voices", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:149: AssertionError
__________________ TestBookmarksAPI.test_get_bookmarks_guest ___________________

self = <test_iteration_19.TestBookmarksAPI object at 0xfd9f67fdc410>

    def test_get_bookmarks_guest(self):
        """Test /api/bookmarks?user_id=guest returns bookmarks"""
        response = requests.get(f"{BASE_URL}/api/bookmarks?user_id=guest", timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:167: AssertionError
______________________ TestBookmarksAPI.test_add_bookmark ______________________

self = <test_iteration_19.TestBookmarksAPI object at 0xfd9f67fd3210>

    def test_add_bookmark(self):
        """Test POST /api/bookmarks adds a bookmark"""
        bookmark_data = {
            "user_id": "test_user_19",
            "story_id": "test_story_19",
            "title": "Test Story for Iteration 19",
            "summary": "Test summary",
            "source": "Test Source",
            "category": "General"
        }
        response = requests.post(f"{BASE_URL}/api/bookmarks", json=bookmark_data, timeout=10)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:183: AssertionError
____________________ TestBookmarksAPI.test_delete_bookmark _____________________

self = <test_iteration_19.TestBookmarksAPI object at 0xfd9f67fdc750>

    def test_delete_bookmark(self):
        """Test DELETE /api/bookmarks/{story_id} removes bookmark"""
        response = requests.delete(
            f"{BASE_URL}/api/bookmarks/test_story_19?user_id=test_user_19",
            timeout=10
        )
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:194: AssertionError
_________________________ TestTTSAPI.test_tts_generate _________________________

self = <test_iteration_19.TestTTSAPI object at 0xfd9f67fdef90>

    def test_tts_generate(self):
        """Test /api/tts/generate creates audio"""
        tts_data = {
            "text": "This is a test of the Narvo text to speech system.",
            "voice_id": "nova"
        }
        response = requests.post(f"{BASE_URL}/api/tts/generate", json=tts_data, timeout=30)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:210: AssertionError
____________________ TestOGImageAPI.test_og_image_endpoint _____________________

self = <test_iteration_19.TestOGImageAPI object at 0xfd9f67fdcb10>

    def test_og_image_endpoint(self):
        """Test /api/og/{news_id} returns HTML with OG tags"""
        # First get a valid news ID
        news_response = requests.get(f"{BASE_URL}/api/news?limit=1", timeout=15)
>       assert news_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:225: AssertionError
___________________ TestOGImageAPI.test_og_image_invalid_id ____________________

self = <test_iteration_19.TestOGImageAPI object at 0xfd9f67fdcf90>

    def test_og_image_invalid_id(self):
        """Test /api/og/{invalid_id} returns 404"""
        response = requests.get(f"{BASE_URL}/api/og/invalid_news_id_12345", timeout=10)
>       assert response.status_code == 404
E       assert 502 == 404
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_19.py:246: AssertionError
____________________ TestFactCheckAPI.test_factcheck_story _____________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_19.TestFactCheckAPI object at 0xfd9f67fdd450>

    def test_factcheck_story(self):
        """Test /api/factcheck/{story_id} returns fact-check result"""
        # Get a valid news ID first
        news_response = requests.get(f"{BASE_URL}/api/news?limit=1", timeout=15)
>       news_data = news_response.json()
                    ^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_19.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
_________________ TestHealthAndBasicAPIs.test_health_endpoint __________________

self = <test_iteration_20.TestHealthAndBasicAPIs object at 0xfd9f682521d0>

    def test_health_endpoint(self):
        """Test health endpoint returns online status"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:25: AssertionError
__________________ TestHealthAndBasicAPIs.test_news_endpoint ___________________

self = <test_iteration_20.TestHealthAndBasicAPIs object at 0xfd9f68252c10>

    def test_news_endpoint(self):
        """Test news endpoint returns news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:34: AssertionError
________ TestShareURLOGTags.test_share_endpoint_with_crawler_user_agent ________

self = <test_iteration_20.TestShareURLOGTags object at 0xfd9f68253310>

    def test_share_endpoint_with_crawler_user_agent(self):
        """Test share endpoint returns HTML with OG tags for TelegramBot"""
        # First get a valid news ID
        news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       assert news_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:54: AssertionError
_________ TestShareURLOGTags.test_share_endpoint_with_regular_browser __________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_20.TestShareURLOGTags object at 0xfd9f682503d0>

    def test_share_endpoint_with_regular_browser(self):
        """Test share endpoint redirects regular browsers to React app"""
        # Get a valid news ID
        news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       news_data = news_response.json()
                    ^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_20.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
______________ TestShareURLOGTags.test_share_endpoint_invalid_id _______________

self = <test_iteration_20.TestShareURLOGTags object at 0xfd9f68251e10>

    def test_share_endpoint_invalid_id(self):
        """Test share endpoint with invalid news ID"""
        headers = {"User-Agent": "TelegramBot"}
        response = requests.get(f"{BASE_URL}/api/share/invalid123", headers=headers)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:100: AssertionError
_____________________ TestBriefingAPI.test_briefing_latest _____________________

self = <test_iteration_20.TestBriefingAPI object at 0xfd9f68252d90>

    def test_briefing_latest(self):
        """Test latest briefing endpoint"""
        response = requests.get(f"{BASE_URL}/api/briefing/latest")
        # May return 404 if no briefing exists yet
>       assert response.status_code in [200, 404]
E       assert 502 in [200, 404]
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:114: AssertionError
____________________ TestBriefingAPI.test_briefing_history _____________________

self = <test_iteration_20.TestBriefingAPI object at 0xfd9f682511d0>

    def test_briefing_history(self):
        """Test briefing history endpoint"""
        response = requests.get(f"{BASE_URL}/api/briefing/history?limit=10")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:126: AssertionError
_____________________ TestBriefingAPI.test_voices_endpoint _____________________

self = <test_iteration_20.TestBriefingAPI object at 0xfd9f68251a50>

    def test_voices_endpoint(self):
        """Test voices endpoint for voice selector"""
        response = requests.get(f"{BASE_URL}/api/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:135: AssertionError
______________________ TestSearchAPI.test_search_endpoint ______________________

self = <test_iteration_20.TestSearchAPI object at 0xfd9f681f2490>

    def test_search_endpoint(self):
        """Test search endpoint"""
        response = requests.get(f"{BASE_URL}/api/search?q=nigeria")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:152: AssertionError
_____________________ TestSearchAPI.test_trending_endpoint _____________________

self = <test_iteration_20.TestSearchAPI object at 0xfd9f681f1250>

    def test_trending_endpoint(self):
        """Test trending endpoint for popular tags"""
        response = requests.get(f"{BASE_URL}/api/trending")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:162: AssertionError
_____________________ TestBookmarksAPI.test_get_bookmarks ______________________

self = <test_iteration_20.TestBookmarksAPI object at 0xfd9f681f1a10>

    def test_get_bookmarks(self):
        """Test get bookmarks endpoint"""
        response = requests.get(f"{BASE_URL}/api/bookmarks?user_id=test_user_iteration20")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:175: AssertionError
________________ TestBookmarksAPI.test_add_and_remove_bookmark _________________

self = <test_iteration_20.TestBookmarksAPI object at 0xfd9f681f3d50>

    def test_add_and_remove_bookmark(self):
        """Test add and remove bookmark flow"""
        user_id = "test_user_iteration20"
        story_id = "test_story_iter20"
    
        # Add bookmark
        add_response = requests.post(f"{BASE_URL}/api/bookmarks", json={
            "user_id": user_id,
            "story_id": story_id,
            "title": "Test Story for Iteration 20",
            "summary": "Test summary",
            "source": "Test Source",
            "category": "General"
        })
>       assert add_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:194: AssertionError
__________________ TestOGImageEndpoint.test_og_image_endpoint __________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_20.TestOGImageEndpoint object at 0xfd9f681f2090>

    def test_og_image_endpoint(self):
        """Test /api/og/{news_id} returns styled HTML for OG image"""
        # Get a valid news ID
        news_response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       news_data = news_response.json()
                    ^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_20.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
_________________ TestOGImageEndpoint.test_og_image_invalid_id _________________

self = <test_iteration_20.TestOGImageEndpoint object at 0xfd9f681f3c50>

    def test_og_image_invalid_id(self):
        """Test OG image endpoint with invalid ID"""
        response = requests.get(f"{BASE_URL}/api/og/invalid_id_12345")
>       assert response.status_code == 404
E       assert 502 == 404
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_20.py:239: AssertionError
__________________ TestHealthAndBasicAPI.test_health_endpoint __________________

self = <test_iteration_22.TestHealthAndBasicAPI object at 0xfd9f681447d0>

    def test_health_endpoint(self):
        """Verify API is online"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:18: AssertionError
____________ TestHealthAndBasicAPI.test_news_endpoint_returns_items ____________

self = <test_iteration_22.TestHealthAndBasicAPI object at 0xfd9f68144dd0>

    def test_news_endpoint_returns_items(self):
        """Verify news API returns items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=10")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:27: AssertionError
___________ TestHealthAndBasicAPI.test_news_item_has_required_fields ___________

self = <test_iteration_22.TestHealthAndBasicAPI object at 0xfd9f68146610>

    def test_news_item_has_required_fields(self):
        """Verify news items have required fields"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:36: AssertionError
__________ TestNewsImageExtraction.test_news_item_has_image_url_field __________

self = <test_iteration_22.TestNewsImageExtraction object at 0xfd9f68145c10>

    def test_news_item_has_image_url_field(self):
        """Verify image_url field exists in response (even if null)"""
        response = requests.get(f"{BASE_URL}/api/news?limit=10")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:53: AssertionError
____________ TestNewsImageExtraction.test_news_detail_has_image_url ____________

self = <test_iteration_22.TestNewsImageExtraction object at 0xfd9f681462d0>

    def test_news_detail_has_image_url(self):
        """Test individual news detail endpoint includes image_url"""
        # First get a news item
        response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:71: AssertionError
_____________________ TestMetricsAPI.test_metrics_endpoint _____________________

self = <test_iteration_22.TestMetricsAPI object at 0xfd9f68147d50>

    def test_metrics_endpoint(self):
        """Verify metrics API returns data"""
        response = requests.get(f"{BASE_URL}/api/metrics")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:90: AssertionError
______________ TestCategoriesAndRegions.test_categories_endpoint _______________

self = <test_iteration_22.TestCategoriesAndRegions object at 0xfd9f68147590>

    def test_categories_endpoint(self):
        """Verify categories API"""
        response = requests.get(f"{BASE_URL}/api/categories")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:105: AssertionError
________________ TestCategoriesAndRegions.test_regions_endpoint ________________

self = <test_iteration_22.TestCategoriesAndRegions object at 0xfd9f68147110>

    def test_regions_endpoint(self):
        """Verify regions API"""
        response = requests.get(f"{BASE_URL}/api/regions")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:114: AssertionError
_________________ TestBreakingNews.test_breaking_news_endpoint _________________

self = <test_iteration_22.TestBreakingNews object at 0xfd9f68124e10>

    def test_breaking_news_endpoint(self):
        """Verify breaking news API"""
        response = requests.get(f"{BASE_URL}/api/news/breaking")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:127: AssertionError
______________________ TestVoicesAPI.test_voices_endpoint ______________________

self = <test_iteration_22.TestVoicesAPI object at 0xfd9f68125510>

    def test_voices_endpoint(self):
        """Verify voices API returns profiles"""
        response = requests.get(f"{BASE_URL}/api/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_22.py:139: AssertionError
_________________ TestFactCheckAPI.test_factcheck_by_story_id __________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_iteration_22.TestFactCheckAPI object at 0xfd9f68126010>

    def test_factcheck_by_story_id(self):
        """Test fact-check lookup by story ID"""
        # First get a news item
        response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_iteration_22.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
_______________ TestNewsImageUrl.test_news_endpoint_returns_data _______________

self = <test_iteration_23.TestNewsImageUrl object at 0xfd9f68124450>

    def test_news_endpoint_returns_data(self):
        """Test /api/news endpoint returns a list of news items"""
>       response = requests.get(f"{BASE_URL}/api/news", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news': No scheme supplied. Perhaps you meant https:///api/news?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestNewsImageUrl.test_news_items_have_image_url_field _____________

self = <test_iteration_23.TestNewsImageUrl object at 0xfd9f68146a90>

    def test_news_items_have_image_url_field(self):
        """Test that news items contain image_url field in response"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=20", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=20'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=20': No scheme supplied. Perhaps you meant https:///api/news?limit=20?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestNewsImageUrl.test_news_item_structure ___________________

self = <test_iteration_23.TestNewsImageUrl object at 0xfd9f68144550>

    def test_news_item_structure(self):
        """Test that news items have correct structure with all expected fields"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestHealthAndMetrics.test_health_endpoint ___________________

self = <test_iteration_23.TestHealthAndMetrics object at 0xfd9f681255d0>

    def test_health_endpoint(self):
        """Test health endpoint returns online status"""
>       response = requests.get(f"{BASE_URL}/api/health", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestHealthAndMetrics.test_metrics_endpoint __________________

self = <test_iteration_23.TestHealthAndMetrics object at 0xfd9f68124f90>

    def test_metrics_endpoint(self):
        """Test metrics endpoint returns platform metrics"""
>       response = requests.get(f"{BASE_URL}/api/metrics", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestRSSFeeds.test_news_from_vanguard_source __________________

self = <test_iteration_23.TestRSSFeeds object at 0xfd9f683d82d0>

    def test_news_from_vanguard_source(self):
        """Check if any news items are from Vanguard Nigeria (known to have images)"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=30", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=30'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=30': No scheme supplied. Perhaps you meant https:///api/news?limit=30?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestCategories.test_categories_endpoint ____________________

self = <test_iteration_23.TestCategories object at 0xfd9f681ab490>

    def test_categories_endpoint(self):
        """Test categories endpoint"""
>       response = requests.get(f"{BASE_URL}/api/categories", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/categories', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/categories': No scheme supplied. Perhaps you meant https:///api/categories?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________________ TestCategories.test_regions_endpoint _____________________

self = <test_iteration_23.TestCategories object at 0xfd9f681a9ed0>

    def test_regions_endpoint(self):
        """Test regions endpoint"""
>       response = requests.get(f"{BASE_URL}/api/regions", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/regions', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/regions': No scheme supplied. Perhaps you meant https:///api/regions?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestVoicesAndTrending.test_voices_endpoint __________________

self = <test_iteration_23.TestVoicesAndTrending object at 0xfd9f681aae50>

    def test_voices_endpoint(self):
        """Test voices endpoint"""
>       response = requests.get(f"{BASE_URL}/api/voices", timeout=10)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestVoicesAndTrending.test_trending_endpoint _________________

self = <test_iteration_23.TestVoicesAndTrending object at 0xfd9f681ab510>

    def test_trending_endpoint(self):
        """Test trending endpoint"""
>       response = requests.get(f"{BASE_URL}/api/trending", timeout=15)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_23.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/trending', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/trending': No scheme supplied. Perhaps you meant https:///api/trending?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestHealthAndBasics.test_health_endpoint ___________________

self = <test_iteration_24.TestHealthAndBasics object at 0xfd9f67ffea10>

    def test_health_endpoint(self):
        """Test API health check"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:18: AssertionError
________________ TestDiscoverPodcasts.test_get_podcasts_latest _________________

self = <test_iteration_24.TestDiscoverPodcasts object at 0xfd9f67ffee90>

    def test_get_podcasts_latest(self):
        """Test fetching podcasts sorted by latest"""
        response = requests.get(f"{BASE_URL}/api/podcasts?sort=latest&limit=8")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:31: AssertionError
________________ TestDiscoverPodcasts.test_get_podcasts_popular ________________

self = <test_iteration_24.TestDiscoverPodcasts object at 0xfd9f67fff910>

    def test_get_podcasts_popular(self):
        """Test fetching podcasts sorted by popular"""
        response = requests.get(f"{BASE_URL}/api/podcasts?sort=popular&limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:49: AssertionError
___________ TestDiscoverPodcasts.test_podcasts_have_required_fields ____________

self = <test_iteration_24.TestDiscoverPodcasts object at 0xfd9f67fff710>

    def test_podcasts_have_required_fields(self):
        """Verify all podcasts have required fields"""
        response = requests.get(f"{BASE_URL}/api/podcasts?limit=10")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:57: AssertionError
________________ TestDiscoverTrending.test_get_trending_topics _________________

self = <test_iteration_24.TestDiscoverTrending object at 0xfd9f6821a550>

    def test_get_trending_topics(self):
        """Test fetching trending topics"""
        response = requests.get(f"{BASE_URL}/api/discover/trending")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:74: AssertionError
__________________ TestRadioStations.test_get_radio_countries __________________

self = <test_iteration_24.TestRadioStations object at 0xfd9f6821acd0>

    def test_get_radio_countries(self):
        """Test fetching radio countries list"""
        response = requests.get(f"{BASE_URL}/api/radio/countries")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:93: AssertionError
_____________ TestRadioStations.test_get_radio_stations_by_country _____________

self = <test_iteration_24.TestRadioStations object at 0xfd9f68263c10>

    def test_get_radio_stations_by_country(self):
        """Test fetching radio stations for Nigeria"""
        response = requests.get(f"{BASE_URL}/api/radio/stations?country=NG&limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:111: AssertionError
________________ TestOfflineArticles.test_save_offline_article _________________

self = <test_iteration_24.TestOfflineArticles object at 0xfd9f68263810>

    def test_save_offline_article(self):
        """Test saving an article for offline"""
        payload = {
            "story_id": "TEST_offline_001",
            "title": "Test Offline Article",
            "summary": "This is a test summary for offline saving",
            "narrative": "This is the full narrative text",
            "source": "Test Source",
            "category": "Tech",
            "image_url": "https://example.com/image.jpg"
        }
        response = requests.post(f"{BASE_URL}/api/offline/save", json=payload)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:151: AssertionError
________________ TestOfflineArticles.test_get_offline_articles _________________

self = <test_iteration_24.TestOfflineArticles object at 0xfd9f68262c10>

    def test_get_offline_articles(self):
        """Test retrieving saved offline articles"""
        # First save an article
        payload = {
            "story_id": "TEST_offline_002",
            "title": "Test Article for Retrieval",
            "summary": "Summary text",
            "narrative": "Narrative text",
            "source": "Test Source",
            "category": "Politics"
        }
        requests.post(f"{BASE_URL}/api/offline/save", json=payload)
    
        # Then retrieve
        response = requests.get(f"{BASE_URL}/api/offline/articles")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:171: AssertionError
_______________ TestOfflineArticles.test_delete_offline_article ________________

self = <test_iteration_24.TestOfflineArticles object at 0xfd9f68261410>

    def test_delete_offline_article(self):
        """Test deleting an offline article"""
        # First save
        payload = {
            "story_id": "TEST_offline_001",
            "title": "Article to Delete",
            "summary": "Will be deleted",
            "source": "Test",
            "category": "General"
        }
        requests.post(f"{BASE_URL}/api/offline/save", json=payload)
    
        # Then delete
        response = requests.delete(f"{BASE_URL}/api/offline/articles/TEST_offline_001")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:196: AssertionError
__________________ TestOfflineArticles.test_get_offline_stats __________________

self = <test_iteration_24.TestOfflineArticles object at 0xfd9f68260fd0>

    def test_get_offline_stats(self):
        """Test getting offline storage statistics"""
        response = requests.get(f"{BASE_URL}/api/offline/stats")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:209: AssertionError
_______________________ TestNewsEndpoints.test_get_news ________________________

self = <test_iteration_24.TestNewsEndpoints object at 0xfd9f68260f90>

    def test_get_news(self):
        """Test fetching news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_24.py:221: AssertionError
_______________ TestHealthAndBasicEndpoints.test_health_endpoint _______________

self = <test_iteration_25.TestHealthAndBasicEndpoints object at 0xfd9f6800cc10>

    def test_health_endpoint(self):
        """Test /api/health returns online status"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:18: AssertionError
___________________ TestModularRoutes.test_podcasts_endpoint ___________________

self = <test_iteration_25.TestModularRoutes object at 0xfd9f6800d410>

    def test_podcasts_endpoint(self):
        """Test /api/podcasts returns podcast episodes"""
        response = requests.get(f"{BASE_URL}/api/podcasts")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:32: AssertionError
______________ TestModularRoutes.test_discover_trending_endpoint _______________

self = <test_iteration_25.TestModularRoutes object at 0xfd9f6800ee10>

    def test_discover_trending_endpoint(self):
        """Test /api/discover/trending returns trending topics"""
        response = requests.get(f"{BASE_URL}/api/discover/trending")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:48: AssertionError
_______________ TestModularRoutes.test_radio_countries_endpoint ________________

self = <test_iteration_25.TestModularRoutes object at 0xfd9f6800d710>

    def test_radio_countries_endpoint(self):
        """Test /api/radio/countries returns African countries"""
        response = requests.get(f"{BASE_URL}/api/radio/countries")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:62: AssertionError
________________ TestModularRoutes.test_offline_stats_endpoint _________________

self = <test_iteration_25.TestModularRoutes object at 0xfd9f6800de50>

    def test_offline_stats_endpoint(self):
        """Test /api/offline/stats returns storage statistics"""
        response = requests.get(f"{BASE_URL}/api/offline/stats")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:75: AssertionError
________________ TestModularRoutes.test_admin_metrics_endpoint _________________

self = <test_iteration_25.TestModularRoutes object at 0xfd9f6800e410>

    def test_admin_metrics_endpoint(self):
        """Test /api/admin/metrics returns system metrics"""
        response = requests.get(f"{BASE_URL}/api/admin/metrics")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:84: AssertionError
____________________ TestModularRoutes.test_voices_endpoint ____________________

self = <test_iteration_25.TestModularRoutes object at 0xfd9f6800e9d0>

    def test_voices_endpoint(self):
        """Test /api/voices returns available TTS voices"""
        response = requests.get(f"{BASE_URL}/api/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:95: AssertionError
___________________ TestOfflineAPI.test_save_article_offline ___________________

self = <test_iteration_25.TestOfflineAPI object at 0xfd9f6800f6d0>

    def test_save_article_offline(self):
        """Test POST /api/offline/save saves an article"""
        article_data = {
            "story_id": "test_article_iter25",
            "title": "Test Article for Iteration 25",
            "summary": "This is a test article summary",
            "narrative": "This is the narrative content",
            "source": "Test Source",
            "category": "Technology",
            "image_url": None
        }
        response = requests.post(
            f"{BASE_URL}/api/offline/save",
            json=article_data
        )
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:126: AssertionError
___________________ TestOfflineAPI.test_get_offline_articles ___________________

self = <test_iteration_25.TestOfflineAPI object at 0xfd9f6800ff10>

    def test_get_offline_articles(self):
        """Test GET /api/offline/articles returns saved articles"""
        response = requests.get(f"{BASE_URL}/api/offline/articles")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:135: AssertionError
__________________ TestOfflineAPI.test_delete_offline_article __________________

self = <test_iteration_25.TestOfflineAPI object at 0xfd9f680244d0>

    def test_delete_offline_article(self):
        """Test DELETE /api/offline/articles/{story_id} removes article"""
        response = requests.delete(f"{BASE_URL}/api/offline/articles/test_article_iter25")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:146: AssertionError
__________________ TestOfflineAPI.test_verify_article_deleted __________________

self = <test_iteration_25.TestOfflineAPI object at 0xfd9f68024910>

    def test_verify_article_deleted(self):
        """Verify the article was actually deleted"""
        response = requests.get(f"{BASE_URL}/api/offline/articles")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:154: AssertionError
________________________ TestNewsAPI.test_news_endpoint ________________________

self = <test_iteration_25.TestNewsAPI object at 0xfd9f68025110>

    def test_news_endpoint(self):
        """Test /api/news returns news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=10")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:167: AssertionError
___________________ TestNewsAPI.test_breaking_news_endpoint ____________________

self = <test_iteration_25.TestNewsAPI object at 0xfd9f68025750>

    def test_breaking_news_endpoint(self):
        """Test /api/news/breaking returns breaking news"""
        response = requests.get(f"{BASE_URL}/api/news/breaking")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:182: AssertionError
______________________ TestAdminRoutes.test_admin_alerts _______________________

self = <test_iteration_25.TestAdminRoutes object at 0xfd9f68026150>

    def test_admin_alerts(self):
        """Test /api/admin/alerts returns system alerts"""
        response = requests.get(f"{BASE_URL}/api/admin/alerts")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:194: AssertionError
______________________ TestAdminRoutes.test_admin_streams ______________________

self = <test_iteration_25.TestAdminRoutes object at 0xfd9f68026990>

    def test_admin_streams(self):
        """Test /api/admin/streams returns stream status"""
        response = requests.get(f"{BASE_URL}/api/admin/streams")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:207: AssertionError
______________________ TestAdminRoutes.test_admin_voices _______________________

self = <test_iteration_25.TestAdminRoutes object at 0xfd9f6800e290>

    def test_admin_voices(self):
        """Test /api/admin/voices returns voice metrics"""
        response = requests.get(f"{BASE_URL}/api/admin/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_iteration_25.py:220: AssertionError
__ TestAggregatorStatusCaching.test_aggregators_status_has_cache_ttl_seconds ___

self = <test_iteration_34.TestAggregatorStatusCaching object at 0xfd9f68084c90>
client = <httpx.Client object at 0xfd9f67bec5d0>

    def test_aggregators_status_has_cache_ttl_seconds(self, client):
        """GET /api/aggregators/status should include cache_ttl_seconds field"""
        r = client.get("/api/aggregators/status")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:31: AssertionError
__ TestAggregatorStatusCaching.test_aggregators_status_has_cache_stale_field ___

self = <test_iteration_34.TestAggregatorStatusCaching object at 0xfd9f68084f10>
client = <httpx.Client object at 0xfd9f68260d10>

    def test_aggregators_status_has_cache_stale_field(self, client):
        """GET /api/aggregators/status should include cache_stale boolean field"""
        r = client.get("/api/aggregators/status")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:42: AssertionError
_____ TestAggregatorStatusCaching.test_aggregators_status_has_last_fetched _____

self = <test_iteration_34.TestAggregatorStatusCaching object at 0xfd9f68086050>
client = <httpx.Client object at 0xfd9f67db3790>

    def test_aggregators_status_has_last_fetched(self, client):
        """GET /api/aggregators/status should include last_fetched timestamp"""
        r = client.get("/api/aggregators/status")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:52: AssertionError
_ TestNewsWithAggregatorSourceFilter.test_news_include_aggregators_returns_mixed_content _

self = <test_iteration_34.TestNewsWithAggregatorSourceFilter object at 0xfd9f68085d50>
client = <httpx.Client object at 0xfd9f67c2b510>

    def test_news_include_aggregators_returns_mixed_content(self, client):
        """GET /api/news?include_aggregators=true returns mix of RSS and aggregator articles"""
        r = client.get("/api/news?limit=50&include_aggregators=true")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:68: AssertionError
_ TestNewsWithAggregatorSourceFilter.test_news_aggregator_sources_mediastack_only _

self = <test_iteration_34.TestNewsWithAggregatorSourceFilter object at 0xfd9f68085f50>
client = <httpx.Client object at 0xfd9f67cd38d0>

    def test_news_aggregator_sources_mediastack_only(self, client):
        """GET /api/news?include_aggregators=true&aggregator_sources=mediastack returns only mediastack aggregator articles plus RSS"""
        r = client.get("/api/news?limit=50&include_aggregators=true&aggregator_sources=mediastack")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:86: AssertionError
_ TestNewsWithAggregatorSourceFilter.test_news_aggregator_sources_newsdata_only _

self = <test_iteration_34.TestNewsWithAggregatorSourceFilter object at 0xfd9f68085890>
client = <httpx.Client object at 0xfd9f679ee5d0>

    def test_news_aggregator_sources_newsdata_only(self, client):
        """GET /api/news?include_aggregators=true&aggregator_sources=newsdata returns only newsdata aggregator articles plus RSS"""
        r = client.get("/api/news?limit=50&include_aggregators=true&aggregator_sources=newsdata")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:104: AssertionError
_____ TestNewsWithAggregatorSourceFilter.test_news_aggregator_sources_both _____

self = <test_iteration_34.TestNewsWithAggregatorSourceFilter object at 0xfd9f680876d0>
client = <httpx.Client object at 0xfd9f67db3f90>

    def test_news_aggregator_sources_both(self, client):
        """GET /api/news?include_aggregators=true&aggregator_sources=mediastack,newsdata returns both sources"""
        r = client.get("/api/news?limit=50&include_aggregators=true&aggregator_sources=mediastack,newsdata")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:122: AssertionError
____ TestSearchWithAggregators.test_search_include_aggregators_default_true ____

self = <test_iteration_34.TestSearchWithAggregators object at 0xfd9f68087dd0>
client = <httpx.Client object at 0xfd9f68086950>

    def test_search_include_aggregators_default_true(self, client):
        """GET /api/search?q=Nigeria should include aggregator articles by default"""
        r = client.get("/api/search?q=Nigeria")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:138: AssertionError
___ TestSearchWithAggregators.test_search_include_aggregators_true_explicit ____

self = <test_iteration_34.TestSearchWithAggregators object at 0xfd9f68085310>
client = <httpx.Client object at 0xfd9f67e44c90>

    def test_search_include_aggregators_true_explicit(self, client):
        """GET /api/search?q=Nigeria&include_aggregators=true returns aggregator articles in results"""
        r = client.get("/api/search?q=Nigeria&include_aggregators=true")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:154: AssertionError
_______ TestSearchWithAggregators.test_search_include_aggregators_false ________

self = <test_iteration_34.TestSearchWithAggregators object at 0xfd9f68073f90>
client = <httpx.Client object at 0xfd9f67a2b710>

    def test_search_include_aggregators_false(self, client):
        """GET /api/search?q=Nigeria&include_aggregators=false returns only RSS results"""
        r = client.get("/api/search?q=Nigeria&include_aggregators=false")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:173: AssertionError
_______ TestSearchWithAggregators.test_search_returns_correct_structure ________

self = <test_iteration_34.TestSearchWithAggregators object at 0xfd9f68071550>
client = <httpx.Client object at 0xfd9f683d9890>

    def test_search_returns_correct_structure(self, client):
        """Search results should have correct structure"""
        r = client.get("/api/search?q=Africa&limit=5")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:185: AssertionError
_ TestUserSettingsAggregatorPreferences.test_get_settings_has_aggregator_fields _

self = <test_iteration_34.TestUserSettingsAggregatorPreferences object at 0xfd9f68071390>
client = <httpx.Client object at 0xfd9f67a670d0>

    def test_get_settings_has_aggregator_fields(self, client):
        """GET /api/settings/guest should return aggregator_mediastack and aggregator_newsdata fields"""
        r = client.get("/api/settings/guest")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:204: AssertionError
____ TestUserSettingsAggregatorPreferences.test_save_aggregator_preferences ____

self = <test_iteration_34.TestUserSettingsAggregatorPreferences object at 0xfd9f68071710>
client = <httpx.Client object at 0xfd9f67d122d0>

    def test_save_aggregator_preferences(self, client):
        """POST /api/settings/guest should save aggregator preferences"""
        # Save with specific values
        save_data = {
            "aggregator_mediastack": True,
            "aggregator_newsdata": False,
        }
    
        r = client.post("/api/settings/guest", json=save_data)
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:226: AssertionError
___ TestUserSettingsAggregatorPreferences.test_toggle_aggregator_preferences ___

self = <test_iteration_34.TestUserSettingsAggregatorPreferences object at 0xfd9f68071c50>
client = <httpx.Client object at 0xfd9f67bebdd0>

    def test_toggle_aggregator_preferences(self, client):
        """Toggling aggregator preferences should persist"""
        # First set both to True
        client.post("/api/settings/guest", json={
            "aggregator_mediastack": True,
            "aggregator_newsdata": True,
        })
    
        # Verify
        r = client.get("/api/settings/guest")
>       data = r.json()
               ^^^^^^^^

backend/tests/test_iteration_34.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_models.py:832: in json
    return jsonlib.loads(self.content, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError
_______ TestSettingsPersistence.test_settings_include_broadcast_language _______

self = <test_iteration_34.TestSettingsPersistence object at 0xfd9f68086390>
client = <httpx.Client object at 0xfd9f67d56690>

    def test_settings_include_broadcast_language(self, client):
        """Settings should include broadcast_language field"""
        r = client.get("/api/settings/guest")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:272: AssertionError
__________ TestSettingsPersistence.test_settings_include_voice_model ___________

self = <test_iteration_34.TestSettingsPersistence object at 0xfd9f68070bd0>
client = <httpx.Client object at 0xfd9f67bc28d0>

    def test_settings_include_voice_model(self, client):
        """Settings should include voice_model field"""
        r = client.get("/api/settings/guest")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:281: AssertionError
_________________ TestRegressionFeatures.test_health_endpoint __________________

self = <test_iteration_34.TestRegressionFeatures object at 0xfd9f68070890>
client = <httpx.Client object at 0xfd9f67a7cc90>

    def test_health_endpoint(self, client):
        """Health endpoint should return online status"""
        r = client.get("/api/health")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:293: AssertionError
_____________ TestRegressionFeatures.test_sources_health_39_feeds ______________

self = <test_iteration_34.TestRegressionFeatures object at 0xfd9f68071f10>
client = <httpx.Client object at 0xfd9f67abbd50>

    def test_sources_health_39_feeds(self, client):
        """Sources health should report 39 feeds"""
        r = client.get("/api/sources/health")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:300: AssertionError
_________________ TestRegressionFeatures.test_sources_count_39 _________________

self = <test_iteration_34.TestRegressionFeatures object at 0xfd9f68072690>
client = <httpx.Client object at 0xfd9f67b5f950>

    def test_sources_count_39(self, client):
        """Sources endpoint should report 39 total sources"""
        r = client.get("/api/sources")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:307: AssertionError
_________________ TestRegressionFeatures.test_voices_endpoint __________________

self = <test_iteration_34.TestRegressionFeatures object at 0xfd9f68072890>
client = <httpx.Client object at 0xfd9f67b5f290>

    def test_voices_endpoint(self, client):
        """Voices endpoint should return 5 voices with gender"""
        r = client.get("/api/voices")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:314: AssertionError
_______________ TestRegressionFeatures.test_news_basic_endpoint ________________

self = <test_iteration_34.TestRegressionFeatures object at 0xfd9f68073210>
client = <httpx.Client object at 0xfd9f67ab9690>

    def test_news_basic_endpoint(self, client):
        """News endpoint should return articles from RSS feeds"""
        r = client.get("/api/news?limit=10")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:323: AssertionError
_____________ TestRegressionFeatures.test_metrics_has_aggregators ______________

self = <test_iteration_34.TestRegressionFeatures object at 0xfd9f68073750>
client = <httpx.Client object at 0xfd9f681a9a50>

    def test_metrics_has_aggregators(self, client):
        """Metrics should include aggregators object"""
        r = client.get("/api/metrics")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502 Bad Gateway]>.status_code

backend/tests/test_iteration_34.py:331: AssertionError
____________ TestNewsDataBugFix.test_newsdata_endpoint_returns_200 _____________

self = <test_iteration_35.TestNewsDataBugFix object at 0xfd9f68060c10>

    def test_newsdata_endpoint_returns_200(self):
        """GET /api/aggregators/newsdata should return 200 (not 422)"""
>       response = requests.get(f"{BASE_URL}/api/aggregators/newsdata", params={"query": "Nigeria", "limit": 10})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/aggregators/newsdata'
params = OrderedDict([('query', 'Nigeria'), ('limit', 10)])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/aggregators/newsdata': No scheme supplied. Perhaps you meant https:///api/aggregators/newsdata?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestNewsDataBugFix.test_newsdata_returns_articles _______________

self = <test_iteration_35.TestNewsDataBugFix object at 0xfd9f68061850>

    def test_newsdata_returns_articles(self):
        """Verify NewsData.io actually fetches articles"""
>       response = requests.get(f"{BASE_URL}/api/aggregators/newsdata", params={"query": "Nigeria", "limit": 10})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/aggregators/newsdata'
params = OrderedDict([('query', 'Nigeria'), ('limit', 10)])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/aggregators/newsdata': No scheme supplied. Perhaps you meant https:///api/aggregators/newsdata?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestNewsDataBugFix.test_aggregator_status_shows_newsdata ___________

self = <test_iteration_35.TestNewsDataBugFix object at 0xfd9f68061a90>

    def test_aggregator_status_shows_newsdata(self):
        """GET /api/aggregators/status should show newsdata cache info"""
>       response = requests.get(f"{BASE_URL}/api/aggregators/status")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/aggregators/status'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/aggregators/status': No scheme supplied. Perhaps you meant https:///api/aggregators/status?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestSearchBugFix.test_search_endpoint_returns_200 _______________

self = <test_iteration_35.TestSearchBugFix object at 0xfd9f68062410>

    def test_search_endpoint_returns_200(self):
        """GET /api/search?q=Nigeria should return 200"""
>       response = requests.get(f"{BASE_URL}/api/search", params={"q": "Nigeria"})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search'
params = OrderedDict([('q', 'Nigeria')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search': No scheme supplied. Perhaps you meant https:///api/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestSearchBugFix.test_search_includes_aggregator_articles ___________

self = <test_iteration_35.TestSearchBugFix object at 0xfd9f680438d0>

    def test_search_includes_aggregator_articles(self):
        """Search results should include items with aggregator field"""
>       response = requests.get(f"{BASE_URL}/api/search", params={"q": "Nigeria", "include_aggregators": "true"})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search'
params = OrderedDict([('q', 'Nigeria'), ('include_aggregators', 'true')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search': No scheme supplied. Perhaps you meant https:///api/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestSearchBugFix.test_search_with_different_query _______________

self = <test_iteration_35.TestSearchBugFix object at 0xfd9f68041050>

    def test_search_with_different_query(self):
        """Test search with broader query"""
>       response = requests.get(f"{BASE_URL}/api/search", params={"q": "Africa"})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search'
params = OrderedDict([('q', 'Africa')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search': No scheme supplied. Perhaps you meant https:///api/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____ TestUserPrefsIntegration.test_guest_settings_returns_aggregator_prefs _____

self = <test_iteration_35.TestUserPrefsIntegration object at 0xfd9f68041310>

    def test_guest_settings_returns_aggregator_prefs(self):
        """GET /api/settings/guest should return aggregator_mediastack and aggregator_newsdata"""
>       response = requests.get(f"{BASE_URL}/api/settings/guest")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/settings/guest'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/settings/guest': No scheme supplied. Perhaps you meant https:///api/settings/guest?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____ TestUserPrefsIntegration.test_news_endpoint_accepts_aggregator_sources ____

self = <test_iteration_35.TestUserPrefsIntegration object at 0xfd9f68060ad0>

    def test_news_endpoint_accepts_aggregator_sources(self):
        """GET /api/news with aggregator_sources param"""
        # Test with both sources
>       response = requests.get(f"{BASE_URL}/api/news", params={
            "limit": 30,
            "include_aggregators": "true",
            "aggregator_sources": "mediastack,newsdata"
        })

backend/tests/test_iteration_35.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news'
params = OrderedDict([('limit', 30), ('include_aggregators', 'true'), ('aggregator_sources', 'mediastack,newsdata')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news': No scheme supplied. Perhaps you meant https:///api/news?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____ TestUserPrefsIntegration.test_news_endpoint_filters_by_single_source _____

self = <test_iteration_35.TestUserPrefsIntegration object at 0xfd9f68084d10>

    def test_news_endpoint_filters_by_single_source(self):
        """GET /api/news with single aggregator source"""
>       response = requests.get(f"{BASE_URL}/api/news", params={
            "limit": 20,
            "include_aggregators": "true",
            "aggregator_sources": "mediastack"
        })

backend/tests/test_iteration_35.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news'
params = OrderedDict([('limit', 20), ('include_aggregators', 'true'), ('aggregator_sources', 'mediastack')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news': No scheme supplied. Perhaps you meant https:///api/news?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestDeduplication.test_news_returns_unique_items _______________

self = <test_iteration_35.TestDeduplication object at 0xfd9f68043790>

    def test_news_returns_unique_items(self):
        """GET /api/news should not have items with duplicate IDs"""
>       response = requests.get(f"{BASE_URL}/api/news", params={
            "limit": 50,
            "include_aggregators": "true"
        })

backend/tests/test_iteration_35.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news'
params = OrderedDict([('limit', 50), ('include_aggregators', 'true')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news': No scheme supplied. Perhaps you meant https:///api/news?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestAggregatorCacheRefresh.test_aggregator_status_cache_info _________

self = <test_iteration_35.TestAggregatorCacheRefresh object at 0xfd9f68041390>

    def test_aggregator_status_cache_info(self):
        """Verify cache TTL and stale status in aggregator status"""
>       response = requests.get(f"{BASE_URL}/api/aggregators/status")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/aggregators/status'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/aggregators/status': No scheme supplied. Perhaps you meant https:///api/aggregators/status?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestAggregatorCacheRefresh.test_mediastack_endpoint ______________

self = <test_iteration_35.TestAggregatorCacheRefresh object at 0xfd9f680419d0>

    def test_mediastack_endpoint(self):
        """Verify Mediastack endpoint works"""
>       response = requests.get(f"{BASE_URL}/api/aggregators/mediastack", params={
            "keywords": "Nigeria Africa",
            "limit": 10
        })

backend/tests/test_iteration_35.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/aggregators/mediastack'
params = OrderedDict([('keywords', 'Nigeria Africa'), ('limit', 10)])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/aggregators/mediastack': No scheme supplied. Perhaps you meant https:///api/aggregators/mediastack?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestSearchFilters.test_search_with_category_filter ______________

self = <test_iteration_35.TestSearchFilters object at 0xfd9f68041b50>

    def test_search_with_category_filter(self):
        """Search with category filter"""
>       response = requests.get(f"{BASE_URL}/api/search", params={
            "q": "news",
            "category": "politics"
        })

backend/tests/test_iteration_35.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search'
params = OrderedDict([('q', 'news'), ('category', 'politics')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search': No scheme supplied. Perhaps you meant https:///api/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestSearchFilters.test_search_pagination ___________________

self = <test_iteration_35.TestSearchFilters object at 0xfd9f68042390>

    def test_search_pagination(self):
        """Test search pagination"""
>       response = requests.get(f"{BASE_URL}/api/search", params={
            "q": "Nigeria",
            "limit": 5,
            "skip": 0
        })

backend/tests/test_iteration_35.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search'
params = OrderedDict([('q', 'Nigeria'), ('limit', 5), ('skip', 0)])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search': No scheme supplied. Perhaps you meant https:///api/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestHealthAndBasics.test_health_endpoint ___________________

self = <test_iteration_35.TestHealthAndBasics object at 0xfd9f68042d50>

    def test_health_endpoint(self):
        """API health check"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestHealthAndBasics.test_metrics_endpoint ___________________

self = <test_iteration_35.TestHealthAndBasics object at 0xfd9f68043590>

    def test_metrics_endpoint(self):
        """Metrics endpoint"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_35.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestSearchAggregatorIntegration.test_health_check _______________

self = <test_iteration_38.TestSearchAggregatorIntegration object at 0xfd9f6805f9d0>

    def test_health_check(self):
        """Verify API is running"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestSearchAggregatorIntegration.test_search_without_filter __________

self = <test_iteration_38.TestSearchAggregatorIntegration object at 0xfd9f6805fb90>

    def test_search_without_filter(self):
        """Search without source_type should return all sources"""
>       response = requests.get(f"{BASE_URL}/api/search?q=Nigeria")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search?q=Nigeria'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search?q=Nigeria': No scheme supplied. Perhaps you meant https:///api/search?q=Nigeria?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestSearchAggregatorIntegration.test_search_filter_rss_only __________

self = <test_iteration_38.TestSearchAggregatorIntegration object at 0xfd9f6805d150>

    def test_search_filter_rss_only(self):
        """Search with source_type=rss should return only RSS results"""
>       response = requests.get(f"{BASE_URL}/api/search?q=Nigeria&source_type=rss")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search?q=Nigeria&source_type=rss'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search?q=Nigeria&source_type=rss': No scheme supplied. Perhaps you meant https:///api/search?q=Nigeria&source_type=rss?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______ TestSearchAggregatorIntegration.test_search_filter_aggregator_only ______

self = <test_iteration_38.TestSearchAggregatorIntegration object at 0xfd9f6805d690>

    def test_search_filter_aggregator_only(self):
        """Search with source_type=aggregator should return only aggregator results"""
>       response = requests.get(f"{BASE_URL}/api/search?q=Nigeria&source_type=aggregator")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>
url = '/api/search?q=Nigeria&source_type=aggregator', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search?q=Nigeria&source_type=aggregator': No scheme supplied. Perhaps you meant https:///api/search?q=Nigeria&source_type=aggregator?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestSearchAggregatorIntegration.test_search_filter_podcast_only ________

self = <test_iteration_38.TestSearchAggregatorIntegration object at 0xfd9f6801ae10>

    def test_search_filter_podcast_only(self):
        """Search with source_type=podcast should return only podcast results"""
>       response = requests.get(f"{BASE_URL}/api/search?q=Africa&source_type=podcast")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search?q=Africa&source_type=podcast'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search?q=Africa&source_type=podcast': No scheme supplied. Perhaps you meant https:///api/search?q=Africa&source_type=podcast?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___ TestSearchAggregatorIntegration.test_search_results_have_required_fields ___

self = <test_iteration_38.TestSearchAggregatorIntegration object at 0xfd9f68018e10>

    def test_search_results_have_required_fields(self):
        """Verify search results contain necessary fields"""
>       response = requests.get(f"{BASE_URL}/api/search?q=Nigeria&limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/search?q=Nigeria&limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/search?q=Nigeria&limit=5': No scheme supplied. Perhaps you meant https:///api/search?q=Nigeria&limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________ TestNewsEndpointWithAggregators.test_news_includes_aggregators ________

self = <test_iteration_38.TestNewsEndpointWithAggregators object at 0xfd9f6805d2d0>

    def test_news_includes_aggregators(self):
        """News endpoint should include aggregator articles when requested"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=50&include_aggregators=true")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>
url = '/api/news?limit=50&include_aggregators=true', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=50&include_aggregators=true': No scheme supplied. Perhaps you meant https:///api/news?limit=50&include_aggregators=true?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestNewsEndpointWithAggregators.test_news_basic_fields ____________

self = <test_iteration_38.TestNewsEndpointWithAggregators object at 0xfd9f680423d0>

    def test_news_basic_fields(self):
        """Verify news items have basic required fields"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestBriefingEndpoint.test_briefing_latest ___________________

self = <test_iteration_38.TestBriefingEndpoint object at 0xfd9f680186d0>

    def test_briefing_latest(self):
        """Get latest briefing"""
>       response = requests.get(f"{BASE_URL}/api/briefing/latest")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/briefing/latest'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/briefing/latest': No scheme supplied. Perhaps you meant https:///api/briefing/latest?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestBriefingEndpoint.test_briefing_history __________________

self = <test_iteration_38.TestBriefingEndpoint object at 0xfd9f68018190>

    def test_briefing_history(self):
        """Get briefing history"""
>       response = requests.get(f"{BASE_URL}/api/briefing/history?limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:136: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/briefing/history?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/briefing/history?limit=5': No scheme supplied. Perhaps you meant https:///api/briefing/history?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________________ TestVoicesEndpoint.test_get_voices ______________________

self = <test_iteration_38.TestVoicesEndpoint object at 0xfd9f68018d50>

    def test_get_voices(self):
        """Get available voices"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestMetricsEndpoint.test_metrics_aggregators _________________

self = <test_iteration_38.TestMetricsEndpoint object at 0xfd9f68019710>

    def test_metrics_aggregators(self):
        """Verify metrics include aggregator info"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________________ TestToolsPageRoute.test_api_health ______________________

self = <test_iteration_38.TestToolsPageRoute object at 0xfd9f6801a550>

    def test_api_health(self):
        """Ensure API doesn't have errors that would affect frontend"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_iteration_38.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestHealthEndpoint.test_health_status _____________________

self = <test_narvo_api.TestHealthEndpoint object at 0xfd9f683e3950>

    def test_health_status(self):
        """Test /api/health returns online status"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:17: AssertionError
_____________________ TestNewsEndpoints.test_get_news_list _____________________

self = <test_narvo_api.TestNewsEndpoints object at 0xfd9f683e2910>

    def test_get_news_list(self):
        """Test /api/news returns news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:33: AssertionError
______________ TestNewsEndpoints.test_get_news_with_region_filter ______________

self = <test_narvo_api.TestNewsEndpoints object at 0xfd9f683d8a90>

    def test_get_news_with_region_filter(self):
        """Test /api/news with region filter"""
        response = requests.get(f"{BASE_URL}/api/news?region=Nigeria&limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:52: AssertionError
____________________ TestNewsEndpoints.test_get_news_detail ____________________

self = <test_narvo_api.TestNewsEndpoints object at 0xfd9f68216850>

    def test_get_news_detail(self):
        """Test /api/news/{id} returns news detail"""
        # First get a news item ID
        list_response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       assert list_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:65: AssertionError
_______________ TestNewsEndpoints.test_get_news_detail_not_found _______________

self = <test_narvo_api.TestNewsEndpoints object at 0xfd9f68216ad0>

    def test_get_news_detail_not_found(self):
        """Test /api/news/{id} returns 404 for invalid ID"""
        response = requests.get(f"{BASE_URL}/api/news/invalid-id-12345")
>       assert response.status_code == 404
E       assert 502 == 404
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:84: AssertionError
______________________ TestVoicesEndpoint.test_get_voices ______________________

self = <test_narvo_api.TestVoicesEndpoint object at 0xfd9f68216b90>

    def test_get_voices(self):
        """Test /api/voices returns voice profiles"""
        response = requests.get(f"{BASE_URL}/api/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:94: AssertionError
_____________________ TestRegionsEndpoint.test_get_regions _____________________

self = <test_narvo_api.TestRegionsEndpoint object at 0xfd9f68217b90>

    def test_get_regions(self):
        """Test /api/regions returns available regions"""
        response = requests.get(f"{BASE_URL}/api/regions")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:114: AssertionError
__________________ TestCategoriesEndpoint.test_get_categories __________________

self = <test_narvo_api.TestCategoriesEndpoint object at 0xfd9f68217bd0>

    def test_get_categories(self):
        """Test /api/categories returns news categories"""
        response = requests.get(f"{BASE_URL}/api/categories")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:132: AssertionError
____________________ TestTrendingEndpoint.test_get_trending ____________________

self = <test_narvo_api.TestTrendingEndpoint object at 0xfd9f68216190>

    def test_get_trending(self):
        """Test /api/trending returns trending data"""
        response = requests.get(f"{BASE_URL}/api/trending")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:150: AssertionError
_____________________ TestMetricsEndpoint.test_get_metrics _____________________

self = <test_narvo_api.TestMetricsEndpoint object at 0xfd9f68215850>

    def test_get_metrics(self):
        """Test /api/metrics returns platform metrics"""
        response = requests.get(f"{BASE_URL}/api/metrics")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:166: AssertionError
_________________ TestBriefingEndpoints.test_generate_briefing _________________

self = <test_narvo_api.TestBriefingEndpoints object at 0xfd9f6821bb10>

    def test_generate_briefing(self):
        """Test /api/briefing/generate returns briefing (may be slow)"""
        response = requests.get(f"{BASE_URL}/api/briefing/generate?voice_id=nova", timeout=120)
        # Allow 200 or 500 (TTS might fail but structure should be valid)
>       assert response.status_code in [200, 500]
E       assert 502 in [200, 500]
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:182: AssertionError
_________________ TestParaphraseEndpoint.test_paraphrase_text __________________

self = <test_narvo_api.TestParaphraseEndpoint object at 0xfd9f680e3010>

    def test_paraphrase_text(self):
        """Test /api/paraphrase generates narrative"""
        response = requests.post(
            f"{BASE_URL}/api/paraphrase",
            json={
                "text": "Nigeria's economy shows signs of recovery with inflation dropping to 12%.",
                "style": "broadcast"
            },
            timeout=60
        )
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api.py:208: AssertionError
____________________ TestHealthEndpoint.test_health_status _____________________

self = <test_narvo_api_v2.TestHealthEndpoint object at 0xfd9f681051d0>

    def test_health_status(self):
        """Test /api/health returns online status"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:19: AssertionError
_____________________ TestNewsEndpoints.test_get_news_list _____________________

self = <test_narvo_api_v2.TestNewsEndpoints object at 0xfd9f68105510>

    def test_get_news_list(self):
        """Test /api/news returns news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:35: AssertionError
______________ TestNewsEndpoints.test_get_news_with_region_filter ______________

self = <test_narvo_api_v2.TestNewsEndpoints object at 0xfd9f68105a10>

    def test_get_news_with_region_filter(self):
        """Test /api/news with region filter"""
        response = requests.get(f"{BASE_URL}/api/news?region=Nigeria&limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:54: AssertionError
____________________ TestNewsEndpoints.test_get_news_detail ____________________

self = <test_narvo_api_v2.TestNewsEndpoints object at 0xfd9f68106a50>

    def test_get_news_detail(self):
        """Test /api/news/{id} returns news detail"""
        list_response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       assert list_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:65: AssertionError
_______________ TestNewsEndpoints.test_get_news_detail_not_found _______________

self = <test_narvo_api_v2.TestNewsEndpoints object at 0xfd9f68106550>

    def test_get_news_detail_not_found(self):
        """Test /api/news/{id} returns 404 for invalid ID"""
        response = requests.get(f"{BASE_URL}/api/news/invalid-id-12345")
>       assert response.status_code == 404
E       assert 502 == 404
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:82: AssertionError
______________________ TestVoicesEndpoint.test_get_voices ______________________

self = <test_narvo_api_v2.TestVoicesEndpoint object at 0xfd9f68106c50>

    def test_get_voices(self):
        """Test /api/voices returns voice profiles"""
        response = requests.get(f"{BASE_URL}/api/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:92: AssertionError
_____________________ TestRegionsEndpoint.test_get_regions _____________________

self = <test_narvo_api_v2.TestRegionsEndpoint object at 0xfd9f68107890>

    def test_get_regions(self):
        """Test /api/regions returns available regions"""
        response = requests.get(f"{BASE_URL}/api/regions")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:112: AssertionError
__________________ TestCategoriesEndpoint.test_get_categories __________________

self = <test_narvo_api_v2.TestCategoriesEndpoint object at 0xfd9f67fdc910>

    def test_get_categories(self):
        """Test /api/categories returns news categories"""
        response = requests.get(f"{BASE_URL}/api/categories")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:130: AssertionError
____________________ TestTrendingEndpoint.test_get_trending ____________________

self = <test_narvo_api_v2.TestTrendingEndpoint object at 0xfd9f67fdd7d0>

    def test_get_trending(self):
        """Test /api/trending returns trending data"""
        response = requests.get(f"{BASE_URL}/api/trending")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:148: AssertionError
_____________________ TestMetricsEndpoint.test_get_metrics _____________________

self = <test_narvo_api_v2.TestMetricsEndpoint object at 0xfd9f67fdfe50>

    def test_get_metrics(self):
        """Test /api/metrics returns platform metrics"""
        response = requests.get(f"{BASE_URL}/api/metrics")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:164: AssertionError
__________________ TestBookmarkEndpoints.test_create_bookmark __________________

self = <test_narvo_api_v2.TestBookmarkEndpoints object at 0xfd9f6800f990>

    def test_create_bookmark(self):
        """Test POST /api/bookmarks creates a bookmark"""
        payload = {
            "user_id": self.test_user_id,
            "story_id": self.test_story_id,
            "title": "Test Story Title",
            "summary": "Test story summary for bookmark test",
            "source": "Test Source",
            "category": "Tech",
            "source_url": "https://example.com/story",
            "saved_at": "2026-01-24T12:00:00Z"
        }
    
        response = requests.post(f"{BASE_URL}/api/bookmarks", json=payload)
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:201: AssertionError
______________ TestBookmarkEndpoints.test_get_bookmarks_for_user _______________

self = <test_narvo_api_v2.TestBookmarkEndpoints object at 0xfd9f6800e250>

    def test_get_bookmarks_for_user(self):
        """Test GET /api/bookmarks?user_id=X returns user's bookmarks"""
        # First create a bookmark
        payload = {
            "user_id": self.test_user_id,
            "story_id": self.test_story_id,
            "title": "Test Story for GET",
            "summary": "Summary",
            "source": "Source",
            "category": "General",
            "source_url": "",
            "saved_at": ""
        }
        create_response = requests.post(f"{BASE_URL}/api/bookmarks", json=payload)
>       assert create_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:224: AssertionError
_____________ TestBookmarkEndpoints.test_get_bookmarks_empty_user ______________

self = <test_narvo_api_v2.TestBookmarkEndpoints object at 0xfd9f6800ca90>

    def test_get_bookmarks_empty_user(self):
        """Test GET /api/bookmarks for user with no bookmarks returns empty list"""
        random_user_id = f"TEST_nonexistent_{uuid.uuid4().hex[:8]}"
        response = requests.get(f"{BASE_URL}/api/bookmarks?user_id={random_user_id}")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:244: AssertionError
__________________ TestBookmarkEndpoints.test_delete_bookmark __________________

self = <test_narvo_api_v2.TestBookmarkEndpoints object at 0xfd9f6800e5d0>

    def test_delete_bookmark(self):
        """Test DELETE /api/bookmarks/{story_id}?user_id=X removes bookmark"""
        # First create a bookmark
        payload = {
            "user_id": self.test_user_id,
            "story_id": self.test_story_id,
            "title": "Test Story to Delete",
            "summary": "Will be deleted",
            "source": "Source",
            "category": "General",
            "source_url": "",
            "saved_at": ""
        }
        create_response = requests.post(f"{BASE_URL}/api/bookmarks", json=payload)
>       assert create_response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_api_v2.py:265: AssertionError
____________ TestBookmarkEndpoints.test_bookmark_replaces_existing _____________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_narvo_api_v2.TestBookmarkEndpoints object at 0xfd9f67fdc050>

    def test_bookmark_replaces_existing(self):
        """Test POST /api/bookmarks replaces existing bookmark with same story_id"""
        # Create first bookmark
        payload1 = {
            "user_id": self.test_user_id,
            "story_id": self.test_story_id,
            "title": "Original Title",
            "summary": "Original summary",
            "source": "Original",
            "category": "General",
            "source_url": "",
            "saved_at": "2026-01-01T00:00:00Z"
        }
        requests.post(f"{BASE_URL}/api/bookmarks", json=payload1)
    
        # Create another with same story_id but different title
        payload2 = {
            "user_id": self.test_user_id,
            "story_id": self.test_story_id,
            "title": "Updated Title",
            "summary": "Updated summary",
            "source": "Updated",
            "category": "Tech",
            "source_url": "https://new.url",
            "saved_at": "2026-01-02T00:00:00Z"
        }
        requests.post(f"{BASE_URL}/api/bookmarks", json=payload2)
    
        # Get bookmarks and verify only one exists with updated data
        response = requests.get(f"{BASE_URL}/api/bookmarks?user_id={self.test_user_id}")
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_narvo_api_v2.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
____________________ TestHealthAndCore.test_health_endpoint ____________________

self = <test_narvo_v8.TestHealthAndCore object at 0xfd9f6805fe90>

    def test_health_endpoint(self):
        """Test /api/health returns online status"""
        response = requests.get(f"{BASE_URL}/api/health")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:18: AssertionError
___________________ TestHealthAndCore.test_metrics_endpoint ____________________

self = <test_narvo_v8.TestHealthAndCore object at 0xfd9f6805ff10>

    def test_metrics_endpoint(self):
        """Test /api/metrics returns platform metrics"""
        response = requests.get(f"{BASE_URL}/api/metrics")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:29: AssertionError
___________________ TestHealthAndCore.test_regions_endpoint ____________________

self = <test_narvo_v8.TestHealthAndCore object at 0xfd9f68a0ac90>

    def test_regions_endpoint(self):
        """Test /api/regions returns available regions"""
        response = requests.get(f"{BASE_URL}/api/regions")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:40: AssertionError
__________________ TestHealthAndCore.test_categories_endpoint __________________

self = <test_narvo_v8.TestHealthAndCore object at 0xfd9f681eb590>

    def test_categories_endpoint(self):
        """Test /api/categories returns news categories"""
        response = requests.get(f"{BASE_URL}/api/categories")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:49: AssertionError
___________________ TestHealthAndCore.test_trending_endpoint ___________________

self = <test_narvo_v8.TestHealthAndCore object at 0xfd9f681e9250>

    def test_trending_endpoint(self):
        """Test /api/trending returns trending topics"""
        response = requests.get(f"{BASE_URL}/api/trending")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:58: AssertionError
____________________ TestHealthAndCore.test_voices_endpoint ____________________

self = <test_narvo_v8.TestHealthAndCore object at 0xfd9f681ebb50>

    def test_voices_endpoint(self):
        """Test /api/voices returns voice profiles"""
        response = requests.get(f"{BASE_URL}/api/voices")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:67: AssertionError
_______________________ TestNewsEndpoints.test_news_list _______________________

self = <test_narvo_v8.TestNewsEndpoints object at 0xfd9f681eb390>

    def test_news_list(self):
        """Test /api/news returns news items"""
        response = requests.get(f"{BASE_URL}/api/news?limit=5")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:83: AssertionError
_________________ TestNewsEndpoints.test_news_limit_parameter __________________

self = <test_narvo_v8.TestNewsEndpoints object at 0xfd9f681e8a90>

    def test_news_limit_parameter(self):
        """Test /api/news respects limit parameter"""
        response = requests.get(f"{BASE_URL}/api/news?limit=3")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:99: AssertionError
_________________ TestNewsEndpoints.test_news_detail_valid_id __________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_narvo_v8.TestNewsEndpoints object at 0xfd9f681e8510>

    def test_news_detail_valid_id(self):
        """Test /api/news/{id} returns news detail with narrative"""
        # First get a valid news ID
        list_response = requests.get(f"{BASE_URL}/api/news?limit=1")
>       news_items = list_response.json()
                     ^^^^^^^^^^^^^^^^^^^^

backend/tests/test_narvo_v8.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
________________ TestNewsEndpoints.test_news_detail_invalid_id _________________

self = <test_narvo_v8.TestNewsEndpoints object at 0xfd9f681e9fd0>

    def test_news_detail_invalid_id(self):
        """Test /api/news/{id} returns 404 for invalid ID"""
        response = requests.get(f"{BASE_URL}/api/news/invalid_id_12345")
>       assert response.status_code == 404
E       assert 502 == 404
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:125: AssertionError
_______________ TestBookmarksEndpoints.test_get_empty_bookmarks ________________

self = <test_narvo_v8.TestBookmarksEndpoints object at 0xfd9f681ea5d0>

    def test_get_empty_bookmarks(self):
        """Test /api/bookmarks returns empty for new user"""
        user_id = f"new_user_{uuid.uuid4().hex[:8]}"
        response = requests.get(f"{BASE_URL}/api/bookmarks?user_id={user_id}")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:142: AssertionError
___________________ TestBookmarksEndpoints.test_add_bookmark ___________________

self = <test_narvo_v8.TestBookmarksEndpoints object at 0xfd9f681e9610>

    def test_add_bookmark(self):
        """Test POST /api/bookmarks adds bookmark"""
        bookmark_data = {
            "user_id": self.user_id,
            "story_id": f"story_{uuid.uuid4().hex[:8]}",
            "title": "Test Bookmark Story",
            "summary": "Test summary for bookmark",
            "source": "Test Source",
            "category": "Tech",
            "source_url": "https://example.com/story"
        }
        response = requests.post(
            f"{BASE_URL}/api/bookmarks",
            json=bookmark_data
        )
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:163: AssertionError
_____________ TestBookmarksEndpoints.test_get_bookmarks_after_add ______________

self = <test_narvo_v8.TestBookmarksEndpoints object at 0xfd9f680f0d10>

    def test_get_bookmarks_after_add(self):
        """Test GET /api/bookmarks returns added bookmark"""
        story_id = f"story_{uuid.uuid4().hex[:8]}"
        # Add bookmark
        requests.post(
            f"{BASE_URL}/api/bookmarks",
            json={
                "user_id": self.user_id,
                "story_id": story_id,
                "title": "Test Persistence",
                "summary": "Testing persistence",
                "source": "Test",
                "category": "General"
            }
        )
        # Get bookmarks
        response = requests.get(f"{BASE_URL}/api/bookmarks?user_id={self.user_id}")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:186: AssertionError
_________________ TestBookmarksEndpoints.test_delete_bookmark __________________

self = <test_narvo_v8.TestBookmarksEndpoints object at 0xfd9f680f1e10>

    def test_delete_bookmark(self):
        """Test DELETE /api/bookmarks/{story_id} removes bookmark"""
        story_id = f"delete_test_{uuid.uuid4().hex[:8]}"
        # Add bookmark first
        requests.post(
            f"{BASE_URL}/api/bookmarks",
            json={
                "user_id": self.user_id,
                "story_id": story_id,
                "title": "To Delete",
                "source": "Test"
            }
        )
        # Delete it
        response = requests.delete(
            f"{BASE_URL}/api/bookmarks/{story_id}?user_id={self.user_id}"
        )
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:211: AssertionError
____________ TestPreferencesEndpoints.test_get_default_preferences _____________

self = <test_narvo_v8.TestPreferencesEndpoints object at 0xfd9f680f1790>

    def test_get_default_preferences(self):
        """Test /api/preferences returns defaults for unknown user"""
        user_id = f"unknown_{uuid.uuid4().hex[:8]}"
        response = requests.get(f"{BASE_URL}/api/preferences?user_id={user_id}")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:235: AssertionError
________________ TestPreferencesEndpoints.test_save_preferences ________________

self = <test_narvo_v8.TestPreferencesEndpoints object at 0xfd9f681ea3d0>

    def test_save_preferences(self):
        """Test POST /api/preferences saves preferences"""
        prefs_data = {
            "user_id": self.user_id,
            "region": "lagos",
            "voice": "pidgin",
            "interests": ["politics", "tech", "sports"]
        }
        response = requests.post(
            f"{BASE_URL}/api/preferences",
            json=prefs_data
        )
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:255: AssertionError
_____________ TestPreferencesEndpoints.test_get_saved_preferences ______________

self = <test_narvo_v8.TestPreferencesEndpoints object at 0xfd9f68a094d0>

    def test_get_saved_preferences(self):
        """Test /api/preferences returns saved preferences"""
        # Save first
        requests.post(
            f"{BASE_URL}/api/preferences",
            json={
                "user_id": self.user_id,
                "region": "nairobi",
                "voice": "echo",
                "interests": ["economy"]
            }
        )
        # Get preferences
        response = requests.get(f"{BASE_URL}/api/preferences?user_id={self.user_id}")
>       assert response.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_narvo_v8.py:275: AssertionError
_______________ TestPreferencesEndpoints.test_update_preferences _______________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_narvo_v8.TestPreferencesEndpoints object at 0xfd9f680f35d0>

    def test_update_preferences(self):
        """Test updating preferences overwrites old values"""
        # Save initial
        requests.post(
            f"{BASE_URL}/api/preferences",
            json={
                "user_id": self.user_id,
                "region": "lagos",
                "voice": "nova",
                "interests": ["sports"]
            }
        )
        # Update
        requests.post(
            f"{BASE_URL}/api/preferences",
            json={
                "user_id": self.user_id,
                "region": "accra",
                "voice": "onyx",
                "interests": ["tech", "politics"]
            }
        )
        # Verify
        response = requests.get(f"{BASE_URL}/api/preferences?user_id={self.user_id}")
>       data = response.json()
               ^^^^^^^^^^^^^^^

backend/tests/test_narvo_v8.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
___________________ TestHealthEndpoints.test_health_endpoint ___________________

self = <test_persistence_v7.TestHealthEndpoints object at 0xfd9f680f0ad0>

    def test_health_endpoint(self):
        """Test /api/health returns OK"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestHealthEndpoints.test_news_endpoint ____________________

self = <test_persistence_v7.TestHealthEndpoints object at 0xfd9f680f1850>

    def test_news_endpoint(self):
        """Test /api/news returns news data"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=5': No scheme supplied. Perhaps you meant https:///api/news?limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestHealthEndpoints.test_voices_endpoint ___________________

self = <test_persistence_v7.TestHealthEndpoints object at 0xfd9f680f2fd0>

    def test_voices_endpoint(self):
        """Test /api/voices returns voice profiles"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestBookmarksPersistence.test_bookmarks_empty_for_new_user __________

self = <test_persistence_v7.TestBookmarksPersistence object at 0xfd9f681356d0>

    def test_bookmarks_empty_for_new_user(self):
        """Test that new user has empty bookmarks"""
        unique_user = f"empty_user_{uuid.uuid4().hex[:8]}"
>       response = requests.get(f"{BASE_URL}/api/bookmarks", params={"user_id": unique_user})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/bookmarks'
params = OrderedDict([('user_id', 'empty_user_1363ccaa')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestBookmarksPersistence.test_create_bookmark _________________

self = <test_persistence_v7.TestBookmarksPersistence object at 0xfd9f68136e50>

    def test_create_bookmark(self):
        """Test POST /api/bookmarks creates bookmark in MongoDB"""
        bookmark_data = {
            "user_id": TEST_USER_ID,
            "story_id": f"test_story_{uuid.uuid4().hex[:8]}",
            "title": "Test Story Title",
            "summary": "This is a test story summary",
            "source": "Test Source",
            "category": "Politics",
            "source_url": "https://example.com/story",
            "saved_at": datetime.utcnow().isoformat()
        }
>       response = requests.post(f"{BASE_URL}/api/bookmarks", json=bookmark_data)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/bookmarks', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestBookmarksPersistence.test_get_bookmarks_returns_created __________

self = <test_persistence_v7.TestBookmarksPersistence object at 0xfd9f68136190>

    def test_get_bookmarks_returns_created(self):
        """Test GET /api/bookmarks returns previously created bookmark"""
        # First create a bookmark
        story_id = f"persist_test_{uuid.uuid4().hex[:8]}"
        bookmark_data = {
            "user_id": TEST_USER_ID,
            "story_id": story_id,
            "title": "Persistence Test Story",
            "summary": "Testing that bookmarks persist in MongoDB",
            "source": "MongoDB Test",
            "category": "Tech"
        }
>       create_response = requests.post(f"{BASE_URL}/api/bookmarks", json=bookmark_data)
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/bookmarks', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestBookmarksPersistence.test_delete_bookmark _________________

self = <test_persistence_v7.TestBookmarksPersistence object at 0xfd9f68136310>

    def test_delete_bookmark(self):
        """Test DELETE /api/bookmarks removes from MongoDB"""
        # Create a bookmark to delete
        story_id = f"delete_test_{uuid.uuid4().hex[:8]}"
        create_data = {
            "user_id": TEST_USER_ID,
            "story_id": story_id,
            "title": "Story to Delete",
            "summary": "This will be deleted",
            "source": "Delete Test"
        }
>       requests.post(f"{BASE_URL}/api/bookmarks", json=create_data)

backend/tests/test_persistence_v7.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/bookmarks', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestBookmarksPersistence.test_bookmark_upsert_behavior ____________

self = <test_persistence_v7.TestBookmarksPersistence object at 0xfd9f68136a50>

    def test_bookmark_upsert_behavior(self):
        """Test that same story_id updates existing bookmark (upsert)"""
        story_id = f"upsert_test_{uuid.uuid4().hex[:8]}"
    
        # Create initial bookmark
        initial_data = {
            "user_id": TEST_USER_ID,
            "story_id": story_id,
            "title": "Original Title",
            "summary": "Original summary",
            "source": "Original Source"
        }
>       requests.post(f"{BASE_URL}/api/bookmarks", json=initial_data)

backend/tests/test_persistence_v7.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/bookmarks', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/bookmarks': No scheme supplied. Perhaps you meant https:///api/bookmarks?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___ TestUserPreferencesPersistence.test_preferences_default_for_unknown_user ___

self = <test_persistence_v7.TestUserPreferencesPersistence object at 0xfd9f681343d0>

    def test_preferences_default_for_unknown_user(self):
        """Test that unknown user gets default preferences"""
        unknown_user = f"unknown_{uuid.uuid4().hex[:8]}"
>       response = requests.get(f"{BASE_URL}/api/preferences", params={"user_id": unknown_user})
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/preferences'
params = OrderedDict([('user_id', 'unknown_d93bb501')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/preferences': No scheme supplied. Perhaps you meant https:///api/preferences?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestUserPreferencesPersistence.test_save_preferences _____________

self = <test_persistence_v7.TestUserPreferencesPersistence object at 0xfd9f68137190>

    def test_save_preferences(self):
        """Test POST /api/preferences saves to MongoDB"""
        pref_user = f"pref_user_{uuid.uuid4().hex[:8]}"
        preferences = {
            "user_id": pref_user,
            "region": "nairobi",
            "voice": "yoruba",
            "interests": ["tech", "sports", "finance"]
        }
>       response = requests.post(f"{BASE_URL}/api/preferences", json=preferences)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:200: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/preferences'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/preferences': No scheme supplied. Perhaps you meant https:///api/preferences?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestUserPreferencesPersistence.test_get_saved_preferences ___________

self = <test_persistence_v7.TestUserPreferencesPersistence object at 0xfd9f681361d0>

    def test_get_saved_preferences(self):
        """Test GET /api/preferences returns saved preferences"""
        # First save preferences
        pref_user = f"get_pref_user_{uuid.uuid4().hex[:8]}"
        saved_prefs = {
            "user_id": pref_user,
            "region": "johannesburg",
            "voice": "igbo",
            "interests": ["politics", "culture"]
        }
>       save_response = requests.post(f"{BASE_URL}/api/preferences", json=saved_prefs)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/preferences'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/preferences': No scheme supplied. Perhaps you meant https:///api/preferences?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestUserPreferencesPersistence.test_preferences_update ____________

self = <test_persistence_v7.TestUserPreferencesPersistence object at 0xfd9f68137e90>

    def test_preferences_update(self):
        """Test that preferences can be updated"""
        pref_user = f"update_pref_user_{uuid.uuid4().hex[:8]}"
    
        # Initial save
        initial_prefs = {
            "user_id": pref_user,
            "region": "lagos",
            "voice": "pidgin",
            "interests": ["politics"]
        }
>       requests.post(f"{BASE_URL}/api/preferences", json=initial_prefs)

backend/tests/test_persistence_v7.py:246: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/preferences'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/preferences': No scheme supplied. Perhaps you meant https:///api/preferences?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestAdditionalAPIs.test_regions_endpoint ___________________

self = <test_persistence_v7.TestAdditionalAPIs object at 0xfd9f68134250>

    def test_regions_endpoint(self):
        """Test /api/regions returns region list"""
>       response = requests.get(f"{BASE_URL}/api/regions")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/regions', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/regions': No scheme supplied. Perhaps you meant https:///api/regions?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestAdditionalAPIs.test_categories_endpoint __________________

self = <test_persistence_v7.TestAdditionalAPIs object at 0xfd9f681360d0>

    def test_categories_endpoint(self):
        """Test /api/categories returns category list"""
>       response = requests.get(f"{BASE_URL}/api/categories")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/categories', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/categories': No scheme supplied. Perhaps you meant https:///api/categories?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestAdditionalAPIs.test_trending_endpoint ___________________

self = <test_persistence_v7.TestAdditionalAPIs object at 0xfd9f680f2a90>

    def test_trending_endpoint(self):
        """Test /api/trending returns trending data"""
>       response = requests.get(f"{BASE_URL}/api/trending")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/trending', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/trending': No scheme supplied. Perhaps you meant https:///api/trending?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestAdditionalAPIs.test_metrics_endpoint ___________________

self = <test_persistence_v7.TestAdditionalAPIs object at 0xfd9f683fbf10>

    def test_metrics_endpoint(self):
        """Test /api/metrics returns metrics"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestNewsDetail.test_news_detail_404_for_invalid_id ______________

self = <test_persistence_v7.TestNewsDetail object at 0xfd9f683f9010>

    def test_news_detail_404_for_invalid_id(self):
        """Test /api/news/{id} returns 404 for invalid ID"""
>       response = requests.get(f"{BASE_URL}/api/news/invalid_id_12345")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news/invalid_id_12345'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news/invalid_id_12345': No scheme supplied. Perhaps you meant https:///api/news/invalid_id_12345?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestNewsDetail.test_news_detail_for_valid_id _________________

self = <test_persistence_v7.TestNewsDetail object at 0xfd9f683f8d90>

    def test_news_detail_for_valid_id(self):
        """Test /api/news/{id} returns detail for valid ID"""
        # First get a valid ID from news list
>       list_response = requests.get(f"{BASE_URL}/api/news?limit=1")
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_persistence_v7.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestContentSources.test_sources_returns_total _________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestContentSources object at 0xfd9f683fb8d0>
client = <httpx.Client object at 0xfd9f67aca510>

    def test_sources_returns_total(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestContentSources.test_sources_has_regions __________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestContentSources object at 0xfd9f683fb110>
client = <httpx.Client object at 0xfd9f67796950>

    def test_sources_has_regions(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
________________ TestContentSources.test_sources_has_categories ________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestContentSources object at 0xfd9f683fa710>
client = <httpx.Client object at 0xfd9f675f25d0>

    def test_sources_has_categories(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________ TestContentSources.test_sources_lists_individual _______________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestContentSources object at 0xfd9f68152110>
client = <httpx.Client object at 0xfd9f675e2cd0>

    def test_sources_lists_individual(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__________________ TestContentSources.test_sources_no_dubawa ___________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestContentSources object at 0xfd9f68152090>
client = <httpx.Client object at 0xfd9f675ef110>

    def test_sources_no_dubawa(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________ TestContentSources.test_sources_has_aggregators ________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestContentSources object at 0xfd9f68153610>
client = <httpx.Client object at 0xfd9f675ebd90>

    def test_sources_has_aggregators(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
___________________ TestNewsEndpoint.test_news_returns_list ____________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestNewsEndpoint object at 0xfd9f68150e90>
client = <httpx.Client object at 0xfd9f6781c190>

    def test_news_returns_list(self, client):
>       r = client.get("/api/news?limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
______________________ TestNewsEndpoint.test_news_search _______________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestNewsEndpoint object at 0xfd9f68150350>
client = <httpx.Client object at 0xfd9f675dd150>

    def test_news_search(self, client):
>       r = client.get("/api/search?q=Nigeria&limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________________ TestSettings.test_save_settings ________________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestSettings object at 0xfd9f683f9410>
client = <httpx.Client object at 0xfd9f67602550>

    def test_save_settings(self, client):
>       r = client.post(
            f"/api/settings/{self.USER_ID}",
            json={"broadcast_language": "yo"},
        )

backend/tests/test_services.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
________________ TestSettings.test_fetch_settings_reflects_save ________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestSettings object at 0xfd9f68152b50>
client = <httpx.Client object at 0xfd9f675f9ad0>

    def test_fetch_settings_reflects_save(self, client):
>       client.post(
            f"/api/settings/{self.USER_ID}",
            json={"broadcast_language": "ha"},
        )

backend/tests/test_services.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
______________ TestSettings.test_settings_merge_preserves_fields _______________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestSettings object at 0xfd9f68151690>
client = <httpx.Client object at 0xfd9f677fea10>

    def test_settings_merge_preserves_fields(self, client):
        # Save both fields
>       client.post(
            f"/api/settings/{self.USER_ID}",
            json={"broadcast_language": "ig", "alert_volume": 90},
        )

backend/tests/test_services.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________ TestSettings.test_default_settings_for_unknown_user ______________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestSettings object at 0xfd9f68152e90>
client = <httpx.Client object at 0xfd9f675d1b50>

    def test_default_settings_for_unknown_user(self, client):
>       r = client.get("/api/settings/nonexistent_user_xyz_99")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________________ TestTranslation.test_languages_list ______________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestTranslation object at 0xfd9f681531d0>
client = <httpx.Client object at 0xfd9f678a4d50>

    def test_languages_list(self, client):
>       r = client.get("/api/translate/languages")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________________ TestTranslation.test_quick_translate _____________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestTranslation object at 0xfd9f68150fd0>
client = <httpx.Client object at 0xfd9f6788a590>

    def test_quick_translate(self, client):
>       r = client.get("/api/translate/quick?text=Hello&lang=pcm")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________________ TestFactCheck.test_factcheck_search ______________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestFactCheck object at 0xfd9f68150b90>
client = <httpx.Client object at 0xfd9f678a4050>

    def test_factcheck_search(self, client):
>       r = client.get("/api/factcheck/search?query=climate+change")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________________ TestFactCheck.test_factcheck_verify ______________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestFactCheck object at 0xfd9f681f2d50>
client = <httpx.Client object at 0xfd9f678899d0>

    def test_factcheck_verify(self, client):
>       r = client.get("/api/factcheck/verify?claim=The+earth+is+flat")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________ TestMetrics.test_metrics_includes_total_sources ________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestMetrics object at 0xfd9f681f0350>
client = <httpx.Client object at 0xfd9f678d6650>

    def test_metrics_includes_total_sources(self, client):
>       r = client.get("/api/metrics")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__________ TestMetrics.test_metrics_includes_local_and_international ___________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestMetrics object at 0xfd9f681f0650>
client = <httpx.Client object at 0xfd9f67969b50>

    def test_metrics_includes_local_and_international(self, client):
>       r = client.get("/api/metrics")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________________ TestHealth.test_health_endpoint ________________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_services.TestHealth object at 0xfd9f683cef90>
client = <httpx.Client object at 0xfd9f6761c110>

    def test_health_endpoint(self, client):
>       r = client.get("/api/health")
            ^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
______________ TestMetricsEndpoint.test_metrics_returns_real_data ______________

self = <test_services_v2.TestMetricsEndpoint object at 0xfd9f681b0a10>

    def test_metrics_returns_real_data(self):
        r = requests.get(f"{API_URL}/api/metrics")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:17: AssertionError
____________________ TestMetricsEndpoint.test_system_alerts ____________________

self = <test_services_v2.TestMetricsEndpoint object at 0xfd9f681b3390>

    def test_system_alerts(self):
        r = requests.get(f"{API_URL}/api/system-alerts")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:26: AssertionError
___________ TestFactcheckEndpoint.test_factcheck_returns_real_status ___________

self = <test_services_v2.TestFactcheckEndpoint object at 0xfd9f681b0c50>

    def test_factcheck_returns_real_status(self):
        r = requests.get(f"{API_URL}/api/factcheck/story/test-story-123")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:36: AssertionError
_________ TestFactcheckEndpoint.test_factcheck_different_stories_vary __________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_services_v2.TestFactcheckEndpoint object at 0xfd9f681b38d0>

    def test_factcheck_different_stories_vary(self):
>       r1 = requests.get(f"{API_URL}/api/factcheck/story/story-a").json()
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services_v2.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
___________________ TestPodcastEndpoints.test_podcasts_list ____________________

self = <test_services_v2.TestPodcastEndpoints object at 0xfd9f681b2590>

    def test_podcasts_list(self):
        r = requests.get(f"{API_URL}/api/podcasts?limit=5")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:52: AssertionError
_________________ TestPodcastEndpoints.test_podcast_categories _________________

self = <test_services_v2.TestPodcastEndpoints object at 0xfd9f681b0250>

    def test_podcast_categories(self):
        r = requests.get(f"{API_URL}/api/podcasts/categories")
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:63: AssertionError
___________________ TestPodcastEndpoints.test_podcast_search ___________________

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
>           return complexjson.loads(self.text, **kwargs)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/root/.venv/lib/python3.11/site-packages/requests/models.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0xfd9f69c26c90>
s = 'The preview environment is not responding. It may be starting up.\n'
idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.
    
        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.
    
        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/usr/local/lib/python3.11/json/decoder.py:355: JSONDecodeError

During handling of the above exception, another exception occurred:

self = <test_services_v2.TestPodcastEndpoints object at 0xfd9f681b2490>

    def test_podcast_search(self):
        # First get a podcast to know what to search for
>       podcasts = requests.get(f"{API_URL}/api/podcasts?limit=1").json()
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_services_v2.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Response [502]>, kwargs = {}

    def json(self, **kwargs):
        r"""Decodes the JSON response body (if any) as a Python object.
    
        This may return a dictionary, list, etc. depending on what is in the response.
    
        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        :raises requests.exceptions.JSONDecodeError: If the response body does not
            contain valid json.
        """
    
        if not self.encoding and self.content and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using charset_normalizer to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return complexjson.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
                except JSONDecodeError as e:
                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
    
        try:
            return complexjson.loads(self.text, **kwargs)
        except JSONDecodeError as e:
            # Catch JSON-related errors and raise as requests.JSONDecodeError
            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError
>           raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)
E           requests.exceptions.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.venv/lib/python3.11/site-packages/requests/models.py:980: JSONDecodeError
________________ TestListeningHistory.test_add_and_get_history _________________

self = <test_services_v2.TestListeningHistory object at 0xfd9f681b2910>

    def test_add_and_get_history(self):
        # Add entry
        r = requests.post(f"{API_URL}/api/listening-history", json={
            "user_id": "test-user-pytest",
            "track_id": "test-track-1",
            "title": "Test Broadcast",
            "source": "pytest",
            "category": "testing",
        })
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:87: AssertionError
_____________ TestTTSCaching.test_tts_caching_returns_same_result ______________

self = <test_services_v2.TestTTSCaching object at 0xfd9f68250090>

    def test_tts_caching_returns_same_result(self):
        payload = {"text": "Test caching", "voice_id": "nova", "language": "en"}
        r1 = requests.post(f"{API_URL}/api/tts/generate", json=payload)
        # Second call should hit cache
        r2 = requests.post(f"{API_URL}/api/tts/generate", json=payload)
>       assert r1.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:103: AssertionError
_____________ TestSettingsPersistence.test_save_and_read_settings ______________

self = <test_services_v2.TestSettingsPersistence object at 0xfd9f68253f50>

    def test_save_and_read_settings(self):
        uid = "test-settings-pytest"
        # Save
        payload = {
            "high_contrast": True,
            "interface_language": "yo",
            "theme": "light",
            "broadcast_language": "pcm",
        }
        r = requests.post(f"{API_URL}/api/settings/{uid}", json=payload)
>       assert r.status_code == 200
E       assert 502 == 200
E        +  where 502 = <Response [502]>.status_code

backend/tests/test_services_v2.py:121: AssertionError
_______________ TestTranslationAPI.test_get_supported_languages ________________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f68298890>

    def test_get_supported_languages(self):
        """Test /api/translate/languages returns all 5 supported languages"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_translation_factcheck.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestTranslationAPI.test_get_specific_language _________________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f6829a990>

    def test_get_specific_language(self):
        """Test /api/translate/languages/{code} returns language details"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages/pcm")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_translation_factcheck.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages/pcm'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages/pcm': No scheme supplied. Perhaps you meant https:///api/translate/languages/pcm?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestTranslationAPI.test_get_invalid_language _________________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f6829a410>

    def test_get_invalid_language(self):
        """Test /api/translate/languages/{code} returns 404 for invalid language"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages/invalid")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_translation_factcheck.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages/invalid'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages/invalid': No scheme supplied. Perhaps you meant https:///api/translate/languages/invalid?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestTranslationAPI.test_quick_translate_to_pidgin _______________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f681b2c90>

    def test_quick_translate_to_pidgin(self):
        """Test /api/translate/quick translates text to Pidgin"""
>       response = requests.get(
            f"{BASE_URL}/api/translate/quick",
            params={"text": "Hello world", "lang": "pcm"}
        )

backend/tests/test_translation_factcheck.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/quick'
params = OrderedDict([('text', 'Hello world'), ('lang', 'pcm')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/quick': No scheme supplied. Perhaps you meant https:///api/translate/quick?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestTranslationAPI.test_quick_translate_to_yoruba _______________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f68299590>

    def test_quick_translate_to_yoruba(self):
        """Test /api/translate/quick translates text to Yoruba"""
>       response = requests.get(
            f"{BASE_URL}/api/translate/quick",
            params={"text": "Good morning", "lang": "yo"}
        )

backend/tests/test_translation_factcheck.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/quick'
params = OrderedDict([('text', 'Good morning'), ('lang', 'yo')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/quick': No scheme supplied. Perhaps you meant https:///api/translate/quick?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestTranslationAPI.test_quick_translate_to_hausa _______________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f68299050>

    def test_quick_translate_to_hausa(self):
        """Test /api/translate/quick translates text to Hausa"""
>       response = requests.get(
            f"{BASE_URL}/api/translate/quick",
            params={"text": "Welcome to Nigeria", "lang": "ha"}
        )

backend/tests/test_translation_factcheck.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/quick'
params = OrderedDict([('text', 'Welcome to Nigeria'), ('lang', 'ha')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/quick': No scheme supplied. Perhaps you meant https:///api/translate/quick?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestTranslationAPI.test_quick_translate_to_igbo ________________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f6829ba50>

    def test_quick_translate_to_igbo(self):
        """Test /api/translate/quick translates text to Igbo"""
>       response = requests.get(
            f"{BASE_URL}/api/translate/quick",
            params={"text": "Thank you", "lang": "ig"}
        )

backend/tests/test_translation_factcheck.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/quick'
params = OrderedDict([('text', 'Thank you'), ('lang', 'ig')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/quick': No scheme supplied. Perhaps you meant https:///api/translate/quick?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestTranslationAPI.test_translate_text_post __________________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f682998d0>

    def test_translate_text_post(self):
        """Test /api/translate/text POST endpoint"""
>       response = requests.post(
            f"{BASE_URL}/api/translate/text",
            json={
                "text": "The government announced new policies today.",
                "target_language": "pcm",
                "source_language": "en"
            }
        )

backend/tests/test_translation_factcheck.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/translate/text'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/text': No scheme supplied. Perhaps you meant https:///api/translate/text?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestTranslationAPI.test_translate_narrate_endpoint ______________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f68299a90>

    def test_translate_narrate_endpoint(self):
        """Test /api/translate/narrate generates broadcast narrative"""
>       response = requests.post(
            f"{BASE_URL}/api/translate/narrate",
            json={
                "title": "Breaking News",
                "summary": "The government has announced new economic policies.",
                "target_language": "pcm"
            }
        )

backend/tests/test_translation_factcheck.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/translate/narrate'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/narrate': No scheme supplied. Perhaps you meant https:///api/translate/narrate?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestTranslationAPI.test_translate_invalid_language ______________

self = <test_translation_factcheck.TestTranslationAPI object at 0xfd9f6829b050>

    def test_translate_invalid_language(self):
        """Test translation with invalid language returns error"""
>       response = requests.post(
            f"{BASE_URL}/api/translate/text",
            json={
                "text": "Hello",
                "target_language": "invalid_lang",
                "source_language": "en"
            }
        )

backend/tests/test_translation_factcheck.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/translate/text'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/text': No scheme supplied. Perhaps you meant https:///api/translate/text?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestFactCheckAPI.test_factcheck_search ____________________

self = <test_translation_factcheck.TestFactCheckAPI object at 0xfd9f6829a950>

    def test_factcheck_search(self):
        """Test /api/factcheck/search returns fact-check results"""
>       response = requests.get(
            f"{BASE_URL}/api/factcheck/search",
            params={"query": "Nigeria election"}
        )

backend/tests/test_translation_factcheck.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/search'
params = OrderedDict([('query', 'Nigeria election')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/search': No scheme supplied. Perhaps you meant https:///api/factcheck/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestFactCheckAPI.test_factcheck_verify ____________________

self = <test_translation_factcheck.TestFactCheckAPI object at 0xfd9f68162dd0>

    def test_factcheck_verify(self):
        """Test /api/factcheck/verify returns verdict and confidence"""
>       response = requests.get(
            f"{BASE_URL}/api/factcheck/verify",
            params={"claim": "Nigeria election results"}
        )

backend/tests/test_translation_factcheck.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/verify'
params = OrderedDict([('claim', 'Nigeria election results')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/verify': No scheme supplied. Perhaps you meant https:///api/factcheck/verify?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestFactCheckAPI.test_factcheck_story _____________________

self = <test_translation_factcheck.TestFactCheckAPI object at 0xfd9f681622d0>

    def test_factcheck_story(self):
        """Test /api/factcheck/story/{story_id} returns status"""
>       response = requests.get(f"{BASE_URL}/api/factcheck/story/test-story-123")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_translation_factcheck.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/story/test-story-123'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/story/test-story-123': No scheme supplied. Perhaps you meant https:///api/factcheck/story/test-story-123?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestFactCheckAPI.test_factcheck_analyze ____________________

self = <test_translation_factcheck.TestFactCheckAPI object at 0xfd9f68162790>

    def test_factcheck_analyze(self):
        """Test /api/factcheck/analyze POST endpoint"""
>       response = requests.post(
            f"{BASE_URL}/api/factcheck/analyze",
            params={"text": "This is a confirmed official statement from the government."}
        )

backend/tests/test_translation_factcheck.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/factcheck/analyze'
params = OrderedDict([('text', 'This is a confirmed official statement from the government.')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/analyze': No scheme supplied. Perhaps you meant https:///api/factcheck/analyze?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestFactCheckAPI.test_factcheck_search_with_language _____________

self = <test_translation_factcheck.TestFactCheckAPI object at 0xfd9f68162f50>

    def test_factcheck_search_with_language(self):
        """Test /api/factcheck/search with language parameter"""
>       response = requests.get(
            f"{BASE_URL}/api/factcheck/search",
            params={"query": "COVID vaccine", "language": "en"}
        )

backend/tests/test_translation_factcheck.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/search'
params = OrderedDict([('query', 'COVID vaccine'), ('language', 'en')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/search': No scheme supplied. Perhaps you meant https:///api/factcheck/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestFactCheckAPI.test_factcheck_search_min_query_length ____________

self = <test_translation_factcheck.TestFactCheckAPI object at 0xfd9f68161990>

    def test_factcheck_search_min_query_length(self):
        """Test /api/factcheck/search requires minimum query length"""
>       response = requests.get(
            f"{BASE_URL}/api/factcheck/search",
            params={"query": "ab"}  # Less than 3 characters
        )

backend/tests/test_translation_factcheck.py:232: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/factcheck/search'
params = OrderedDict([('query', 'ab')])

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/factcheck/search': No scheme supplied. Perhaps you meant https:///api/factcheck/search?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestHealthAndIntegration.test_health_endpoint _________________

self = <test_translation_factcheck.TestHealthAndIntegration object at 0xfd9f68162810>

    def test_health_endpoint(self):
        """Test /api/health returns online status"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_translation_factcheck.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestTTS.test_tts_generate_returns_audio ____________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestTTS object at 0xfd9f68163390>
client = <httpx.Client object at 0xfd9f67844610>

    def test_tts_generate_returns_audio(self, client):
>       r = client.post(
            "/api/tts/generate",
            json={"text": "Hello Narvo", "voice_id": "onyx", "language": "en"},
        )

backend/tests/test_tts_podcast_aggregator.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestTTS.test_tts_voice_mapping_english_male __________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestTTS object at 0xfd9f68161b10>
client = <httpx.Client object at 0xfd9f6769b110>

    def test_tts_voice_mapping_english_male(self, client):
>       r = client.post(
            "/api/tts/generate",
            json={"text": "English test", "voice_id": "onyx", "language": "en"},
        )

backend/tests/test_tts_podcast_aggregator.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestTTS.test_tts_voice_mapping_yoruba_female _________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestTTS object at 0xfd9f6829bed0>
client = <httpx.Client object at 0xfd9f67732890>

    def test_tts_voice_mapping_yoruba_female(self, client):
>       r = client.post(
            "/api/tts/generate",
            json={"text": "Yoruba test", "voice_id": "onyx", "language": "yo"},
        )

backend/tests/test_tts_podcast_aggregator.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
___________________ TestTTS.test_tts_with_translation_pidgin ___________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestTTS object at 0xfd9f681b18d0>
client = <httpx.Client object at 0xfd9f67afdd50>

    def test_tts_with_translation_pidgin(self, client):
>       r = client.post(
            "/api/tts/generate",
            json={"text": "Welcome to the news", "voice_id": "onyx", "language": "pcm"},
        )

backend/tests/test_tts_podcast_aggregator.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1144: in post
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________________ TestTTS.test_tts_voices_list _________________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestTTS object at 0xfd9f68199c50>
client = <httpx.Client object at 0xfd9f677320d0>

    def test_tts_voices_list(self, client):
>       r = client.get("/api/voices")
            ^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
________________________ TestPodcast.test_podcasts_list ________________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestPodcast object at 0xfd9f6819b9d0>
client = <httpx.Client object at 0xfd9f6790d890>

    def test_podcasts_list(self, client):
>       r = client.get("/api/podcasts?limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_________________ TestPodcast.test_podcasts_list_main_endpoint _________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestPodcast object at 0xfd9f68198450>
client = <httpx.Client object at 0xfd9f67d4e5d0>

    def test_podcasts_list_main_endpoint(self, client):
>       r = client.get("/api/podcasts?limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
____________________ TestAggregators.test_aggregator_status ____________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestAggregators object at 0xfd9f68199fd0>
client = <httpx.Client object at 0xfd9f676ab190>

    def test_aggregator_status(self, client):
>       r = client.get("/api/aggregators/status")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
____________________ TestAggregators.test_fetch_mediastack _____________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestAggregators object at 0xfd9f68199e90>
client = <httpx.Client object at 0xfd9f67629610>

    def test_fetch_mediastack(self, client):
>       r = client.get("/api/aggregators/mediastack?keywords=Nigeria&limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_____________________ TestAggregators.test_fetch_newsdata ______________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestAggregators object at 0xfd9f681985d0>
client = <httpx.Client object at 0xfd9f676aaad0>

    def test_fetch_newsdata(self, client):
>       r = client.get("/api/aggregators/newsdata?query=Nigeria&limit=5")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__________________ TestAggregators.test_fetch_all_aggregators __________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestAggregators object at 0xfd9f68198950>
client = <httpx.Client object at 0xfd9f679cd290>

    def test_fetch_all_aggregators(self, client):
>       r = client.get("/api/aggregators/fetch?keywords=Nigeria")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
______________ TestAggregators.test_mediastack_article_structure _______________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestAggregators object at 0xfd9f68198810>
client = <httpx.Client object at 0xfd9f67699550>

    def test_mediastack_article_structure(self, client):
>       r = client.get("/api/aggregators/mediastack?keywords=Nigeria&limit=3")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
_______________ TestAggregators.test_newsdata_article_structure ________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestAggregators object at 0xfd9f68198490>
client = <httpx.Client object at 0xfd9f6780a410>

    def test_newsdata_article_structure(self, client):
>       r = client.get("/api/aggregators/newsdata?query=Nigeria&limit=3")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__________________ TestHealthRegression.test_health_endpoint ___________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestHealthRegression object at 0xfd9f68271690>
client = <httpx.Client object at 0xfd9f67dc3350>

    def test_health_endpoint(self, client):
>       r = client.get("/api/health")
            ^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
___________________ TestHealthRegression.test_sources_health ___________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestHealthRegression object at 0xfd9f682710d0>
client = <httpx.Client object at 0xfd9f679ce850>

    def test_sources_health(self, client):
>       r = client.get("/api/sources/health")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
___________________ TestHealthRegression.test_sources_count ____________________

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
>           yield

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:250: in handle_request
    resp = self._pool.handle_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:256: in handle_request
    raise exc from None
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection_pool.py:236: in handle_request
    response = connection.handle_request(
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:101: in handle_request
    raise exc
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:78: in handle_request
    stream = self._connect(request)
             ^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_sync/connection.py:124: in _connect
    stream = self._network_backend.connect_tcp(**kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpcore/_backends/sync.py:207: in connect_tcp
    with map_exceptions(exc_map):
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

map = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}

    @contextlib.contextmanager
    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:
        try:
            yield
        except Exception as exc:  # noqa: PIE786
            for from_exc, to_exc in map.items():
                if isinstance(exc, from_exc):
>                   raise to_exc(exc) from exc
E                   httpcore.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpcore/_exceptions.py:14: ConnectError

The above exception was the direct cause of the following exception:

self = <test_tts_podcast_aggregator.TestHealthRegression object at 0xfd9f682730d0>
client = <httpx.Client object at 0xfd9f67d618d0>

    def test_sources_count(self, client):
>       r = client.get("/api/sources")
            ^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_tts_podcast_aggregator.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1053: in get
    return self.request(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:825: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:914: in send
    response = self._send_handling_auth(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:942: in _send_handling_auth
    response = self._send_handling_redirects(
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:979: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_client.py:1014: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:249: in handle_request
    with map_httpcore_exceptions():
/usr/local/lib/python3.11/contextlib.py:158: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    @contextlib.contextmanager
    def map_httpcore_exceptions() -> typing.Iterator[None]:
        global HTTPCORE_EXC_MAP
        if len(HTTPCORE_EXC_MAP) == 0:
            HTTPCORE_EXC_MAP = _load_httpcore_exceptions()
        try:
            yield
        except Exception as exc:
            mapped_exc = None
    
            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():
                if not isinstance(exc, from_exc):
                    continue
                # We want to map to the most specific exception we can find.
                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to
                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.
                if mapped_exc is None or issubclass(to_exc, mapped_exc):
                    mapped_exc = to_exc
    
            if mapped_exc is None:  # pragma: no cover
                raise
    
            message = str(exc)
>           raise mapped_exc(message) from exc
E           httpx.ConnectError: [Errno 99] Cannot assign requested address

/root/.venv/lib/python3.11/site-packages/httpx/_transports/default.py:118: ConnectError
__________________ TestHealthAndMetrics.test_health_endpoint ___________________

self = <test_user_profile_radio.TestHealthAndMetrics object at 0xfd9f6819bed0>

    def test_health_endpoint(self):
        """Test /api/health returns online status"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestHealthAndMetrics.test_metrics_endpoint __________________

self = <test_user_profile_radio.TestHealthAndMetrics object at 0xfd9f68199310>

    def test_metrics_endpoint(self):
        """Test /api/metrics returns platform metrics for Account page"""
>       response = requests.get(f"{BASE_URL}/api/metrics")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/metrics', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/metrics': No scheme supplied. Perhaps you meant https:///api/metrics?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________________ TestVoiceStudioAPI.test_voices_endpoint ____________________

self = <test_user_profile_radio.TestVoiceStudioAPI object at 0xfd9f68273a50>

    def test_voices_endpoint(self):
        """Test /api/voices returns voice profiles for Voice Studio page"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestRadioIntegration.test_radio_countries_endpoint ______________

self = <test_user_profile_radio.TestRadioIntegration object at 0xfd9f68273fd0>

    def test_radio_countries_endpoint(self):
        """Test /api/radio/countries returns African countries"""
>       response = requests.get(f"{BASE_URL}/api/radio/countries")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/countries'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/countries': No scheme supplied. Perhaps you meant https:///api/radio/countries?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestRadioIntegration.test_radio_stations_nigeria _______________

self = <test_user_profile_radio.TestRadioIntegration object at 0xfd9f68271bd0>

    def test_radio_stations_nigeria(self):
        """Test /api/radio/stations returns Nigerian stations"""
>       response = requests.get(f"{BASE_URL}/api/radio/stations?country=NG&limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/stations?country=NG&limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/stations?country=NG&limit=5': No scheme supplied. Perhaps you meant https:///api/radio/stations?country=NG&limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________ TestRadioIntegration.test_radio_stations_ghana ________________

self = <test_user_profile_radio.TestRadioIntegration object at 0xfd9f68271110>

    def test_radio_stations_ghana(self):
        """Test /api/radio/stations returns Ghanaian stations"""
>       response = requests.get(f"{BASE_URL}/api/radio/stations?country=GH&limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/stations?country=GH&limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/stations?country=GH&limit=5': No scheme supplied. Perhaps you meant https:///api/radio/stations?country=GH&limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestRadioIntegration.test_radio_stations_south_africa _____________

self = <test_user_profile_radio.TestRadioIntegration object at 0xfd9f68270790>

    def test_radio_stations_south_africa(self):
        """Test /api/radio/stations returns South African stations"""
>       response = requests.get(f"{BASE_URL}/api/radio/stations?country=ZA&limit=5")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/stations?country=ZA&limit=5'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/stations?country=ZA&limit=5': No scheme supplied. Perhaps you meant https:///api/radio/stations?country=ZA&limit=5?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestRadioIntegration.test_radio_stations_default _______________

self = <test_user_profile_radio.TestRadioIntegration object at 0xfd9f68271010>

    def test_radio_stations_default(self):
        """Test /api/radio/stations without country filter returns African stations"""
>       response = requests.get(f"{BASE_URL}/api/radio/stations?limit=10")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/radio/stations?limit=10'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/radio/stations?limit=10': No scheme supplied. Perhaps you meant https:///api/radio/stations?limit=10?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________________________ TestNewsAPI.test_news_endpoint ________________________

self = <test_user_profile_radio.TestNewsAPI object at 0xfd9f68136250>

    def test_news_endpoint(self):
        """Test /api/news returns news items for Discover page hero"""
>       response = requests.get(f"{BASE_URL}/api/news?limit=1")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_user_profile_radio.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/news?limit=1'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/news?limit=1': No scheme supplied. Perhaps you meant https:///api/news?limit=1?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____ TestVoiceGenderMapping.test_translate_languages_endpoint_returns_200 _____

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f4250>

    def test_translate_languages_endpoint_returns_200(self):
        """GET /api/translate/languages returns 200"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestVoiceGenderMapping.test_translate_languages_returns_list _________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f6cd0>

    def test_translate_languages_returns_list(self):
        """Response is a list of languages"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestVoiceGenderMapping.test_translate_languages_has_gender_field _______

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f5d10>

    def test_translate_languages_has_gender_field(self):
        """Each language entry includes a 'gender' field"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestVoiceGenderMapping.test_english_voice_is_onyx_male ____________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f4c50>

    def test_english_voice_is_onyx_male(self):
        """English (en) maps to onyx voice (male)"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestVoiceGenderMapping.test_pidgin_voice_is_echo_male _____________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f7e90>

    def test_pidgin_voice_is_echo_male(self):
        """Naij Pidgin (pcm) maps to echo voice (male)"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestVoiceGenderMapping.test_yoruba_voice_is_nova_female ____________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f6710>

    def test_yoruba_voice_is_nova_female(self):
        """Yorb (yo) maps to nova voice (female)"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestVoiceGenderMapping.test_hausa_voice_is_shimmer_female ___________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f68270c10>

    def test_hausa_voice_is_shimmer_female(self):
        """Hausa (ha) maps to shimmer voice (female)"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestVoiceGenderMapping.test_igbo_voice_is_alloy_female ____________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f6390>

    def test_igbo_voice_is_alloy_female(self):
        """Igbo (ig) maps to alloy voice (female)"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestVoiceGenderMapping.test_all_voice_mappings_complete ____________

self = <test_voice_mapping_v31.TestVoiceGenderMapping object at 0xfd9f680f6bd0>

    def test_all_voice_mappings_complete(self):
        """Verify all 5 voice mappings match requirements"""
>       response = requests.get(f"{BASE_URL}/api/translate/languages")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:104: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/translate/languages'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/translate/languages': No scheme supplied. Perhaps you meant https:///api/translate/languages?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_____________ TestVoicesEndpoint.test_voices_endpoint_returns_200 ______________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f680f65d0>

    def test_voices_endpoint_returns_200(self):
        """GET /api/voices returns 200"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________________ TestVoicesEndpoint.test_voices_returns_list __________________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f680f6ed0>

    def test_voices_returns_list(self):
        """Response is a list of voice profiles"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______________ TestVoicesEndpoint.test_voices_have_gender_field _______________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f680f7b10>

    def test_voices_have_gender_field(self):
        """Each voice profile includes a 'gender' field"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
______________ TestVoicesEndpoint.test_voices_have_nigerian_names ______________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f6822a810>

    def test_voices_have_nigerian_names(self):
        """Voice profiles have authentic Nigerian names"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestVoicesEndpoint.test_onyx_voice_is_male __________________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f6822b4d0>

    def test_onyx_voice_is_male(self):
        """Onyx voice (Emeka) is male"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________________ TestVoicesEndpoint.test_echo_voice_is_male __________________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f6822bad0>

    def test_echo_voice_is_male(self):
        """Echo voice (Tunde) is male"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________________ TestVoicesEndpoint.test_female_voices _____________________

self = <test_voice_mapping_v31.TestVoicesEndpoint object at 0xfd9f682282d0>

    def test_female_voices(self):
        """Nova, Shimmer, Alloy are female voices"""
>       response = requests.get(f"{BASE_URL}/api/voices")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/voices', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/voices': No scheme supplied. Perhaps you meant https:///api/voices?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
___________ TestHealthCheckPeriodic.test_sources_health_returns_200 ____________

self = <test_voice_mapping_v31.TestHealthCheckPeriodic object at 0xfd9f6822b990>

    def test_sources_health_returns_200(self):
        """GET /api/sources/health returns 200"""
>       response = requests.get(f"{BASE_URL}/api/sources/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
________ TestHealthCheckPeriodic.test_sources_health_has_sources_array _________

self = <test_voice_mapping_v31.TestHealthCheckPeriodic object at 0xfd9f6822acd0>

    def test_sources_health_has_sources_array(self):
        """Health response has sources array"""
>       response = requests.get(f"{BASE_URL}/api/sources/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:208: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_________ TestHealthCheckPeriodic.test_sources_health_has_last_checked _________

self = <test_voice_mapping_v31.TestHealthCheckPeriodic object at 0xfd9f6822a6d0>

    def test_sources_health_has_last_checked(self):
        """Health data sources have last_checked timestamp"""
>       response = requests.get(f"{BASE_URL}/api/sources/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestHealthCheckPeriodic.test_sources_health_summary_counts __________

self = <test_voice_mapping_v31.TestHealthCheckPeriodic object at 0xfd9f6822ae50>

    def test_sources_health_summary_counts(self):
        """Health response has green/amber/red counts"""
>       response = requests.get(f"{BASE_URL}/api/sources/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources/health'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health': No scheme supplied. Perhaps you meant https:///api/sources/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestHealthCheckPeriodic.test_sources_health_refresh_still_works ________

self = <test_voice_mapping_v31.TestHealthCheckPeriodic object at 0xfd9f67fd80d0>

    def test_sources_health_refresh_still_works(self):
        """POST /api/sources/health/refresh works"""
>       response = requests.post(f"{BASE_URL}/api/sources/health/refresh")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/sources/health/refresh'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health/refresh': No scheme supplied. Perhaps you meant https:///api/sources/health/refresh?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestHealthCheckPeriodic.test_health_data_non_null_after_refresh ________

self = <test_voice_mapping_v31.TestHealthCheckPeriodic object at 0xfd9f67fd9c90>

    def test_health_data_non_null_after_refresh(self):
        """After refresh, sources should have last_checked timestamps"""
        # Trigger a refresh first
>       requests.post(f"{BASE_URL}/api/sources/health/refresh")

backend/tests/test_voice_mapping_v31.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:115: in post
    return request("post", url, data=data, json=json, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [POST]>, url = '/api/sources/health/refresh'
params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources/health/refresh': No scheme supplied. Perhaps you meant https:///api/sources/health/refresh?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
_______ TestRegressionPreviousFeatures.test_api_sources_returns_39_feeds _______

self = <test_voice_mapping_v31.TestRegressionPreviousFeatures object at 0xfd9f67fdae50>

    def test_api_sources_returns_39_feeds(self):
        """GET /api/sources still returns 39 total feeds"""
>       response = requests.get(f"{BASE_URL}/api/sources")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources': No scheme supplied. Perhaps you meant https:///api/sources?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
__________ TestRegressionPreviousFeatures.test_api_sources_3_regions ___________

self = <test_voice_mapping_v31.TestRegressionPreviousFeatures object at 0xfd9f6822a710>

    def test_api_sources_3_regions(self):
        """GET /api/sources has 3 regions"""
>       response = requests.get(f"{BASE_URL}/api/sources")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/sources', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/sources': No scheme supplied. Perhaps you meant https:///api/sources?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
____________ TestRegressionPreviousFeatures.test_api_health_status _____________

self = <test_voice_mapping_v31.TestRegressionPreviousFeatures object at 0xfd9f6822b910>

    def test_api_health_status(self):
        """GET /api/health returns online"""
>       response = requests.get(f"{BASE_URL}/api/health")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

backend/tests/test_voice_mapping_v31.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/root/.venv/lib/python3.11/site-packages/requests/api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:575: in request
    prep = self.prepare_request(req)
           ^^^^^^^^^^^^^^^^^^^^^^^^^
/root/.venv/lib/python3.11/site-packages/requests/sessions.py:484: in prepare_request
    p.prepare(
/root/.venv/lib/python3.11/site-packages/requests/models.py:367: in prepare
    self.prepare_url(url, params)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <PreparedRequest [GET]>, url = '/api/health', params = OrderedDict()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        #: We're unable to blindly call unicode/str functions
        #: as this will include the bytestring indicator (b'')
        #: on python 3.x.
        #: https://github.com/psf/requests/pull/2238
        if isinstance(url, bytes):
            url = url.decode("utf8")
        else:
            url = str(url)
    
        # Remove leading whitespaces from url
        url = url.lstrip()
    
        # Don't do any URL preparation for non-HTTP schemes like `mailto`,
        # `data` etc to work around exceptions from `url_parse`, which
        # handles RFC 3986 only.
        if ":" in url and not url.lower().startswith("http"):
            self.url = url
            return
    
        # Support for unicode domain names and paths.
        try:
            scheme, auth, host, port, path, query, fragment = parse_url(url)
        except LocationParseError as e:
            raise InvalidURL(*e.args)
    
        if not scheme:
>           raise MissingSchema(
                f"Invalid URL {url!r}: No scheme supplied. "
                f"Perhaps you meant https://{url}?"
            )
E           requests.exceptions.MissingSchema: Invalid URL '/api/health': No scheme supplied. Perhaps you meant https:///api/health?

/root/.venv/lib/python3.11/site-packages/requests/models.py:438: MissingSchema
=========================== short test summary info ============================
FAILED backend/tests/test_admin_factcheck_api.py::TestHealthCheck::test_health_endpoint
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminMetricsAPI::test_metrics_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminMetricsAPI::test_metrics_has_required_fields
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminMetricsAPI::test_metrics_values_are_valid
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminAlertsAPI::test_alerts_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminAlertsAPI::test_alerts_returns_list
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminAlertsAPI::test_alert_structure
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminStreamsAPI::test_streams_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminStreamsAPI::test_streams_returns_list
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminStreamsAPI::test_stream_structure
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminVoicesAPI::test_voices_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminVoicesAPI::test_voices_returns_list
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminVoicesAPI::test_voice_structure
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminModerationAPI::test_moderation_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminModerationAPI::test_moderation_returns_list
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminModerationAPI::test_moderation_item_structure
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminStatsAPI::test_stats_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminStatsAPI::test_stats_has_required_fields
FAILED backend/tests/test_admin_factcheck_api.py::TestAdminStatsAPI::test_stats_dubawa_status
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckStoryAPI::test_factcheck_story_returns_200
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckStoryAPI::test_factcheck_story_structure
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckStoryAPI::test_factcheck_different_stories_may_vary
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckAnalyzeAPI::test_analyze_confirmed_text
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckAnalyzeAPI::test_analyze_disputed_text
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckAnalyzeAPI::test_analyze_rumor_text
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckAnalyzeAPI::test_analyze_neutral_text
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckAnalyzeAPI::test_analyze_false_text
FAILED backend/tests/test_admin_factcheck_api.py::TestFactCheckAnalyzeAPI::test_analyze_response_structure
FAILED backend/tests/test_aggregator_integration_v33.py::TestNewsWithAggregators::test_news_with_include_aggregators_returns_aggregator_field
FAILED backend/tests/test_aggregator_integration_v33.py::TestNewsWithAggregators::test_news_without_include_aggregators_no_aggregator_field
FAILED backend/tests/test_aggregator_integration_v33.py::TestNewsWithAggregators::test_news_include_aggregators_false
FAILED backend/tests/test_aggregator_integration_v33.py::TestMetricsWithAggregators::test_metrics_includes_aggregators_object
FAILED backend/tests/test_aggregator_integration_v33.py::TestMetricsWithAggregators::test_metrics_aggregators_cached_count
FAILED backend/tests/test_aggregator_integration_v33.py::TestAggregatorsStatus::test_aggregators_status_configured
FAILED backend/tests/test_aggregator_integration_v33.py::TestAggregatorsStatus::test_aggregators_status_after_fetch
FAILED backend/tests/test_aggregator_integration_v33.py::TestAggregatorArticleFields::test_mediastack_articles_have_aggregator_field
FAILED backend/tests/test_aggregator_integration_v33.py::TestAggregatorArticleFields::test_newsdata_articles_have_aggregator_field
FAILED backend/tests/test_aggregator_integration_v33.py::TestRegressionFeatures::test_health_endpoint
FAILED backend/tests/test_aggregator_integration_v33.py::TestRegressionFeatures::test_sources_health_39_feeds
FAILED backend/tests/test_aggregator_integration_v33.py::TestRegressionFeatures::test_sources_count_39
FAILED backend/tests/test_aggregator_integration_v33.py::TestRegressionFeatures::test_voices_endpoint
FAILED backend/tests/test_aggregator_integration_v33.py::TestRegressionFeatures::test_news_basic_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestHealthAndBasicEndpoints::test_health_check
FAILED backend/tests/test_ai_sanitizer_v37.py::TestHealthAndBasicEndpoints::test_news_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestHealthAndBasicEndpoints::test_search_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestParaphraseSanitizer::test_paraphrase_basic
FAILED backend/tests/test_ai_sanitizer_v37.py::TestParaphraseSanitizer::test_paraphrase_strips_brackets
FAILED backend/tests/test_ai_sanitizer_v37.py::TestTranslationSanitizer::test_translate_to_pidgin
FAILED backend/tests/test_ai_sanitizer_v37.py::TestTranslationSanitizer::test_translate_to_yoruba
FAILED backend/tests/test_ai_sanitizer_v37.py::TestTranslationSanitizer::test_supported_languages_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestBriefingScriptSanitizer::test_briefing_generate
FAILED backend/tests/test_ai_sanitizer_v37.py::TestBriefingScriptSanitizer::test_briefing_history
FAILED backend/tests/test_ai_sanitizer_v37.py::TestSanitizerIntegration::test_multiple_paraphrases_no_sfx
FAILED backend/tests/test_ai_sanitizer_v37.py::TestRegressionEndpoints::test_voices_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestRegressionEndpoints::test_categories_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestRegressionEndpoints::test_regions_endpoint
FAILED backend/tests/test_ai_sanitizer_v37.py::TestRegressionEndpoints::test_metrics_endpoint
FAILED backend/tests/test_emptystate_truthtag_share.py::TestSettingsAPI::test_get_default_settings
FAILED backend/tests/test_emptystate_truthtag_share.py::TestSettingsAPI::test_save_user_settings
FAILED backend/tests/test_emptystate_truthtag_share.py::TestVoiceSettingsAPI::test_get_voice_settings
FAILED backend/tests/test_emptystate_truthtag_share.py::TestVoiceSettingsAPI::test_save_voice_settings
FAILED backend/tests/test_emptystate_truthtag_share.py::TestVoiceSettingsAPI::test_voice_settings_persistence
FAILED backend/tests/test_emptystate_truthtag_share.py::TestFactCheckAPI::test_factcheck_story
FAILED backend/tests/test_emptystate_truthtag_share.py::TestFactCheckAPI::test_factcheck_different_stories
FAILED backend/tests/test_emptystate_truthtag_share.py::TestFactCheckAPI::test_factcheck_analyze_verified
FAILED backend/tests/test_emptystate_truthtag_share.py::TestFactCheckAPI::test_factcheck_analyze_disputed
FAILED backend/tests/test_emptystate_truthtag_share.py::TestFactCheckAPI::test_factcheck_analyze_neutral
FAILED backend/tests/test_emptystate_truthtag_share.py::TestVoicesAPI::test_get_voices
FAILED backend/tests/test_emptystate_truthtag_share.py::TestVoicesAPI::test_voice_ids_valid
FAILED backend/tests/test_emptystate_truthtag_share.py::TestNewsAPI::test_get_news_list
FAILED backend/tests/test_emptystate_truthtag_share.py::TestNewsAPI::test_news_has_id_for_truthtag
FAILED backend/tests/test_emptystate_truthtag_share.py::TestBookmarksAPI::test_get_empty_bookmarks
FAILED backend/tests/test_emptystate_truthtag_share.py::TestBookmarksAPI::test_add_and_get_bookmark
FAILED backend/tests/test_emptystate_truthtag_share.py::TestBookmarksAPI::test_remove_bookmark
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_sources_health_endpoint_returns_200
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_sources_health_has_summary_counts
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_sources_health_has_sources_array
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_sources_health_refresh_endpoint
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_sources_health_regions_covered
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_health_refresh_then_verify_updated
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_health_sources_latency_values
FAILED backend/tests/test_health_monitoring_v30.py::TestHealthMonitoringAPI::test_health_last_checked_format
FAILED backend/tests/test_health_monitoring_v30.py::TestExistingFeaturesRegression::test_api_sources_still_returns_39
FAILED backend/tests/test_health_monitoring_v30.py::TestExistingFeaturesRegression::test_api_metrics_endpoint
FAILED backend/tests/test_health_monitoring_v30.py::TestExistingFeaturesRegression::test_api_news_endpoint
FAILED backend/tests/test_health_monitoring_v30.py::TestExistingFeaturesRegression::test_api_health_endpoint
FAILED backend/tests/test_i18n_settings_v16.py::TestSettingsAPI::test_get_default_settings_for_guest
FAILED backend/tests/test_i18n_settings_v16.py::TestSettingsAPI::test_save_system_settings
FAILED backend/tests/test_i18n_settings_v16.py::TestSettingsAPI::test_save_accessibility_settings
FAILED backend/tests/test_i18n_settings_v16.py::TestSettingsAPI::test_settings_merge_behavior
FAILED backend/tests/test_i18n_settings_v16.py::TestNewsDetailAPI::test_get_news_list
FAILED backend/tests/test_i18n_settings_v16.py::TestNewsDetailAPI::test_get_news_detail_with_narrative
FAILED backend/tests/test_i18n_settings_v16.py::TestNewsDetailAPI::test_factcheck_api_for_truthtag
FAILED backend/tests/test_i18n_settings_v16.py::TestRadioAPI::test_get_radio_countries
FAILED backend/tests/test_i18n_settings_v16.py::TestRadioAPI::test_get_radio_stations_by_country
FAILED backend/tests/test_i18n_settings_v16.py::TestVoicesAPI::test_get_voices
FAILED backend/tests/test_i18n_settings_v16.py::TestVoicesAPI::test_save_voice_settings
FAILED backend/tests/test_i18n_settings_v16.py::TestHealthAPI::test_health_endpoint
FAILED backend/tests/test_iteration42.py::TestPodcastEndpoints::test_podcast_categories_returns_8_categories
FAILED backend/tests/test_iteration42.py::TestPodcastEndpoints::test_podcast_search_with_arctic_query
FAILED backend/tests/test_iteration42.py::TestPodcastEndpoints::test_podcast_list_returns_episodes
FAILED backend/tests/test_iteration42.py::TestSettingsPersistence::test_save_and_retrieve_guest_settings
FAILED backend/tests/test_iteration42.py::TestSettingsPersistence::test_settings_merge_behavior
FAILED backend/tests/test_iteration42.py::TestVoicesEndpoint::test_voices_returns_all_profiles
FAILED backend/tests/test_iteration42.py::TestHealthEndpoint::test_api_health
FAILED backend/tests/test_iteration_17.py::TestBreakingNewsAPI::test_breaking_news_returns_200
FAILED backend/tests/test_iteration_17.py::TestBreakingNewsAPI::test_breaking_news_returns_list
FAILED backend/tests/test_iteration_17.py::TestBreakingNewsAPI::test_breaking_news_has_at_least_one_story
FAILED backend/tests/test_iteration_17.py::TestBreakingNewsAPI::test_breaking_news_story_structure
FAILED backend/tests/test_iteration_17.py::TestNewsAPI::test_news_returns_200
FAILED backend/tests/test_iteration_17.py::TestNewsAPI::test_news_returns_list_with_items
FAILED backend/tests/test_iteration_17.py::TestNewsAPI::test_news_has_category_field
FAILED backend/tests/test_iteration_17.py::TestNewsAPI::test_news_has_tags_field
FAILED backend/tests/test_iteration_17.py::TestRouteOrdering::test_breaking_before_news_id
FAILED backend/tests/test_iteration_17.py::TestHealthAndMetrics::test_health_check
FAILED backend/tests/test_iteration_17.py::TestHealthAndMetrics::test_metrics_endpoint
FAILED backend/tests/test_iteration_17.py::TestCategoriesAPI::test_categories_endpoint
FAILED backend/tests/test_iteration_18.py::TestHealthAndBasics::test_health_endpoint
FAILED backend/tests/test_iteration_18.py::TestBreakingNewsAPI::test_breaking_news_endpoint_returns_200
FAILED backend/tests/test_iteration_18.py::TestBreakingNewsAPI::test_breaking_news_returns_list
FAILED backend/tests/test_iteration_18.py::TestBreakingNewsAPI::test_breaking_news_has_stories
FAILED backend/tests/test_iteration_18.py::TestBreakingNewsAPI::test_breaking_news_story_structure
FAILED backend/tests/test_iteration_18.py::TestBreakingNewsAPI::test_breaking_news_max_3_stories
FAILED backend/tests/test_iteration_18.py::TestMetricsAPI::test_metrics_endpoint_returns_200
FAILED backend/tests/test_iteration_18.py::TestMetricsAPI::test_metrics_has_required_fields
FAILED backend/tests/test_iteration_18.py::TestMetricsAPI::test_metrics_values_are_valid
FAILED backend/tests/test_iteration_18.py::TestOGImageEndpoint::test_og_endpoint_returns_html
FAILED backend/tests/test_iteration_18.py::TestOGImageEndpoint::test_og_endpoint_has_og_title
FAILED backend/tests/test_iteration_18.py::TestOGImageEndpoint::test_og_endpoint_has_og_description
FAILED backend/tests/test_iteration_18.py::TestOGImageEndpoint::test_og_endpoint_has_twitter_card
FAILED backend/tests/test_iteration_18.py::TestOGImageEndpoint::test_og_endpoint_invalid_id_returns_404
FAILED backend/tests/test_iteration_18.py::TestNewsAPI::test_news_endpoint_returns_200
FAILED backend/tests/test_iteration_18.py::TestNewsAPI::test_news_returns_list
FAILED backend/tests/test_iteration_18.py::TestNewsAPI::test_news_limit_parameter
FAILED backend/tests/test_iteration_18.py::TestNewsAPI::test_news_item_structure
FAILED backend/tests/test_iteration_18.py::TestNewsDetailAPI::test_news_detail_returns_200
FAILED backend/tests/test_iteration_18.py::TestNewsDetailAPI::test_news_detail_invalid_id_returns_404
FAILED backend/tests/test_iteration_19.py::TestHealthAndBasicAPIs::test_health_endpoint
FAILED backend/tests/test_iteration_19.py::TestHealthAndBasicAPIs::test_news_endpoint
FAILED backend/tests/test_iteration_19.py::TestHealthAndBasicAPIs::test_categories_endpoint
FAILED backend/tests/test_iteration_19.py::TestSearchAPI::test_search_with_query
FAILED backend/tests/test_iteration_19.py::TestSearchAPI::test_search_with_category_filter
FAILED backend/tests/test_iteration_19.py::TestSearchAPI::test_search_empty_query
FAILED backend/tests/test_iteration_19.py::TestSearchAPI::test_search_pagination
FAILED backend/tests/test_iteration_19.py::TestTrendingAPI::test_trending_endpoint
FAILED backend/tests/test_iteration_19.py::TestTrendingAPI::test_trending_tags_format
FAILED backend/tests/test_iteration_19.py::TestBriefingAPI::test_briefing_history
FAILED backend/tests/test_iteration_19.py::TestBriefingAPI::test_briefing_latest
FAILED backend/tests/test_iteration_19.py::TestBriefingAPI::test_briefing_by_date_invalid
FAILED backend/tests/test_iteration_19.py::TestVoicesAPI::test_voices_endpoint
FAILED backend/tests/test_iteration_19.py::TestBookmarksAPI::test_get_bookmarks_guest
FAILED backend/tests/test_iteration_19.py::TestBookmarksAPI::test_add_bookmark
FAILED backend/tests/test_iteration_19.py::TestBookmarksAPI::test_delete_bookmark
FAILED backend/tests/test_iteration_19.py::TestTTSAPI::test_tts_generate - as...
FAILED backend/tests/test_iteration_19.py::TestOGImageAPI::test_og_image_endpoint
FAILED backend/tests/test_iteration_19.py::TestOGImageAPI::test_og_image_invalid_id
FAILED backend/tests/test_iteration_19.py::TestFactCheckAPI::test_factcheck_story
FAILED backend/tests/test_iteration_20.py::TestHealthAndBasicAPIs::test_health_endpoint
FAILED backend/tests/test_iteration_20.py::TestHealthAndBasicAPIs::test_news_endpoint
FAILED backend/tests/test_iteration_20.py::TestShareURLOGTags::test_share_endpoint_with_crawler_user_agent
FAILED backend/tests/test_iteration_20.py::TestShareURLOGTags::test_share_endpoint_with_regular_browser
FAILED backend/tests/test_iteration_20.py::TestShareURLOGTags::test_share_endpoint_invalid_id
FAILED backend/tests/test_iteration_20.py::TestBriefingAPI::test_briefing_latest
FAILED backend/tests/test_iteration_20.py::TestBriefingAPI::test_briefing_history
FAILED backend/tests/test_iteration_20.py::TestBriefingAPI::test_voices_endpoint
FAILED backend/tests/test_iteration_20.py::TestSearchAPI::test_search_endpoint
FAILED backend/tests/test_iteration_20.py::TestSearchAPI::test_trending_endpoint
FAILED backend/tests/test_iteration_20.py::TestBookmarksAPI::test_get_bookmarks
FAILED backend/tests/test_iteration_20.py::TestBookmarksAPI::test_add_and_remove_bookmark
FAILED backend/tests/test_iteration_20.py::TestOGImageEndpoint::test_og_image_endpoint
FAILED backend/tests/test_iteration_20.py::TestOGImageEndpoint::test_og_image_invalid_id
FAILED backend/tests/test_iteration_22.py::TestHealthAndBasicAPI::test_health_endpoint
FAILED backend/tests/test_iteration_22.py::TestHealthAndBasicAPI::test_news_endpoint_returns_items
FAILED backend/tests/test_iteration_22.py::TestHealthAndBasicAPI::test_news_item_has_required_fields
FAILED backend/tests/test_iteration_22.py::TestNewsImageExtraction::test_news_item_has_image_url_field
FAILED backend/tests/test_iteration_22.py::TestNewsImageExtraction::test_news_detail_has_image_url
FAILED backend/tests/test_iteration_22.py::TestMetricsAPI::test_metrics_endpoint
FAILED backend/tests/test_iteration_22.py::TestCategoriesAndRegions::test_categories_endpoint
FAILED backend/tests/test_iteration_22.py::TestCategoriesAndRegions::test_regions_endpoint
FAILED backend/tests/test_iteration_22.py::TestBreakingNews::test_breaking_news_endpoint
FAILED backend/tests/test_iteration_22.py::TestVoicesAPI::test_voices_endpoint
FAILED backend/tests/test_iteration_22.py::TestFactCheckAPI::test_factcheck_by_story_id
FAILED backend/tests/test_iteration_23.py::TestNewsImageUrl::test_news_endpoint_returns_data
FAILED backend/tests/test_iteration_23.py::TestNewsImageUrl::test_news_items_have_image_url_field
FAILED backend/tests/test_iteration_23.py::TestNewsImageUrl::test_news_item_structure
FAILED backend/tests/test_iteration_23.py::TestHealthAndMetrics::test_health_endpoint
FAILED backend/tests/test_iteration_23.py::TestHealthAndMetrics::test_metrics_endpoint
FAILED backend/tests/test_iteration_23.py::TestRSSFeeds::test_news_from_vanguard_source
FAILED backend/tests/test_iteration_23.py::TestCategories::test_categories_endpoint
FAILED backend/tests/test_iteration_23.py::TestCategories::test_regions_endpoint
FAILED backend/tests/test_iteration_23.py::TestVoicesAndTrending::test_voices_endpoint
FAILED backend/tests/test_iteration_23.py::TestVoicesAndTrending::test_trending_endpoint
FAILED backend/tests/test_iteration_24.py::TestHealthAndBasics::test_health_endpoint
FAILED backend/tests/test_iteration_24.py::TestDiscoverPodcasts::test_get_podcasts_latest
FAILED backend/tests/test_iteration_24.py::TestDiscoverPodcasts::test_get_podcasts_popular
FAILED backend/tests/test_iteration_24.py::TestDiscoverPodcasts::test_podcasts_have_required_fields
FAILED backend/tests/test_iteration_24.py::TestDiscoverTrending::test_get_trending_topics
FAILED backend/tests/test_iteration_24.py::TestRadioStations::test_get_radio_countries
FAILED backend/tests/test_iteration_24.py::TestRadioStations::test_get_radio_stations_by_country
FAILED backend/tests/test_iteration_24.py::TestOfflineArticles::test_save_offline_article
FAILED backend/tests/test_iteration_24.py::TestOfflineArticles::test_get_offline_articles
FAILED backend/tests/test_iteration_24.py::TestOfflineArticles::test_delete_offline_article
FAILED backend/tests/test_iteration_24.py::TestOfflineArticles::test_get_offline_stats
FAILED backend/tests/test_iteration_24.py::TestNewsEndpoints::test_get_news
FAILED backend/tests/test_iteration_25.py::TestHealthAndBasicEndpoints::test_health_endpoint
FAILED backend/tests/test_iteration_25.py::TestModularRoutes::test_podcasts_endpoint
FAILED backend/tests/test_iteration_25.py::TestModularRoutes::test_discover_trending_endpoint
FAILED backend/tests/test_iteration_25.py::TestModularRoutes::test_radio_countries_endpoint
FAILED backend/tests/test_iteration_25.py::TestModularRoutes::test_offline_stats_endpoint
FAILED backend/tests/test_iteration_25.py::TestModularRoutes::test_admin_metrics_endpoint
FAILED backend/tests/test_iteration_25.py::TestModularRoutes::test_voices_endpoint
FAILED backend/tests/test_iteration_25.py::TestOfflineAPI::test_save_article_offline
FAILED backend/tests/test_iteration_25.py::TestOfflineAPI::test_get_offline_articles
FAILED backend/tests/test_iteration_25.py::TestOfflineAPI::test_delete_offline_article
FAILED backend/tests/test_iteration_25.py::TestOfflineAPI::test_verify_article_deleted
FAILED backend/tests/test_iteration_25.py::TestNewsAPI::test_news_endpoint - ...
FAILED backend/tests/test_iteration_25.py::TestNewsAPI::test_breaking_news_endpoint
FAILED backend/tests/test_iteration_25.py::TestAdminRoutes::test_admin_alerts
FAILED backend/tests/test_iteration_25.py::TestAdminRoutes::test_admin_streams
FAILED backend/tests/test_iteration_25.py::TestAdminRoutes::test_admin_voices
FAILED backend/tests/test_iteration_34.py::TestAggregatorStatusCaching::test_aggregators_status_has_cache_ttl_seconds
FAILED backend/tests/test_iteration_34.py::TestAggregatorStatusCaching::test_aggregators_status_has_cache_stale_field
FAILED backend/tests/test_iteration_34.py::TestAggregatorStatusCaching::test_aggregators_status_has_last_fetched
FAILED backend/tests/test_iteration_34.py::TestNewsWithAggregatorSourceFilter::test_news_include_aggregators_returns_mixed_content
FAILED backend/tests/test_iteration_34.py::TestNewsWithAggregatorSourceFilter::test_news_aggregator_sources_mediastack_only
FAILED backend/tests/test_iteration_34.py::TestNewsWithAggregatorSourceFilter::test_news_aggregator_sources_newsdata_only
FAILED backend/tests/test_iteration_34.py::TestNewsWithAggregatorSourceFilter::test_news_aggregator_sources_both
FAILED backend/tests/test_iteration_34.py::TestSearchWithAggregators::test_search_include_aggregators_default_true
FAILED backend/tests/test_iteration_34.py::TestSearchWithAggregators::test_search_include_aggregators_true_explicit
FAILED backend/tests/test_iteration_34.py::TestSearchWithAggregators::test_search_include_aggregators_false
FAILED backend/tests/test_iteration_34.py::TestSearchWithAggregators::test_search_returns_correct_structure
FAILED backend/tests/test_iteration_34.py::TestUserSettingsAggregatorPreferences::test_get_settings_has_aggregator_fields
FAILED backend/tests/test_iteration_34.py::TestUserSettingsAggregatorPreferences::test_save_aggregator_preferences
FAILED backend/tests/test_iteration_34.py::TestUserSettingsAggregatorPreferences::test_toggle_aggregator_preferences
FAILED backend/tests/test_iteration_34.py::TestSettingsPersistence::test_settings_include_broadcast_language
FAILED backend/tests/test_iteration_34.py::TestSettingsPersistence::test_settings_include_voice_model
FAILED backend/tests/test_iteration_34.py::TestRegressionFeatures::test_health_endpoint
FAILED backend/tests/test_iteration_34.py::TestRegressionFeatures::test_sources_health_39_feeds
FAILED backend/tests/test_iteration_34.py::TestRegressionFeatures::test_sources_count_39
FAILED backend/tests/test_iteration_34.py::TestRegressionFeatures::test_voices_endpoint
FAILED backend/tests/test_iteration_34.py::TestRegressionFeatures::test_news_basic_endpoint
FAILED backend/tests/test_iteration_34.py::TestRegressionFeatures::test_metrics_has_aggregators
FAILED backend/tests/test_iteration_35.py::TestNewsDataBugFix::test_newsdata_endpoint_returns_200
FAILED backend/tests/test_iteration_35.py::TestNewsDataBugFix::test_newsdata_returns_articles
FAILED backend/tests/test_iteration_35.py::TestNewsDataBugFix::test_aggregator_status_shows_newsdata
FAILED backend/tests/test_iteration_35.py::TestSearchBugFix::test_search_endpoint_returns_200
FAILED backend/tests/test_iteration_35.py::TestSearchBugFix::test_search_includes_aggregator_articles
FAILED backend/tests/test_iteration_35.py::TestSearchBugFix::test_search_with_different_query
FAILED backend/tests/test_iteration_35.py::TestUserPrefsIntegration::test_guest_settings_returns_aggregator_prefs
FAILED backend/tests/test_iteration_35.py::TestUserPrefsIntegration::test_news_endpoint_accepts_aggregator_sources
FAILED backend/tests/test_iteration_35.py::TestUserPrefsIntegration::test_news_endpoint_filters_by_single_source
FAILED backend/tests/test_iteration_35.py::TestDeduplication::test_news_returns_unique_items
FAILED backend/tests/test_iteration_35.py::TestAggregatorCacheRefresh::test_aggregator_status_cache_info
FAILED backend/tests/test_iteration_35.py::TestAggregatorCacheRefresh::test_mediastack_endpoint
FAILED backend/tests/test_iteration_35.py::TestSearchFilters::test_search_with_category_filter
FAILED backend/tests/test_iteration_35.py::TestSearchFilters::test_search_pagination
FAILED backend/tests/test_iteration_35.py::TestHealthAndBasics::test_health_endpoint
FAILED backend/tests/test_iteration_35.py::TestHealthAndBasics::test_metrics_endpoint
FAILED backend/tests/test_iteration_38.py::TestSearchAggregatorIntegration::test_health_check
FAILED backend/tests/test_iteration_38.py::TestSearchAggregatorIntegration::test_search_without_filter
FAILED backend/tests/test_iteration_38.py::TestSearchAggregatorIntegration::test_search_filter_rss_only
FAILED backend/tests/test_iteration_38.py::TestSearchAggregatorIntegration::test_search_filter_aggregator_only
FAILED backend/tests/test_iteration_38.py::TestSearchAggregatorIntegration::test_search_filter_podcast_only
FAILED backend/tests/test_iteration_38.py::TestSearchAggregatorIntegration::test_search_results_have_required_fields
FAILED backend/tests/test_iteration_38.py::TestNewsEndpointWithAggregators::test_news_includes_aggregators
FAILED backend/tests/test_iteration_38.py::TestNewsEndpointWithAggregators::test_news_basic_fields
FAILED backend/tests/test_iteration_38.py::TestBriefingEndpoint::test_briefing_latest
FAILED backend/tests/test_iteration_38.py::TestBriefingEndpoint::test_briefing_history
FAILED backend/tests/test_iteration_38.py::TestVoicesEndpoint::test_get_voices
FAILED backend/tests/test_iteration_38.py::TestMetricsEndpoint::test_metrics_aggregators
FAILED backend/tests/test_iteration_38.py::TestToolsPageRoute::test_api_health
FAILED backend/tests/test_narvo_api.py::TestHealthEndpoint::test_health_status
FAILED backend/tests/test_narvo_api.py::TestNewsEndpoints::test_get_news_list
FAILED backend/tests/test_narvo_api.py::TestNewsEndpoints::test_get_news_with_region_filter
FAILED backend/tests/test_narvo_api.py::TestNewsEndpoints::test_get_news_detail
FAILED backend/tests/test_narvo_api.py::TestNewsEndpoints::test_get_news_detail_not_found
FAILED backend/tests/test_narvo_api.py::TestVoicesEndpoint::test_get_voices
FAILED backend/tests/test_narvo_api.py::TestRegionsEndpoint::test_get_regions
FAILED backend/tests/test_narvo_api.py::TestCategoriesEndpoint::test_get_categories
FAILED backend/tests/test_narvo_api.py::TestTrendingEndpoint::test_get_trending
FAILED backend/tests/test_narvo_api.py::TestMetricsEndpoint::test_get_metrics
FAILED backend/tests/test_narvo_api.py::TestBriefingEndpoints::test_generate_briefing
FAILED backend/tests/test_narvo_api.py::TestParaphraseEndpoint::test_paraphrase_text
FAILED backend/tests/test_narvo_api_v2.py::TestHealthEndpoint::test_health_status
FAILED backend/tests/test_narvo_api_v2.py::TestNewsEndpoints::test_get_news_list
FAILED backend/tests/test_narvo_api_v2.py::TestNewsEndpoints::test_get_news_with_region_filter
FAILED backend/tests/test_narvo_api_v2.py::TestNewsEndpoints::test_get_news_detail
FAILED backend/tests/test_narvo_api_v2.py::TestNewsEndpoints::test_get_news_detail_not_found
FAILED backend/tests/test_narvo_api_v2.py::TestVoicesEndpoint::test_get_voices
FAILED backend/tests/test_narvo_api_v2.py::TestRegionsEndpoint::test_get_regions
FAILED backend/tests/test_narvo_api_v2.py::TestCategoriesEndpoint::test_get_categories
FAILED backend/tests/test_narvo_api_v2.py::TestTrendingEndpoint::test_get_trending
FAILED backend/tests/test_narvo_api_v2.py::TestMetricsEndpoint::test_get_metrics
FAILED backend/tests/test_narvo_api_v2.py::TestBookmarkEndpoints::test_create_bookmark
FAILED backend/tests/test_narvo_api_v2.py::TestBookmarkEndpoints::test_get_bookmarks_for_user
FAILED backend/tests/test_narvo_api_v2.py::TestBookmarkEndpoints::test_get_bookmarks_empty_user
FAILED backend/tests/test_narvo_api_v2.py::TestBookmarkEndpoints::test_delete_bookmark
FAILED backend/tests/test_narvo_api_v2.py::TestBookmarkEndpoints::test_bookmark_replaces_existing
FAILED backend/tests/test_narvo_v8.py::TestHealthAndCore::test_health_endpoint
FAILED backend/tests/test_narvo_v8.py::TestHealthAndCore::test_metrics_endpoint
FAILED backend/tests/test_narvo_v8.py::TestHealthAndCore::test_regions_endpoint
FAILED backend/tests/test_narvo_v8.py::TestHealthAndCore::test_categories_endpoint
FAILED backend/tests/test_narvo_v8.py::TestHealthAndCore::test_trending_endpoint
FAILED backend/tests/test_narvo_v8.py::TestHealthAndCore::test_voices_endpoint
FAILED backend/tests/test_narvo_v8.py::TestNewsEndpoints::test_news_list - as...
FAILED backend/tests/test_narvo_v8.py::TestNewsEndpoints::test_news_limit_parameter
FAILED backend/tests/test_narvo_v8.py::TestNewsEndpoints::test_news_detail_valid_id
FAILED backend/tests/test_narvo_v8.py::TestNewsEndpoints::test_news_detail_invalid_id
FAILED backend/tests/test_narvo_v8.py::TestBookmarksEndpoints::test_get_empty_bookmarks
FAILED backend/tests/test_narvo_v8.py::TestBookmarksEndpoints::test_add_bookmark
FAILED backend/tests/test_narvo_v8.py::TestBookmarksEndpoints::test_get_bookmarks_after_add
FAILED backend/tests/test_narvo_v8.py::TestBookmarksEndpoints::test_delete_bookmark
FAILED backend/tests/test_narvo_v8.py::TestPreferencesEndpoints::test_get_default_preferences
FAILED backend/tests/test_narvo_v8.py::TestPreferencesEndpoints::test_save_preferences
FAILED backend/tests/test_narvo_v8.py::TestPreferencesEndpoints::test_get_saved_preferences
FAILED backend/tests/test_narvo_v8.py::TestPreferencesEndpoints::test_update_preferences
FAILED backend/tests/test_persistence_v7.py::TestHealthEndpoints::test_health_endpoint
FAILED backend/tests/test_persistence_v7.py::TestHealthEndpoints::test_news_endpoint
FAILED backend/tests/test_persistence_v7.py::TestHealthEndpoints::test_voices_endpoint
FAILED backend/tests/test_persistence_v7.py::TestBookmarksPersistence::test_bookmarks_empty_for_new_user
FAILED backend/tests/test_persistence_v7.py::TestBookmarksPersistence::test_create_bookmark
FAILED backend/tests/test_persistence_v7.py::TestBookmarksPersistence::test_get_bookmarks_returns_created
FAILED backend/tests/test_persistence_v7.py::TestBookmarksPersistence::test_delete_bookmark
FAILED backend/tests/test_persistence_v7.py::TestBookmarksPersistence::test_bookmark_upsert_behavior
FAILED backend/tests/test_persistence_v7.py::TestUserPreferencesPersistence::test_preferences_default_for_unknown_user
FAILED backend/tests/test_persistence_v7.py::TestUserPreferencesPersistence::test_save_preferences
FAILED backend/tests/test_persistence_v7.py::TestUserPreferencesPersistence::test_get_saved_preferences
FAILED backend/tests/test_persistence_v7.py::TestUserPreferencesPersistence::test_preferences_update
FAILED backend/tests/test_persistence_v7.py::TestAdditionalAPIs::test_regions_endpoint
FAILED backend/tests/test_persistence_v7.py::TestAdditionalAPIs::test_categories_endpoint
FAILED backend/tests/test_persistence_v7.py::TestAdditionalAPIs::test_trending_endpoint
FAILED backend/tests/test_persistence_v7.py::TestAdditionalAPIs::test_metrics_endpoint
FAILED backend/tests/test_persistence_v7.py::TestNewsDetail::test_news_detail_404_for_invalid_id
FAILED backend/tests/test_persistence_v7.py::TestNewsDetail::test_news_detail_for_valid_id
FAILED backend/tests/test_services.py::TestContentSources::test_sources_returns_total
FAILED backend/tests/test_services.py::TestContentSources::test_sources_has_regions
FAILED backend/tests/test_services.py::TestContentSources::test_sources_has_categories
FAILED backend/tests/test_services.py::TestContentSources::test_sources_lists_individual
FAILED backend/tests/test_services.py::TestContentSources::test_sources_no_dubawa
FAILED backend/tests/test_services.py::TestContentSources::test_sources_has_aggregators
FAILED backend/tests/test_services.py::TestNewsEndpoint::test_news_returns_list
FAILED backend/tests/test_services.py::TestNewsEndpoint::test_news_search - h...
FAILED backend/tests/test_services.py::TestSettings::test_save_settings - htt...
FAILED backend/tests/test_services.py::TestSettings::test_fetch_settings_reflects_save
FAILED backend/tests/test_services.py::TestSettings::test_settings_merge_preserves_fields
FAILED backend/tests/test_services.py::TestSettings::test_default_settings_for_unknown_user
FAILED backend/tests/test_services.py::TestTranslation::test_languages_list
FAILED backend/tests/test_services.py::TestTranslation::test_quick_translate
FAILED backend/tests/test_services.py::TestFactCheck::test_factcheck_search
FAILED backend/tests/test_services.py::TestFactCheck::test_factcheck_verify
FAILED backend/tests/test_services.py::TestMetrics::test_metrics_includes_total_sources
FAILED backend/tests/test_services.py::TestMetrics::test_metrics_includes_local_and_international
FAILED backend/tests/test_services.py::TestHealth::test_health_endpoint - htt...
FAILED backend/tests/test_services_v2.py::TestMetricsEndpoint::test_metrics_returns_real_data
FAILED backend/tests/test_services_v2.py::TestMetricsEndpoint::test_system_alerts
FAILED backend/tests/test_services_v2.py::TestFactcheckEndpoint::test_factcheck_returns_real_status
FAILED backend/tests/test_services_v2.py::TestFactcheckEndpoint::test_factcheck_different_stories_vary
FAILED backend/tests/test_services_v2.py::TestPodcastEndpoints::test_podcasts_list
FAILED backend/tests/test_services_v2.py::TestPodcastEndpoints::test_podcast_categories
FAILED backend/tests/test_services_v2.py::TestPodcastEndpoints::test_podcast_search
FAILED backend/tests/test_services_v2.py::TestListeningHistory::test_add_and_get_history
FAILED backend/tests/test_services_v2.py::TestTTSCaching::test_tts_caching_returns_same_result
FAILED backend/tests/test_services_v2.py::TestSettingsPersistence::test_save_and_read_settings
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_get_supported_languages
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_get_specific_language
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_get_invalid_language
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_quick_translate_to_pidgin
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_quick_translate_to_yoruba
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_quick_translate_to_hausa
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_quick_translate_to_igbo
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_translate_text_post
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_translate_narrate_endpoint
FAILED backend/tests/test_translation_factcheck.py::TestTranslationAPI::test_translate_invalid_language
FAILED backend/tests/test_translation_factcheck.py::TestFactCheckAPI::test_factcheck_search
FAILED backend/tests/test_translation_factcheck.py::TestFactCheckAPI::test_factcheck_verify
FAILED backend/tests/test_translation_factcheck.py::TestFactCheckAPI::test_factcheck_story
FAILED backend/tests/test_translation_factcheck.py::TestFactCheckAPI::test_factcheck_analyze
FAILED backend/tests/test_translation_factcheck.py::TestFactCheckAPI::test_factcheck_search_with_language
FAILED backend/tests/test_translation_factcheck.py::TestFactCheckAPI::test_factcheck_search_min_query_length
FAILED backend/tests/test_translation_factcheck.py::TestHealthAndIntegration::test_health_endpoint
FAILED backend/tests/test_tts_podcast_aggregator.py::TestTTS::test_tts_generate_returns_audio
FAILED backend/tests/test_tts_podcast_aggregator.py::TestTTS::test_tts_voice_mapping_english_male
FAILED backend/tests/test_tts_podcast_aggregator.py::TestTTS::test_tts_voice_mapping_yoruba_female
FAILED backend/tests/test_tts_podcast_aggregator.py::TestTTS::test_tts_with_translation_pidgin
FAILED backend/tests/test_tts_podcast_aggregator.py::TestTTS::test_tts_voices_list
FAILED backend/tests/test_tts_podcast_aggregator.py::TestPodcast::test_podcasts_list
FAILED backend/tests/test_tts_podcast_aggregator.py::TestPodcast::test_podcasts_list_main_endpoint
FAILED backend/tests/test_tts_podcast_aggregator.py::TestAggregators::test_aggregator_status
FAILED backend/tests/test_tts_podcast_aggregator.py::TestAggregators::test_fetch_mediastack
FAILED backend/tests/test_tts_podcast_aggregator.py::TestAggregators::test_fetch_newsdata
FAILED backend/tests/test_tts_podcast_aggregator.py::TestAggregators::test_fetch_all_aggregators
FAILED backend/tests/test_tts_podcast_aggregator.py::TestAggregators::test_mediastack_article_structure
FAILED backend/tests/test_tts_podcast_aggregator.py::TestAggregators::test_newsdata_article_structure
FAILED backend/tests/test_tts_podcast_aggregator.py::TestHealthRegression::test_health_endpoint
FAILED backend/tests/test_tts_podcast_aggregator.py::TestHealthRegression::test_sources_health
FAILED backend/tests/test_tts_podcast_aggregator.py::TestHealthRegression::test_sources_count
FAILED backend/tests/test_user_profile_radio.py::TestHealthAndMetrics::test_health_endpoint
FAILED backend/tests/test_user_profile_radio.py::TestHealthAndMetrics::test_metrics_endpoint
FAILED backend/tests/test_user_profile_radio.py::TestVoiceStudioAPI::test_voices_endpoint
FAILED backend/tests/test_user_profile_radio.py::TestRadioIntegration::test_radio_countries_endpoint
FAILED backend/tests/test_user_profile_radio.py::TestRadioIntegration::test_radio_stations_nigeria
FAILED backend/tests/test_user_profile_radio.py::TestRadioIntegration::test_radio_stations_ghana
FAILED backend/tests/test_user_profile_radio.py::TestRadioIntegration::test_radio_stations_south_africa
FAILED backend/tests/test_user_profile_radio.py::TestRadioIntegration::test_radio_stations_default
FAILED backend/tests/test_user_profile_radio.py::TestNewsAPI::test_news_endpoint
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_translate_languages_endpoint_returns_200
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_translate_languages_returns_list
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_translate_languages_has_gender_field
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_english_voice_is_onyx_male
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_pidgin_voice_is_echo_male
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_yoruba_voice_is_nova_female
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_hausa_voice_is_shimmer_female
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_igbo_voice_is_alloy_female
FAILED backend/tests/test_voice_mapping_v31.py::TestVoiceGenderMapping::test_all_voice_mappings_complete
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_voices_endpoint_returns_200
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_voices_returns_list
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_voices_have_gender_field
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_voices_have_nigerian_names
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_onyx_voice_is_male
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_echo_voice_is_male
FAILED backend/tests/test_voice_mapping_v31.py::TestVoicesEndpoint::test_female_voices
FAILED backend/tests/test_voice_mapping_v31.py::TestHealthCheckPeriodic::test_sources_health_returns_200
FAILED backend/tests/test_voice_mapping_v31.py::TestHealthCheckPeriodic::test_sources_health_has_sources_array
FAILED backend/tests/test_voice_mapping_v31.py::TestHealthCheckPeriodic::test_sources_health_has_last_checked
FAILED backend/tests/test_voice_mapping_v31.py::TestHealthCheckPeriodic::test_sources_health_summary_counts
FAILED backend/tests/test_voice_mapping_v31.py::TestHealthCheckPeriodic::test_sources_health_refresh_still_works
FAILED backend/tests/test_voice_mapping_v31.py::TestHealthCheckPeriodic::test_health_data_non_null_after_refresh
FAILED backend/tests/test_voice_mapping_v31.py::TestRegressionPreviousFeatures::test_api_sources_returns_39_feeds
FAILED backend/tests/test_voice_mapping_v31.py::TestRegressionPreviousFeatures::test_api_sources_3_regions
FAILED backend/tests/test_voice_mapping_v31.py::TestRegressionPreviousFeatures::test_api_health_status
======================== 430 failed in 94.36s (0:01:34) ======================== tests for the new services: , , and . The test file for  has been started but can be expanded.
-   **P2: Additional Podcast Sourcing:** The current implementation uses a few hardcoded RSS feeds. The next step is to allow for dynamic addition or discovery of more podcast sources.

**Future Tasks:**
-   Daily digest via email notifications.
-   Implement a native mobile application.
-   Allow users to provide their own API keys for third-party services.

**Completed work in this session**
- **Core Feature Integration:**
  - Integrated real podcast data via RSS feeds () and updated the Discover page with search, categories, and detail views.
  - Implemented a Listening History feature with a backend endpoint and a dedicated frontend page.
  - Replaced all mock/hardcoded data ( stats, fact-check source) with real data from the backend.
  - Began integration of YarnGPT as the primary TTS service.
- **Settings & UI Refinement:**
  - Implemented a persistent settings system for all settings pages, using  for speed and syncing with MongoDB.
  - Redesigned the  page to merge voice selection and language into a unified UI.
  - Redesigned the  page for better mobile responsiveness.
  - Made voice previews on the  page auto-play on selection.
- **Bug Fixes & UX Improvements:**
  - Fixed the  page layout to correctly inherit the main .
  - Implemented clickable hashtags across the app using a reusable  component.
  - Fixed mobile UI overflow issues on  and  pages.
  - Removed the non-functional Push Notifications toggle from the settings page.
  - Corrected the fact-checker source display, removing the hardcoded DUBAWA AI.
- **Performance & Accessibility:**
  - Implemented server-side TTS caching and a frontend audio pre-fetch hook to improve audio loading times.
  - Completed a full accessibility overhaul, adding focus styles, a skip to content link, and reduced motion queries based on the user's design system.

**Earlier issues found/mentioned but not fixed**
- The news detail autoplay functionality has been a persistent issue across multiple implementation attempts and remains unresolved to the user's satisfaction.

**Known issue recurrence from previous fork**
- **Mobile UI/UX Parity:** While many specific mobile issues were fixed, ensuring perfect parity between desktop and mobile remains an ongoing effort.
- **Autoplay Functionality:** This has become the most prominent recurring issue in the current session, with multiple fixes attempted but the core problem of speed and reliability persisting.

**Code Architecture**


**Key Technical Concepts**
- **Frameworks:** FastAPI, React
- **Database:** MongoDB
- **Authentication:** Supabase (Email/Password + Google OAuth)
- **Styling:** Tailwind CSS, Shadcn UI
- **State Management:** React Context, React Hooks
- **AI/ML:**
  - **TTS:** YarnGPT (primary), OpenAI (fallback)
  - **Text Gen:** Google Gemini
- **Data Parsing:**  for RSS feeds
- **Async HTTP:**  for backend services

**key DB schema**
  - **users:** (Implicit schema from Supabase)
  - **user_settings:**  (Expanded to be more comprehensive)
  - **listening_history:**  (New collection)
  - **tts_cache:**  (New collection for caching)

**changes in tech stack**
- **YarnGPT:** Added as the primary TTS provider.
- **feedparser:** Added for parsing podcast RSS feeds.
- **httpx:** Added for making async HTTP requests in the backend.

**All files of reference**
- **New Files Created:**
  - 
  - 
  - 
  - 
  - 
  - 
  - 
  - 
- **Heavily Modified Files:**
  -  (TTS routing, new endpoints)
  -  (TTS caching)
  -  (RSS integration)
  -  (Real data logic)
  -  (Autoplay logic)
  -  (Sound themes UI)
  -  (Voice list, auto-play)
  -  (Real data, mobile UI)
  -  (Podcast search/filter UI)
  -  (History tracking)
  -  (History page routing)

**Critical Info for New Agent**
- **YarnGPT API Key:** A new key, , has been added to . This is critical for the primary TTS functionality.
- **In-Progress Feature Batch:** You are resuming mid-way through a large batch of work (YarnGPT, Push Notifications, Sound Themes, Autoplay fix). Do not start new tasks until this batch is complete and tested. Your first priority is to finish the  component and the  sound theme UI.
- **Recurring Autoplay Bug:** The user is sensitive to the autoplay feature on the news detail page. The latest fix attempt involves pre-generating the audio on page load. You must verify if this approach works and be prepared to debug it further. This is a top-priority bug.
- **Route Order Matters:** The project has multiple routers (, ). When adding new endpoints, be mindful of route registration order, especially with parameterized paths (e.g., ) vs. static paths (e.g., ). Static paths must be registered *before* parameterized ones to avoid being incorrectly captured.

**documents and test reports created in this job**
-  (Updated)
-  (Updated)
-  (Updated)
-  (Multiple reports from testing agent runs)

**Last 10 User Messages and any pending HUMAN messages** 
1.  **User:** Provided YarnGPT API key and confirmed to implement push notifications but skip email for now. (Status: **In Progress**)
2.  **User:** Presented a new list of urgent issues and features: voice cards mismatch, autoplay still not working,  page layout is broken, implement YarnGPT, add push notifications & sound themes. (Status: **In Progress**)
3.  **User:** Marked a large batch of fixes and features as complete, including real data integration and the new Listening History feature. Provided the next set of tasks. (Status: **Completed**)
4.  **User:** Approved the agent's plan to implement fixes (Account page, Voices page UI) and new features (persistent settings, audio optimization, podcasts, hashtags). (Status: **Completed**)
5.  **User:** Provided feedback on the first batch of fixes, noting the Account page is still truncated, and requested the  to be open by default. Confirmed the next set of features to implement. (Status: **Completed**)
6.  **User:** Confirmed the next steps after the agent's initial large batch of fixes. (This message seems to be a simple proceed confirmation). (Status: **Completed**)
7.  **User:** Uploaded the new  and clarified that persistent settings should use MongoDB + localStorage. (Status: **Completed**)
8.  **User:** (from previous session) Provided the comprehensive list of fixes and features that kicked off the current session's work. (Status: **Completed**)
9.  **User:** (from previous session) Confirmed documentation was correct. (Status: **Completed**)
10. **User:** (from previous session) Reported the Google OAuth redirect error. (Status: **Completed**)

**Project Health Check:**
- **Broken:**
  - News detail page autoplay is unreliable and slow.
  - Voice/language mapping on the  page is incorrect.
- **Mocked:**
  - None. Major mock data sources (fact-checking, podcasts) have been replaced with real data.
- **Untested:**
  - The entire in-progress feature batch: YarnGPT integration, push notifications, and broadcast sound themes.

**3rd Party Integrations**
- **Supabase:** Authentication (Email/Password, Google OAuth).
- **MongoDB:** Primary database.
- **Emergent LLM Key Integrations:**
    - Google Gemini (Narrative Generation)
- **User-Provided Key Integrations:**
    - **YarnGPT:** Primary Text-to-Speech (requires  from ).
    - **OpenAI TTS:** Fallback Text-to-Speech.
- **News APIs:** Mediastack, NewsData.io.
- **Data Parsers:**
    - **feedparser:** For parsing podcast RSS feeds.
- **Other Frontend Libraries:** , , , .

**Testing status**
  - Testing agent used after significant changes: YES (used multiple times after large batches).
  - Troubleshoot agent used after agent stuck in loop: NO
  - Test files created: Yes,  was created.
  - Known regressions: The autoplay feature can be considered a regression as it's a recurring issue that is still not resolved to user satisfaction.

**Credentials to test flow:**
Use the Guest Mode ([Oya, Play]) from the landing page. The YarnGPT API key is configured in the environment.

**What agent forgot to execute**
The agent has not forgotten anything but is in the middle of a large, multi-part implementation. The tasks for push notifications and sound themes are incomplete and need to be finished before testing and final delivery.</analysis>
