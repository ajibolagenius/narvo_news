{"version":3,"file":"static/js/68.ef146056.chunk.js","mappings":"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","sources":["../node_modules/automation-events/build/es5/bundle.js","../node_modules/@babel/runtime/helpers/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/@babel/runtime/helpers/createClass.js","../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/nonIterableRest.js","../node_modules/@babel/runtime/helpers/slicedToArray.js","../node_modules/@babel/runtime/helpers/toPrimitive.js","../node_modules/@babel/runtime/helpers/toPropertyKey.js","../node_modules/@babel/runtime/helpers/typeof.js","../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","../node_modules/tone/Tone/version.ts","../node_modules/standardized-audio-context/src/factories/abort-error.ts","../node_modules/standardized-audio-context/src/globals.ts","../node_modules/standardized-audio-context/src/helpers/is-constructible.ts","../node_modules/standardized-audio-context/src/helpers/split-import-statements.ts","../node_modules/standardized-audio-context/src/factories/add-audio-worklet-module.ts","../node_modules/standardized-audio-context/src/helpers/get-value-for-key.ts","../node_modules/standardized-audio-context/src/helpers/pick-element-from-set.ts","../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/get-event-listeners-of-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-active.ts","../node_modules/standardized-audio-context/src/guards/audio-worklet-node.ts","../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive.ts","../node_modules/standardized-audio-context/src/helpers/set-internal-state-to-passive-when-necessary.ts","../node_modules/standardized-audio-context/src/factories/analyser-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/is-owned-by-context.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.ts","../node_modules/standardized-audio-context/src/factories/index-size-error.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-get-channel-data-method.ts","../node_modules/standardized-audio-context/src/factories/audio-buffer-constructor.ts","../node_modules/standardized-audio-context/src/constants.ts","../node_modules/standardized-audio-context/src/helpers/is-active-audio-node.ts","../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/get-audio-node-connections.ts","../node_modules/standardized-audio-context/src/helpers/get-audio-param-connections.ts","../node_modules/standardized-audio-context/src/helpers/deactivate-active-audio-node-input-connections.ts","../node_modules/standardized-audio-context/src/guards/audio-buffer-source-node.ts","../node_modules/standardized-audio-context/src/guards/biquad-filter-node.ts","../node_modules/standardized-audio-context/src/guards/constant-source-node.ts","../node_modules/standardized-audio-context/src/guards/gain-node.ts","../node_modules/standardized-audio-context/src/guards/oscillator-node.ts","../node_modules/standardized-audio-context/src/guards/stereo-panner-node.ts","../node_modules/standardized-audio-context/src/helpers/deactivate-audio-graph.ts","../node_modules/standardized-audio-context/src/helpers/is-valid-latency-hint.ts","../node_modules/standardized-audio-context/src/guards/audio-node.ts","../node_modules/standardized-audio-context/src/guards/audio-node-output-connection.ts","../node_modules/standardized-audio-context/src/helpers/insert-element-in-set.ts","../node_modules/standardized-audio-context/src/helpers/add-active-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/helpers/add-passive-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/guards/native-audio-node-faker.ts","../node_modules/standardized-audio-context/src/helpers/connect-native-audio-node-to-native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection.ts","../node_modules/standardized-audio-context/src/helpers/delete-event-listeners-of-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/helpers/disconnect-native-audio-node-from-native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/get-native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/get-native-audio-param.ts","../node_modules/standardized-audio-context/src/helpers/is-part-of-a-cycle.ts","../node_modules/standardized-audio-context/src/helpers/is-passive-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-node-disconnect-method-support.ts","../node_modules/standardized-audio-context/src/helpers/visit-each-audio-node-once.ts","../node_modules/standardized-audio-context/src/guards/native-audio-node.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-node-disconnect-method.ts","../node_modules/standardized-audio-context/src/factories/audio-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/delete-active-input-connection-to-audio-param.ts","../node_modules/standardized-audio-context/src/read-only-map.ts","../node_modules/standardized-audio-context/src/factories/audio-worklet-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/copy-from-channel.ts","../node_modules/standardized-audio-context/src/helpers/copy-to-channel.ts","../node_modules/standardized-audio-context/src/helpers/create-nested-arrays.ts","../node_modules/standardized-audio-context/src/factories/audio-worklet-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/helpers/get-audio-worklet-processor.ts","../node_modules/standardized-audio-context/src/factories/biquad-filter-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/channel-merger-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/channel-splitter-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/constant-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/convolver-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/detach-array-buffer.ts","../node_modules/standardized-audio-context/src/factories/delay-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/disconnect-multiple-outputs.ts","../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/gain-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/invalid-state-error.ts","../node_modules/standardized-audio-context/src/factories/invalid-access-error.ts","../node_modules/standardized-audio-context/src/factories/iir-filter-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/filter-buffer.ts","../node_modules/standardized-audio-context/src/factories/media-stream-audio-destination-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/test-promise-support.ts","../node_modules/standardized-audio-context/src/factories/minimal-offline-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-option.ts","../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-options.ts","../node_modules/standardized-audio-context/src/helpers/test-analyser-node-get-float-time-domain-data-method-support.ts","../node_modules/standardized-audio-context/src/helpers/assign-native-audio-node-audio-param-value.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.ts","../node_modules/standardized-audio-context/src/helpers/compute-buffer-size.ts","../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor-promise.ts","../node_modules/standardized-audio-context/src/helpers/clone-audio-worklet-node-options.ts","../node_modules/standardized-audio-context/src/factories/native-biquad-filter-node.ts","../node_modules/standardized-audio-context/src/factories/native-channel-splitter-node.ts","../node_modules/standardized-audio-context/src/helpers/wrap-channel-splitter-node.ts","../node_modules/standardized-audio-context/src/helpers/intercept-connections.ts","../node_modules/standardized-audio-context/src/factories/native-delay-node.ts","../node_modules/standardized-audio-context/src/factories/native-gain-node.ts","../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-script-processor-node.ts","../node_modules/standardized-audio-context/src/factories/not-supported-error.ts","../node_modules/standardized-audio-context/src/factories/offline-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/oscillator-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/panner-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/periodic-wave-constructor.ts","../node_modules/standardized-audio-context/src/factories/stereo-panner-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/unknown-error.ts","../node_modules/standardized-audio-context/src/factories/wave-shaper-node-constructor.ts","../node_modules/standardized-audio-context/src/helpers/get-first-sample.ts","../node_modules/standardized-audio-context/src/helpers/is-dc-curve.ts","../node_modules/standardized-audio-context/src/helpers/overwrite-accessors.ts","../node_modules/standardized-audio-context/src/helpers/set-value-at-time-until-possible.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.ts","../node_modules/standardized-audio-context/src/helpers/test-dom-exception-constructor-support.ts","../node_modules/standardized-audio-context/src/helpers/test-transferables-support.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts","../node_modules/standardized-audio-context/src/helpers/wrap-event-listener.ts","../node_modules/standardized-audio-context/src/module.ts","../node_modules/standardized-audio-context/src/factories/add-active-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/add-passive-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/delete-active-input-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/get-audio-node-tail-time.ts","../node_modules/standardized-audio-context/src/factories/cache-test-result.ts","../node_modules/standardized-audio-context/src/factories/window.ts","../node_modules/standardized-audio-context/src/factories/native-analyser-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/wrap-analyser-node-get-float-time-domain-data-method.ts","../node_modules/standardized-audio-context/src/factories/get-audio-node-renderer.ts","../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-node.ts","../node_modules/standardized-audio-context/src/factories/analyser-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/get-native-context.ts","../node_modules/standardized-audio-context/src/factories/native-offline-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/is-native-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/event-target-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/is-native-audio-context.ts","../node_modules/standardized-audio-context/src/factories/is-native-audio-node.ts","../node_modules/standardized-audio-context/src/factories/is-native-audio-param.ts","../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/add-audio-node-connections.ts","../node_modules/standardized-audio-context/src/factories/add-connection-to-audio-node.ts","../node_modules/standardized-audio-context/src/factories/increment-cycle-counter-factory.ts","../node_modules/standardized-audio-context/src/factories/decrement-cycle-counter.ts","../node_modules/standardized-audio-context/src/factories/detect-cycles.ts","../node_modules/standardized-audio-context/src/guards/delay-node.ts","../node_modules/standardized-audio-context/src/factories/native-audio-buffer-constructor.ts","../node_modules/standardized-audio-context/src/factories/convert-number-to-unsigned-long.ts","../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods.ts","../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts","../node_modules/standardized-audio-context/src/factories/test-audio-buffer-constructor-support.ts","../node_modules/standardized-audio-context/src/factories/add-silent-connection.ts","../node_modules/standardized-audio-context/src/factories/render-inputs-of-audio-param.ts","../node_modules/standardized-audio-context/src/factories/connect-audio-param.ts","../node_modules/standardized-audio-context/src/factories/native-audio-buffer-source-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.ts","../node_modules/standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.ts","../node_modules/standardized-audio-context/src/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.ts","../node_modules/standardized-audio-context/src/factories/render-automation.ts","../node_modules/standardized-audio-context/src/factories/get-audio-param-renderer.ts","../node_modules/standardized-audio-context/src/factories/audio-buffer-source-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/audio-param-factory.ts","../node_modules/standardized-audio-context/src/factories/add-audio-param-connections.ts","../node_modules/standardized-audio-context/src/factories/audio-param-renderer.ts","../node_modules/standardized-audio-context/src/factories/audio-destination-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/audio-destination-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-audio-destination-node.ts","../node_modules/standardized-audio-context/src/factories/biquad-filter-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/set-audio-node-tail-time.ts","../node_modules/standardized-audio-context/src/factories/monitor-connections.ts","../node_modules/standardized-audio-context/src/factories/wrap-channel-merger-node.ts","../node_modules/standardized-audio-context/src/factories/native-channel-merger-node-factory.ts","../node_modules/standardized-audio-context/src/factories/channel-merger-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/channel-splitter-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/helpers/sanitize-channel-splitter-options.ts","../node_modules/standardized-audio-context/src/factories/native-constant-source-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-constant-source-node-factory.ts","../node_modules/standardized-audio-context/src/factories/constant-source-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-convolver-node-factory.ts","../node_modules/standardized-audio-context/src/factories/convolver-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/delay-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-dynamics-compressor-node-factory.ts","../node_modules/standardized-audio-context/src/factories/dynamics-compressor-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/gain-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/render-native-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/test-offline-audio-context-current-time-support.ts","../node_modules/standardized-audio-context/src/factories/iir-filter-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-iir-filter-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/wrap-iir-filter-node-get-frequency-response-method.ts","../node_modules/standardized-audio-context/src/factories/audio-listener-factory.ts","../node_modules/standardized-audio-context/src/factories/minimal-base-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-oscillator-node-factory.ts","../node_modules/standardized-audio-context/src/factories/oscillator-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/connected-native-audio-buffer-source-node-factory.ts","../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-wave-shaper-node-factory.ts","../node_modules/standardized-audio-context/src/factories/native-panner-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-panner-node-factory.ts","../node_modules/standardized-audio-context/src/factories/panner-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/native-periodic-wave-factory.ts","../node_modules/standardized-audio-context/src/helpers/sanitize-periodic-wave-options.ts","../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-faker-factory.ts","../node_modules/standardized-audio-context/src/factories/native-stereo-panner-node-factory.ts","../node_modules/standardized-audio-context/src/factories/stereo-panner-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/wave-shaper-node-renderer-factory.ts","../node_modules/standardized-audio-context/src/factories/is-secure-context.ts","../node_modules/standardized-audio-context/src/factories/expose-current-frame-and-current-time.ts","../node_modules/standardized-audio-context/src/factories/get-or-create-backup-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/evaluate-source.ts","../node_modules/standardized-audio-context/src/factories/fetch-source.ts","../node_modules/standardized-audio-context/src/factories/test-audio-worklet-processor-post-message-support.ts","../node_modules/standardized-audio-context/src/factories/is-native-context.ts","../node_modules/standardized-audio-context/src/factories/decode-audio-data.ts","../node_modules/standardized-audio-context/src/factories/data-clone-error.ts","../node_modules/standardized-audio-context/src/factories/encoding-error.ts","../node_modules/standardized-audio-context/src/factories/base-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/media-element-audio-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-media-element-audio-source-node.ts","../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-destination-node.ts","../node_modules/standardized-audio-context/src/factories/media-stream-audio-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/native-media-stream-audio-source-node.ts","../node_modules/standardized-audio-context/src/factories/native-media-stream-track-audio-source-node-factory.ts","../node_modules/standardized-audio-context/src/factories/media-stream-track-audio-source-node-constructor.ts","../node_modules/standardized-audio-context/src/factories/audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/get-unrendered-audio-worklet-nodes.ts","../node_modules/standardized-audio-context/src/factories/add-unrendered-audio-worklet-node.ts","../node_modules/standardized-audio-context/src/factories/connect-multiple-outputs.ts","../node_modules/standardized-audio-context/src/factories/delete-unrendered-audio-worklet-node.ts","../node_modules/standardized-audio-context/src/factories/get-active-audio-worklet-node-inputs.ts","../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-faker-factory.ts","../node_modules/standardized-audio-context/src/helpers/create-audio-worklet-processor.ts","../node_modules/standardized-audio-context/src/factories/native-audio-worklet-node-factory.ts","../node_modules/standardized-audio-context/src/helpers/test-clonability-of-audio-worklet-node-options.ts","../node_modules/standardized-audio-context/src/factories/get-backup-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/set-active-audio-worklet-node-inputs.ts","../node_modules/standardized-audio-context/src/helpers/sanitize-audio-worklet-node-options.ts","../node_modules/standardized-audio-context/src/helpers/test-audio-worklet-node-options-clonability.ts","../node_modules/standardized-audio-context/src/factories/minimal-audio-context-constructor.ts","../node_modules/standardized-audio-context/src/factories/create-native-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/start-rendering.ts","../node_modules/standardized-audio-context/src/factories/is-any-audio-context.ts","../node_modules/standardized-audio-context/src/factories/is-any-audio-node.ts","../node_modules/standardized-audio-context/src/factories/is-any-audio-param.ts","../node_modules/standardized-audio-context/src/factories/is-any-offline-audio-context.ts","../node_modules/standardized-audio-context/src/factories/is-supported-promise.ts","../node_modules/standardized-audio-context/src/factories/test-audio-buffer-copy-channel-methods-subarray-support.ts","../node_modules/standardized-audio-context/src/factories/test-audio-context-close-method-support.ts","../node_modules/standardized-audio-context/src/factories/test-audio-context-decode-audio-data-method-type-error-support.ts","../node_modules/standardized-audio-context/src/factories/test-audio-context-options-support.ts","../node_modules/standardized-audio-context/src/factories/test-audio-node-connect-method-support.ts","../node_modules/standardized-audio-context/src/factories/test-audio-worklet-processor-no-outputs-support.ts","../node_modules/standardized-audio-context/src/factories/test-channel-merger-node-channel-count-support.ts","../node_modules/standardized-audio-context/src/factories/test-constant-source-node-accurate-scheduling-support.ts","../node_modules/standardized-audio-context/src/factories/test-convolver-node-buffer-reassignability-support.ts","../node_modules/standardized-audio-context/src/factories/test-convolver-node-channel-count-support.ts","../node_modules/standardized-audio-context/src/factories/test-is-secure-context-support.ts","../node_modules/standardized-audio-context/src/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.ts","../node_modules/standardized-audio-context/src/factories/test-stereo-panner-node-default-value-support.ts","../node_modules/tone/Tone/core/util/TypeCheck.ts","../node_modules/tone/Tone/core/util/Debug.ts","../node_modules/tone/Tone/core/context/AudioContext.ts","../node_modules/tone/Tone/core/clock/Ticker.ts","../node_modules/tone/Tone/core/util/AdvancedTypeCheck.ts","../node_modules/tone/Tone/core/util/Defaults.ts","../node_modules/tone/Tone/core/Tone.ts","../node_modules/tone/Tone/core/util/Math.ts","../node_modules/tone/Tone/core/util/Timeline.ts","../node_modules/tone/Tone/core/context/ContextInitialization.ts","../node_modules/tone/Tone/core/util/Emitter.ts","../node_modules/tone/Tone/core/context/BaseContext.ts","../node_modules/tone/Tone/core/context/Context.ts","../node_modules/tone/Tone/core/util/Interface.ts","../node_modules/tone/Tone/core/context/ToneAudioBuffer.ts","../node_modules/tone/Tone/core/context/OfflineContext.ts","../node_modules/tone/Tone/core/Global.ts","../node_modules/tone/Tone/core/context/DummyContext.ts","../node_modules/tone/Tone/core/type/Conversions.ts","../node_modules/tone/Tone/core/type/TimeBase.ts","../node_modules/tone/Tone/core/type/Time.ts","../node_modules/tone/Tone/core/type/Frequency.ts","../node_modules/tone/Tone/core/type/TransportTime.ts","../node_modules/tone/Tone/core/context/ToneWithContext.ts","../node_modules/tone/Tone/core/util/StateTimeline.ts","../node_modules/tone/Tone/core/context/Param.ts","../node_modules/tone/Tone/core/context/ToneAudioNode.ts","../node_modules/tone/Tone/core/context/Gain.ts","../node_modules/tone/Tone/source/OneShotSource.ts","../node_modules/tone/Tone/signal/ToneConstantSource.ts","../node_modules/tone/Tone/signal/Signal.ts","../node_modules/tone/Tone/core/clock/TickParam.ts","../node_modules/tone/Tone/core/clock/TickSignal.ts","../node_modules/tone/Tone/core/clock/TickSource.ts","../node_modules/tone/Tone/core/clock/Clock.ts","../node_modules/tone/Tone/core/context/Delay.ts","../node_modules/tone/Tone/component/channel/Volume.ts","../node_modules/tone/Tone/core/context/Destination.ts","../node_modules/tone/Tone/core/context/Listener.ts","../node_modules/tone/Tone/core/context/Offline.ts","../node_modules/tone/Tone/core/context/ToneAudioBuffers.ts","../node_modules/tone/Tone/core/type/Midi.ts","../node_modules/tone/Tone/core/type/Ticks.ts","../node_modules/tone/Tone/core/util/Draw.ts","../node_modules/tone/Tone/core/util/IntervalTimeline.ts","../node_modules/tone/Tone/core/util/TimelineValue.ts","../node_modules/tone/Tone/signal/SignalOperator.ts","../node_modules/tone/Tone/signal/WaveShaper.ts","../node_modules/tone/Tone/signal/Pow.ts","../node_modules/tone/Tone/core/clock/TransportEvent.ts","../node_modules/tone/Tone/core/clock/TransportRepeatEvent.ts","../node_modules/tone/Tone/core/clock/Transport.ts","../node_modules/tone/Tone/source/Source.ts","../node_modules/tone/Tone/source/buffer/ToneBufferSource.ts","../node_modules/tone/Tone/source/Noise.ts","../node_modules/tone/Tone/source/UserMedia.ts","../node_modules/tone/Tone/source/oscillator/OscillatorInterface.ts","../node_modules/tone/Tone/source/oscillator/ToneOscillatorNode.ts","../node_modules/tone/Tone/source/oscillator/Oscillator.ts","../node_modules/tone/Tone/signal/AudioToGain.ts","../node_modules/tone/Tone/signal/Multiply.ts","../node_modules/tone/Tone/source/oscillator/AMOscillator.ts","../node_modules/tone/Tone/source/oscillator/FMOscillator.ts","../node_modules/tone/Tone/source/oscillator/PulseOscillator.ts","../node_modules/tone/Tone/source/oscillator/FatOscillator.ts","../node_modules/tone/Tone/source/oscillator/PWMOscillator.ts","../node_modules/tone/Tone/source/oscillator/OmniOscillator.ts","../node_modules/tone/Tone/signal/Add.ts","../node_modules/tone/Tone/signal/Scale.ts","../node_modules/tone/Tone/signal/Zero.ts","../node_modules/tone/Tone/source/oscillator/LFO.ts","../node_modules/tone/Tone/core/util/Decorator.ts","../node_modules/tone/Tone/source/buffer/Player.ts","../node_modules/tone/Tone/source/buffer/Players.ts","../node_modules/tone/Tone/source/buffer/GrainPlayer.ts","../node_modules/tone/Tone/signal/Abs.ts","../node_modules/tone/Tone/signal/GainToAudio.ts","../node_modules/tone/Tone/signal/Negate.ts","../node_modules/tone/Tone/signal/Subtract.ts","../node_modules/tone/Tone/signal/GreaterThanZero.ts","../node_modules/tone/Tone/signal/GreaterThan.ts","../node_modules/tone/Tone/signal/ScaleExp.ts","../node_modules/tone/Tone/signal/SyncedSignal.ts","../node_modules/tone/Tone/component/envelope/Envelope.ts","../node_modules/tone/Tone/instrument/Instrument.ts","../node_modules/tone/Tone/instrument/Monophonic.ts","../node_modules/tone/Tone/component/envelope/AmplitudeEnvelope.ts","../node_modules/tone/Tone/instrument/Synth.ts","../node_modules/tone/Tone/instrument/ModulationSynth.ts","../node_modules/tone/Tone/instrument/AMSynth.ts","../node_modules/tone/Tone/component/filter/BiquadFilter.ts","../node_modules/tone/Tone/component/filter/Filter.ts","../node_modules/tone/Tone/component/envelope/FrequencyEnvelope.ts","../node_modules/tone/Tone/instrument/MonoSynth.ts","../node_modules/tone/Tone/instrument/DuoSynth.ts","../node_modules/tone/Tone/instrument/FMSynth.ts","../node_modules/tone/Tone/instrument/MetalSynth.ts","../node_modules/tone/Tone/instrument/MembraneSynth.ts","../node_modules/tone/Tone/instrument/NoiseSynth.ts","../node_modules/tone/Tone/core/worklet/WorkletGlobalScope.ts","../node_modules/tone/Tone/core/worklet/ToneAudioWorklet.ts","../node_modules/tone/Tone/core/worklet/ToneAudioWorkletProcessor.worklet.ts","../node_modules/tone/Tone/core/worklet/SingleIOProcessor.worklet.ts","../node_modules/tone/Tone/core/worklet/DelayLine.worklet.ts","../node_modules/tone/Tone/component/filter/FeedbackCombFilter.worklet.ts","../node_modules/tone/Tone/component/filter/FeedbackCombFilter.ts","../node_modules/tone/Tone/component/filter/OnePoleFilter.ts","../node_modules/tone/Tone/component/filter/LowpassCombFilter.ts","../node_modules/tone/Tone/instrument/PluckSynth.ts","../node_modules/tone/Tone/instrument/PolySynth.ts","../node_modules/tone/Tone/instrument/Sampler.ts","../node_modules/tone/Tone/event/ToneEvent.ts","../node_modules/tone/Tone/event/Loop.ts","../node_modules/tone/Tone/event/Part.ts","../node_modules/tone/Tone/event/PatternGenerator.ts","../node_modules/tone/Tone/event/Pattern.ts","../node_modules/tone/Tone/event/Sequence.ts","../node_modules/tone/Tone/component/channel/CrossFade.ts","../node_modules/tone/Tone/effect/Effect.ts","../node_modules/tone/Tone/effect/LFOEffect.ts","../node_modules/tone/Tone/effect/AutoFilter.ts","../node_modules/tone/Tone/component/channel/Panner.ts","../node_modules/tone/Tone/effect/AutoPanner.ts","../node_modules/tone/Tone/component/analysis/Follower.ts","../node_modules/tone/Tone/effect/AutoWah.ts","../node_modules/tone/Tone/effect/BitCrusher.worklet.ts","../node_modules/tone/Tone/effect/BitCrusher.ts","../node_modules/tone/Tone/effect/Chebyshev.ts","../node_modules/tone/Tone/component/channel/Split.ts","../node_modules/tone/Tone/component/channel/Merge.ts","../node_modules/tone/Tone/effect/StereoEffect.ts","../node_modules/tone/Tone/effect/StereoFeedbackEffect.ts","../node_modules/tone/Tone/effect/Chorus.ts","../node_modules/tone/Tone/effect/Distortion.ts","../node_modules/tone/Tone/effect/FeedbackEffect.ts","../node_modules/tone/Tone/effect/FeedbackDelay.ts","../node_modules/tone/Tone/component/filter/PhaseShiftAllpass.ts","../node_modules/tone/Tone/effect/FrequencyShifter.ts","../node_modules/tone/Tone/effect/Freeverb.ts","../node_modules/tone/Tone/effect/JCReverb.ts","../node_modules/tone/Tone/effect/StereoXFeedbackEffect.ts","../node_modules/tone/Tone/effect/PingPongDelay.ts","../node_modules/tone/Tone/effect/PitchShift.ts","../node_modules/tone/Tone/effect/Phaser.ts","../node_modules/tone/Tone/effect/Reverb.ts","../node_modules/tone/Tone/component/channel/MidSideSplit.ts","../node_modules/tone/Tone/component/channel/MidSideMerge.ts","../node_modules/tone/Tone/effect/MidSideEffect.ts","../node_modules/tone/Tone/effect/StereoWidener.ts","../node_modules/tone/Tone/effect/Tremolo.ts","../node_modules/tone/Tone/effect/Vibrato.ts","../node_modules/tone/Tone/component/analysis/Analyser.ts","../node_modules/tone/Tone/component/analysis/MeterBase.ts","../node_modules/tone/Tone/component/analysis/Meter.ts","../node_modules/tone/Tone/component/analysis/FFT.ts","../node_modules/tone/Tone/component/analysis/DCMeter.ts","../node_modules/tone/Tone/component/analysis/Waveform.ts","../node_modules/tone/Tone/component/channel/Solo.ts","../node_modules/tone/Tone/component/channel/PanVol.ts","../node_modules/tone/Tone/component/channel/Channel.ts","../node_modules/tone/Tone/component/channel/Mono.ts","../node_modules/tone/Tone/component/channel/MultibandSplit.ts","../node_modules/tone/Tone/component/channel/Panner3D.ts","../node_modules/tone/Tone/component/channel/Recorder.ts","../node_modules/tone/Tone/component/dynamics/Compressor.ts","../node_modules/tone/Tone/component/dynamics/Gate.ts","../node_modules/tone/Tone/component/dynamics/Limiter.ts","../node_modules/tone/Tone/component/dynamics/MidSideCompressor.ts","../node_modules/tone/Tone/component/dynamics/MultibandCompressor.ts","../node_modules/tone/Tone/component/filter/EQ3.ts","../node_modules/tone/Tone/component/filter/Convolver.ts","../node_modules/tone/Tone/index.ts"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n})(this, (function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n        target = _ref.target,\n        timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var _getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, _getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, _getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      if (valueAtStartTime === value) {\n        return value;\n      }\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n        value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n        startTime = _ref.startTime,\n        values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList = /*#__PURE__*/function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n      return _createClass(AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n              }\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            var removedAutomationEvent = this._automationEvents[index];\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n                var startTime = lastAutomationEvent === undefined ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = lastAutomationEvent === undefined ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                var duration = eventTime - lastAutomationEvent.startTime;\n                var ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                var length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                var fraction = duration / (length - 1) * ratio;\n                var values = lastAutomationEvent.values.slice(0, length);\n                if (fraction < 1) {\n                  for (var i = 1; i < length; i += 1) {\n                    var factor = fraction * i % 1;\n                    values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                  }\n                }\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(_getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n          var indexOfNextEvent = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n          var nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n          var indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n          var currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, _getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n              startTime = _getEndTimeAndValueOf2[0],\n              value = _getEndTimeAndValueOf2[1];\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n              _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n              _startTime = _getEndTimeAndValueOf4[0],\n              _value = _getEndTimeAndValueOf4[1];\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n          return this._defaultValue;\n        }\n      }]);\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n}));\n","function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","export const version: string = \"15.1.22\";\n","import { TAbortErrorFactory } from '../types';\n\nexport const createAbortError: TAbortErrorFactory = () => new DOMException('', 'AbortError');\n","import { IAudioNode, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from './interfaces';\nimport {\n    TAudioNodeConnectionsStore,\n    TAudioNodeStore,\n    TAudioParamConnectionsStore,\n    TAudioParamStore,\n    TContext,\n    TContextStore,\n    TCycleCounters,\n    TInternalStateEventListener,\n    TNativeAudioWorkletNode,\n    TNativeContext\n} from './types';\n\nexport const ACTIVE_AUDIO_NODE_STORE: WeakSet<IAudioNode<TContext>> = new WeakSet();\n\nexport const AUDIO_NODE_CONNECTIONS_STORE: TAudioNodeConnectionsStore = new WeakMap();\n\nexport const AUDIO_NODE_STORE: TAudioNodeStore = new WeakMap();\n\nexport const AUDIO_PARAM_CONNECTIONS_STORE: TAudioParamConnectionsStore = new WeakMap();\n\nexport const AUDIO_PARAM_STORE: TAudioParamStore = new WeakMap();\n\nexport const CONTEXT_STORE: TContextStore = new WeakMap();\n\nexport const EVENT_LISTENERS: WeakMap<IAudioNode<TContext>, Set<TInternalStateEventListener>> = new WeakMap();\n\nexport const CYCLE_COUNTERS: TCycleCounters = new WeakMap();\n\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS: WeakMap<\n    TNativeContext,\n    Map<string, IAudioWorkletProcessorConstructor>\n> = new WeakMap();\n\nexport const NODE_TO_PROCESSOR_MAPS: WeakMap<\n    TNativeContext,\n    WeakMap<TNativeAudioWorkletNode, Promise<IAudioWorkletProcessor>>\n> = new WeakMap();\n","import { TConstructor } from '../types';\n\nconst handler = {\n    construct(): any {\n        return handler;\n    }\n};\n\nexport const isConstructible = (constructible: TConstructor): boolean => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n\n        new proxy(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source: string, url: string): [string, string] => {\n    const importStatements = [];\n\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nimport { IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TAddAudioWorkletModuleFactory, TEvaluateAudioWorkletGlobalScopeFunction } from '../types';\n\nconst verifyParameterDescriptors = (parameterDescriptors: IAudioWorkletProcessorConstructor['parameterDescriptors']) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\n\nconst verifyProcessorCtor = <T extends IAudioWorkletProcessorConstructor>(processorCtor: T) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\n\nexport const createAddAudioWorkletModule: TAddAudioWorkletModuleFactory = (\n    cacheTestResult,\n    createNotSupportedError,\n    evaluateSource,\n    exposeCurrentFrameAndCurrentTime,\n    fetchSource,\n    getNativeContext,\n    getOrCreateBackupOfflineAudioContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    ongoingRequests,\n    resolvedRequests,\n    testAudioWorkletProcessorPostMessageSupport,\n    window\n) => {\n    let index = 0;\n\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n\n        const nativeContext = getNativeContext(context);\n\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise =\n            nativeContext.audioWorklet === undefined\n                ? fetchSource(moduleURL)\n                      .then(([source, absoluteUrl]) => {\n                          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n\n                          /*\n                           * This is the unminified version of the code used below:\n                           *\n                           * ```js\n                           * ${ importStatements };\n                           * ((a, b) => {\n                           *     (a[b] = a[b] || [ ]).push(\n                           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                           *             ${ sourceWithoutImportStatements }\n                           *         }\n                           *     );\n                           * })(window, '_AWGS');\n                           * ```\n                           */\n                          // tslint:disable-next-line:max-line-length\n                          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n\n                          // @todo Evaluating the given source code is a possible security problem.\n                          return evaluateSource(wrappedSource);\n                      })\n                      .then(() => {\n                          const evaluateAudioWorkletGlobalScope = (<TEvaluateAudioWorkletGlobalScopeFunction[]>(<any>window)._AWGS).pop();\n\n                          if (evaluateAudioWorkletGlobalScope === undefined) {\n                              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                              throw new SyntaxError();\n                          }\n\n                          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                              evaluateAudioWorkletGlobalScope(\n                                  class AudioWorkletProcessor {},\n                                  undefined,\n                                  (name, processorCtor) => {\n                                      if (name.trim() === '') {\n                                          throw createNotSupportedError();\n                                      }\n\n                                      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n                                      if (nodeNameToProcessorConstructorMap !== undefined) {\n                                          if (nodeNameToProcessorConstructorMap.has(name)) {\n                                              throw createNotSupportedError();\n                                          }\n\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                                      } else {\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                                      }\n                                  },\n                                  nativeContext.sampleRate,\n                                  undefined,\n                                  undefined\n                              )\n                          );\n                      })\n                : Promise.all([\n                      fetchSource(moduleURL),\n                      Promise.resolve(\n                          cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport)\n                      )\n                  ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                      const currentIndex = index + 1;\n\n                      index = currentIndex;\n\n                      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                      /*\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * This is the unminified version of the code used below.\n                       *\n                       * ```js\n                       * class extends AudioWorkletProcessor {\n                       *\n                       *     __buffers = new WeakSet();\n                       *\n                       *     constructor () {\n                       *         super();\n                       *\n                       *         this.port.postMessage = ((postMessage) => {\n                       *             return (message, transferables) => {\n                       *                 const filteredTransferables = (transferables)\n                       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                       *                     : transferables;\n                       *\n                       *                 return postMessage.call(this.port, message, filteredTransferables);\n                       *              };\n                       *         })(this.port.postMessage);\n                       *     }\n                       * }\n                       * ```\n                       */\n                      const patchedAudioWorkletProcessor = isSupportingPostMessage\n                          ? 'AudioWorkletProcessor'\n                          : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                      /*\n                       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                       *\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                       *\n                       * This is the unminified version of the code used below:\n                       *\n                       * ```js\n                       * `${ importStatements };\n                       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                       * })(\n                       *     ${patchedAudioWorkletProcessor },\n                       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                       *\n                       *         __collectBuffers = (array) => {\n                       *             array.forEach((element) => this.__buffers.add(element.buffer));\n                       *         };\n                       *\n                       *         process (inputs, outputs, parameters) {\n                       *             inputs.forEach(this.__collectBuffers);\n                       *             outputs.forEach(this.__collectBuffers);\n                       *             this.__collectBuffers(Object.values(parameters));\n                       *\n                       *             return super.process(\n                       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                       *                 outputs,\n                       *                 parameters\n                       *             );\n                       *         }\n                       *\n                       *     })\n                       * );\n                       *\n                       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                       *\n                       *     process () {\n                       *         return false;\n                       *     }\n                       *\n                       * })`\n                       * ```\n                       */\n                      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                      const bufferRegistration = isSupportingPostMessage\n                          ? ''\n                          : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                      const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                      const url = URL.createObjectURL(blob);\n\n                      return nativeContext.audioWorklet\n                          .addModule(url, options)\n                          .then(() => {\n                              if (isNativeOfflineAudioContext(nativeContext)) {\n                                  return nativeContext;\n                              }\n\n                              // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                              const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n\n                              return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                          })\n                          .then((nativeContextOrBackupOfflineAudioContext) => {\n                              if (nativeAudioWorkletNodeConstructor === null) {\n                                  throw new SyntaxError();\n                              }\n\n                              try {\n                                  // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                                  new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                              } catch {\n                                  throw new SyntaxError();\n                              }\n                          })\n                          .finally(() => URL.revokeObjectURL(url));\n                  });\n\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n\n        promise\n            .then(() => {\n                const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n                if (updatedResolvedRequestsOfContext === undefined) {\n                    resolvedRequests.set(context, new Set([moduleURL]));\n                } else {\n                    updatedResolvedRequestsOfContext.add(moduleURL);\n                }\n            })\n            .finally(() => {\n                const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n                if (updatedOngoingRequestsOfContext !== undefined) {\n                    updatedOngoingRequestsOfContext.delete(moduleURL);\n                }\n            });\n\n        return promise;\n    };\n};\n","import { TGetValueForKeyFunction } from '../types';\n\nexport const getValueForKey: TGetValueForKeyFunction = (map, key) => {\n    const value = map.get(key);\n\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n\n    return value;\n};\n","import { TPickElementFromSetFunction } from '../types';\n\nexport const pickElementFromSet: TPickElementFromSetFunction = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n\n    const [matchingElement] = matchingElements;\n\n    set.delete(matchingElement);\n\n    return matchingElement;\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioNodeInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioNode = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioNodeInputConnection>>,\n    source: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n","import { EVENT_LISTENERS } from '../globals';\nimport { TGetEventListenersOfAudioNodeFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getEventListenersOfAudioNode: TGetEventListenersOfAudioNodeFunction = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToActive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n","import { IAudioNode, IAudioWorkletNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioWorkletNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioWorkletNode<T> => {\n    return 'port' in audioNode;\n};\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToPassive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    activeInputs: Set<TActiveInputConnection<T>>[]\n) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n","import { IAnalyserNode, IAnalyserOptions } from '../interfaces';\nimport { TAnalyserNodeConstructorFactory, TAudioNodeRenderer, TContext, TNativeAnalyserNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n} as const;\n\nexport const createAnalyserNodeConstructor: TAnalyserNodeConstructorFactory = (\n    audionNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class AnalyserNode<T extends TContext> extends audionNodeConstructor<T> implements IAnalyserNode<T> {\n        private _nativeAnalyserNode: TNativeAnalyserNode;\n\n        constructor(context: T, options?: Partial<IAnalyserOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n\n        get fftSize(): number {\n            return this._nativeAnalyserNode.fftSize;\n        }\n\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n\n        get frequencyBinCount(): number {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n\n        get maxDecibels(): number {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n\n            this._nativeAnalyserNode.maxDecibels = value;\n\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get minDecibels(): number {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n\n            this._nativeAnalyserNode.minDecibels = value;\n\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get smoothingTimeConstant(): number {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n\n        public getByteFrequencyData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n\n        public getByteTimeDomainData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n\n        public getFloatFrequencyData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n\n        public getFloatTimeDomainData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n","import { TNativeAudioNode, TNativeContext } from '../types';\n\nexport const isOwnedByContext = (nativeAudioNode: TNativeAudioNode, nativeContext: TNativeContext): boolean => {\n    return nativeAudioNode.context === nativeContext;\n};\n","import { TNativeAudioBuffer } from '../types';\n\nexport const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer: TNativeAudioBuffer): boolean => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","import { TIndexSizeErrorFactory } from '../types';\n\nexport const createIndexSizeError: TIndexSizeErrorFactory = () => new DOMException('', 'IndexSizeError');\n","import { createIndexSizeError } from '../factories/index-size-error';\nimport { TNativeAudioBuffer } from '../types';\n\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer: TNativeAudioBuffer): void => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel: number) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            } catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsActiveAudioNodeFunction } from '../types';\n\nexport const isActiveAudioNode: TIsActiveAudioNodeFunction = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n","import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TAudioNodeConnections, TContext, TGetAudioNodeConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioNodeConnections: TGetAudioNodeConnectionsFunction = <T extends TContext>(\n    audioNode: IAudioNode<T>\n): TAudioNodeConnections<T> => {\n    return <TAudioNodeConnections<T>>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n","import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioParamConnections, TContext, TGetAudioParamConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioParamConnections: TGetAudioParamConnectionsFunction = <T extends TContext>(\n    audioParam: IAudioParam\n): TAudioParamConnections<T> => {\n    return <TAudioParamConnections<T>>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n","import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\nexport const deactivateActiveAudioNodeInputConnections = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    trace: readonly IAudioNode<T>[]\n) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n\n    activeInputs.forEach((connections) =>\n        connections.forEach(([source]) => {\n            if (!trace.includes(audioNode)) {\n                deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n            }\n        })\n    );\n\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n              // Bug #149: Safari does not yet support the detune AudioParam.\n              audioNode.playbackRate\n          ]\n        : isAudioWorkletNode(audioNode)\n        ? Array.from(audioNode.parameters.values())\n        : isBiquadFilterNode(audioNode)\n        ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n        : isConstantSourceNode(audioNode)\n        ? [audioNode.offset]\n        : isGainNode(audioNode)\n        ? [audioNode.gain]\n        : isOscillatorNode(audioNode)\n        ? [audioNode.detune, audioNode.frequency]\n        : isStereoPannerNode(audioNode)\n        ? [audioNode.pan]\n        : [];\n\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n","import { IAudioBufferSourceNode, IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioBufferSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioBufferSourceNode<T> => {\n    return 'playbackRate' in audioNode;\n};\n","import { IAudioNode, IBiquadFilterNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isBiquadFilterNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IBiquadFilterNode<T> => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n","import { IAudioNode, IConstantSourceNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isConstantSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IConstantSourceNode<T> => {\n    return 'offset' in audioNode;\n};\n","import { IAudioNode, IGainNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isGainNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IGainNode<T> => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n","import { IAudioNode, IOscillatorNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isOscillatorNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IOscillatorNode<T> => {\n    return 'detune' in audioNode && 'frequency' in audioNode && !('gain' in audioNode);\n};\n","import { IAudioNode, IStereoPannerNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isStereoPannerNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IStereoPannerNode<T> => {\n    return 'pan' in audioNode;\n};\n","import { IAudioDestinationNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\n\nexport const deactivateAudioGraph = <T extends TContext>(context: T): void => {\n    deactivateActiveAudioNodeInputConnections(<IAudioDestinationNode<T>>context.destination, []);\n};\n","import { IAudioContextOptions } from '../interfaces';\n\nexport const isValidLatencyHint = (latencyHint: IAudioContextOptions['latencyHint']) => {\n    return (\n        latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'))\n    );\n};\n","import { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioNode = <T extends TContext>(\n    audioNodeOrAudioParam: IAudioNode<T> | IAudioParam\n): audioNodeOrAudioParam is IAudioNode<T> => {\n    return 'context' in audioNodeOrAudioParam;\n};\n","import { TAudioNodeOutputConnection, TContext, TOutputConnection } from '../types';\nimport { isAudioNode } from './audio-node';\n\nexport const isAudioNodeOutputConnection = <T extends TContext>(\n    outputConnection: TOutputConnection<T>\n): outputConnection is TAudioNodeOutputConnection<T> => {\n    return isAudioNode(outputConnection[0]);\n};\n","import { TInsertElementInSetFunction } from '../types';\n\nexport const insertElementInSet: TInsertElementInSetFunction = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n\n    set.add(element);\n\n    return true;\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    [output, eventListener]: TPassiveAudioParamInputConnection,\n    ignoreDuplicates: boolean\n) => {\n    insertElementInSet(\n        activeInputs,\n        [source, output, eventListener],\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n        ignoreDuplicates\n    );\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addPassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    [source, output, eventListener]: TActiveInputConnection<T>,\n    ignoreDuplicates: boolean\n) => {\n    const passiveInputConnections = passiveInputs.get(source);\n\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    } else {\n        insertElementInSet(\n            passiveInputConnections,\n            [output, eventListener],\n            (passiveInputConnection) => passiveInputConnection[0] === output,\n            ignoreDuplicates\n        );\n    }\n};\n","import { INativeAudioNodeFaker } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\n\nexport const isNativeAudioNodeFaker = (\n    nativeAudioNodeOrNativeAudioNodeFaker: TNativeAudioNode | INativeAudioNodeFaker\n): nativeAudioNodeOrNativeAudioNodeFaker is INativeAudioNodeFaker => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { INativeAudioNodeFaker } from '../interfaces';\nimport { TConnectNativeAudioNodeToNativeAudioNodeFunction, TNativeAudioNode } from '../types';\n\nexport const connectNativeAudioNodeToNativeAudioNode: TConnectNativeAudioNodeToNativeAudioNodeFunction = (\n    nativeSourceAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    nativeDestinationAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    output: number,\n    input: number\n): [TNativeAudioNode, number, number] => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n\n    return [nativeDestinationAudioNode, output, input];\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\n\nexport const deleteActiveInputConnection = <T extends TContext>(\n    activeInputConnections: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n): null | TActiveInputConnection<T> => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n\n            return activeInputConnection;\n        }\n    }\n\n    return null;\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext, TInternalStateEventListener } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const deleteEventListenerOfAudioNode = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    eventListener: TInternalStateEventListener\n) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { TDisconnectNativeAudioNodeFromNativeAudioNodeFunction } from '../types';\n\nexport const disconnectNativeAudioNodeFromNativeAudioNode: TDisconnectNativeAudioNodeFromNativeAudioNodeFunction = (\n    nativeSourceAudioNode,\n    nativeDestinationAudioNode,\n    output,\n    input\n) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n","import { AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode, INativeAudioNodeFaker } from '../interfaces';\nimport { TContext, TGetNativeAudioNodeFunction, TNativeAudioNode } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioNode: TGetNativeAudioNodeFunction = <T extends TContext, U extends TNativeAudioNode | INativeAudioNodeFaker>(\n    audioNode: IAudioNode<T>\n): U => {\n    return <U>getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n","import { AUDIO_PARAM_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TNativeAudioParam } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioParam = (audioParam: IAudioParam): TNativeAudioParam => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n","import { CYCLE_COUNTERS } from '../globals';\nimport { TIsPartOfACycleFunction } from '../types';\n\nexport const isPartOfACycle: TIsPartOfACycleFunction = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsPassiveAudioNodeFunction } from '../types';\n\nexport const isPassiveAudioNode: TIsPassiveAudioNodeFunction = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n","import { TNativeAudioContext, TNativeAudioWorkletNodeConstructor } from '../types';\n\nexport const testAudioNodeDisconnectMethodSupport = (\n    nativeAudioContext: TNativeAudioContext,\n    nativeAudioWorkletNodeConstructor: null | TNativeAudioWorkletNodeConstructor\n): Promise<boolean> => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        } else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n\n            channelData[0] = 1;\n            channelData[1] = 1;\n\n            const source = nativeAudioContext.createBufferSource();\n\n            source.buffer = ones;\n            source.loop = true;\n\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n\n                if (Array.prototype.some.call(chnnlDt, (sample: number) => sample === 1)) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n\n                source.stop();\n\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n\n            source.start();\n        }\n    });\n};\n","import { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const visitEachAudioNodeOnce = <T extends TContext>(\n    cycles: IAudioNode<T>[][],\n    visitor: (audioNode: IAudioNode<T>, count: number) => void\n): void => {\n    const counts = new Map<IAudioNode<T>, number>();\n\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n","import { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const isNativeAudioNode = (\n    nativeAudioNodeOrAudioParam: TNativeAudioNode | TNativeAudioParam\n): nativeAudioNodeOrAudioParam is TNativeAudioNode => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n","import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n","import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n","import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deleteActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    return pickElementFromSet(\n        activeInputs,\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n    );\n};\n","import { IReadOnlyMap } from './interfaces';\n\nexport class ReadOnlyMap<T, U> implements IReadOnlyMap<T, U> {\n    private _map: Map<T, U>;\n\n    constructor(parameters: [T, U][]) {\n        this._map = new Map(parameters);\n    }\n\n    get size(): number {\n        return this._map.size;\n    }\n\n    public entries(): IterableIterator<[T, U]> {\n        return this._map.entries();\n    }\n\n    public forEach(callback: (audioParam: U, name: T, map: ReadOnlyMap<T, U>) => void, thisArg: any = null): void {\n        return this._map.forEach((value: U, key: T) => callback.call(thisArg, value, key, this));\n    }\n\n    public get(name: T): undefined | U {\n        return this._map.get(name);\n    }\n\n    public has(name: T): boolean {\n        return this._map.has(name);\n    }\n\n    public keys(): IterableIterator<T> {\n        return this._map.keys();\n    }\n\n    public values(): IterableIterator<U> {\n        return this._map.values();\n    }\n}\n","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n","import { TNativeAudioBuffer } from '../types';\n\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: string]: Float32Array },\n    key: string,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent: any,\n    key: number | string,\n    channelNumber: number,\n    bufferOffset: number\n): void {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n\n        // Bug #5: Safari does not support copyFromChannel().\n    } else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n\n            parent[key].set(slicedInput);\n        }\n    }\n}\n","import { TNativeAudioBuffer } from '../types';\n\nexport const copyToChannel = (\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n\n        // Bug #5: Safari does not support copyToChannel().\n    } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n","export const createNestedArrays = (x: number, y: number | number[]): Float32Array[][] => {\n    const arrays: Float32Array[][] = [];\n\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n\n        const length = typeof y === 'number' ? y : y[i];\n\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n\n        arrays.push(array);\n    }\n\n    return arrays;\n};\n","import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioNode, IAudioWorkletProcessor } from '../interfaces';\nimport { TContext, TNativeAudioWorkletNode, TNativeOfflineAudioContext } from '../types';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioWorkletProcessor = <T extends TContext>(\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    proxy: IAudioNode<T>\n): Promise<IAudioWorkletProcessor> => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IBiquadFilterNode, IBiquadFilterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TBiquadFilterNodeConstructorFactory, TBiquadFilterType, TContext, TNativeBiquadFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n} as const;\n\nexport const createBiquadFilterNodeConstructor: TBiquadFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class BiquadFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IBiquadFilterNode<T> {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _gain: IAudioParam;\n\n        private _nativeBiquadFilterNode: TNativeBiquadFilterNode;\n\n        private _Q: IAudioParam;\n\n        constructor(context: T, options?: Partial<IBiquadFilterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createBiquadFilterNodeRenderer() : null);\n\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.detune,\n                1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT),\n                -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT)\n            );\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.gain,\n                40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT),\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n\n        get Q(): IAudioParam {\n            return this._Q;\n        }\n\n        get type(): TBiquadFilterType {\n            return this._nativeBiquadFilterNode.type;\n        }\n\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n","import { IChannelMergerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelMergerNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n} as const;\n\nexport const createChannelMergerNodeConstructor: TChannelMergerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class ChannelMergerNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelMergerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n","import { IChannelSplitterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelSplitterNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n} as const;\n\nexport const createChannelSplitterNodeConstructor: TChannelSplitterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n) => {\n    return class ChannelSplitterNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelSplitterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioParam, IAudioScheduledSourceNodeEventMap, IConstantSourceNode, IConstantSourceOptions } from '../interfaces';\nimport {\n    TConstantSourceNodeConstructorFactory,\n    TConstantSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeConstantSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n} as const;\n\nexport const createConstantSourceNodeConstructor: TConstantSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRendererFactory,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class ConstantSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IConstantSourceNode<T>\n    {\n        private _constantSourceNodeRenderer: TConstantSourceNodeRenderer<T>;\n\n        private _nativeConstantSourceNode: TNativeConstantSourceNode;\n\n        private _offset: IAudioParam;\n\n        private _onended: null | TEventHandler<this>;\n\n        constructor(context: T, options?: Partial<IConstantSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = <TConstantSourceNodeRenderer<T>>(\n                (isOffline ? createConstantSourceNodeRendererFactory() : null)\n            );\n\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(\n                this,\n                isOffline,\n                nativeConstantSourceNode.offset,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._onended = null;\n        }\n\n        get offset(): IAudioParam {\n            return this._offset;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeConstantSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        public start(when = 0): void {\n            this._nativeConstantSourceNode.start(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeConstantSourceNode.stop(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n","import { IConvolverNode, IConvolverOptions } from '../interfaces';\nimport { TAnyAudioBuffer, TAudioNodeRenderer, TContext, TConvolverNodeConstructorFactory, TNativeConvolverNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n} as const;\n\nexport const createConvolverNodeConstructor: TConvolverNodeConstructorFactory = (\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class ConvolverNode<T extends TContext> extends audioNodeConstructor<T> implements IConvolverNode<T> {\n        private _isBufferNullified: boolean;\n\n        private _nativeConvolverNode: TNativeConvolverNode;\n\n        constructor(context: T, options?: Partial<IConvolverOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createConvolverNodeRenderer() : null);\n\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeConvolverNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n\n                setAudioNodeTailTime(this, 0);\n            } else {\n                this._isBufferNullified = false;\n\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n\n        get normalize(): boolean {\n            return this._nativeConvolverNode.normalize;\n        }\n\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n","export const detachArrayBuffer = (arrayBuffer: ArrayBuffer): Promise<void> => {\n    const { port1, port2 } = new MessageChannel();\n\n    return new Promise((resolve) => {\n        const closeAndResolve = () => {\n            port2.onmessage = null;\n\n            port1.close();\n            port2.close();\n\n            resolve();\n        };\n\n        port2.onmessage = () => closeAndResolve();\n\n        try {\n            port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } catch {\n            // Ignore errors.\n        } finally {\n            closeAndResolve();\n        }\n    });\n};\n","import { IAudioParam, IDelayNode, IDelayOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TDelayNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n} as const;\n\nexport const createDelayNodeConstructor: TDelayNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DelayNode<T extends TContext> extends audioNodeConstructor<T> implements IDelayNode<T> {\n        private _delayTime: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDelayOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n\n        get delayTime(): IAudioParam {\n            return this._delayTime;\n        }\n    };\n};\n","import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TDisconnectMultipleOutputsFactory, TIndexSizeErrorFactory, TNativeAudioNode } from '../types';\n\nconst getOutputAudioNodeAtIndex = (\n    createIndexSizeError: TIndexSizeErrorFactory,\n    outputAudioNodes: TNativeAudioNode[],\n    output: number\n): TNativeAudioNode => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n\n    return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs: TDisconnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n","import { IAudioParam, IDynamicsCompressorNode, IDynamicsCompressorOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TDynamicsCompressorNodeConstructorFactory,\n    TNativeAudioParam,\n    TNativeDynamicsCompressorNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n} as const;\n\nexport const createDynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DynamicsCompressorNode<T extends TContext> extends audioNodeConstructor<T> implements IDynamicsCompressorNode<T> {\n        private _attack: IAudioParam;\n\n        private _knee: IAudioParam;\n\n        private _nativeDynamicsCompressorNode: TNativeDynamicsCompressorNode;\n\n        private _ratio: IAudioParam;\n\n        private _release: IAudioParam;\n\n        private _threshold: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDynamicsCompressorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDynamicsCompressorNodeRenderer() : null);\n\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n\n            setAudioNodeTailTime(this, 0.006);\n        }\n\n        get attack(): IAudioParam {\n            return this._attack;\n        }\n\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount(): number {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n\n            this._nativeDynamicsCompressorNode.channelCount = value;\n\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        /*\n         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        get knee(): IAudioParam {\n            return this._knee;\n        }\n\n        get ratio(): IAudioParam {\n            return this._ratio;\n        }\n\n        get reduction(): number {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value === 'number') {\n                return (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value;\n            }\n\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n\n        get release(): IAudioParam {\n            return this._release;\n        }\n\n        get threshold(): IAudioParam {\n            return this._threshold;\n        }\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IGainNode, IGainOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TGainNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n} as const;\n\nexport const createGainNodeConstructor: TGainNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class GainNode<T extends TContext> extends audioNodeConstructor<T> implements IGainNode<T> {\n        private _gain: IAudioParam;\n\n        constructor(context: T, options?: Partial<IGainOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createGainNodeRenderer() : null);\n\n            super(context, false, nativeGainNode, gainNodeRenderer);\n\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n    };\n};\n","import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => new DOMException('', 'InvalidStateError');\n","import { TInvalidAccessErrorFactory } from '../types';\n\nexport const createInvalidAccessError: TInvalidAccessErrorFactory = () => new DOMException('', 'InvalidAccessError');\n","import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nimport { IIIRFilterNode, IIIRFilterOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TIIRFilterNodeConstructorFactory, TNativeIIRFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createIIRFilterNodeConstructor: TIIRFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class IIRFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IIIRFilterNode<T> {\n        private _nativeIIRFilterNode: TNativeIIRFilterNode;\n\n        constructor(\n            context: T,\n            options: { feedback: IIIRFilterOptions['feedback']; feedforward: IIIRFilterOptions['feedforward'] } & Partial<IIIRFilterOptions>\n        ) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(\n                nativeContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                mergedOptions\n            );\n            const iirFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null)\n            );\n\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (\n    feedback: Float64Array,\n    feedbackLength: number,\n    feedforward: Float64Array,\n    feedforwardLength: number,\n    minLength: number,\n    xBuffer: Float32Array,\n    yBuffer: Float32Array,\n    bufferIndex: number,\n    bufferLength: number,\n    input: Float32Array,\n    output: Float32Array\n) => {\n    const inputLength = input.length;\n\n    let i = bufferIndex;\n\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n        output[j] = y;\n    }\n\n    return i;\n};\n","import { IAudioContext, IAudioNodeOptions, IMediaStreamAudioDestinationNode, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioDestinationNodeConstructorFactory, TNativeMediaStreamAudioDestinationNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createMediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioDestinationNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioDestinationNode<T> {\n        private _nativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNode;\n\n        constructor(context: T, options?: Partial<IAudioNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n\n            super(context, false, nativeMediaStreamAudioDestinationNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n\n        get stream(): MediaStream {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n","import { TNativeContext } from '../types';\n\nexport const testPromiseSupport = (nativeContext: TNativeContext): boolean => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(<ArrayBuffer>uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n\n        if (promise === undefined) {\n            return false;\n        }\n\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n\n        return true;\n    } catch {\n        // Ignore errors.\n    }\n\n    return false;\n};\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n","export const assignNativeAudioNodeOption = <T extends keyof any, U extends any>(\n    nativeAudioNode: Record<T, U>,\n    options: Record<T, U>,\n    option: T\n) => {\n    const value = options[option];\n\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n","import { IAudioNodeOptions } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\nimport { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\n\nexport const assignNativeAudioNodeOptions = (nativeAudioNode: TNativeAudioNode, options: IAudioNodeOptions): void => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n","import { TNativeAnalyserNode } from '../types';\n\nexport const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode: TNativeAnalyserNode): boolean => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n","export const assignNativeAudioNodeAudioParamValue = <T extends { [key: string]: any }, U extends { [key: string]: any }>(\n    nativeAudioNode: T,\n    options: U,\n    audioParam: keyof T & keyof U\n) => {\n    const value = options[audioParam];\n\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n","import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            (<(when: number, offset: number, duration?: number) => void>start).call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n","import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n","export const computeBufferSize = (baseLatency: null | number, sampleRate: number) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n","import { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\n\nexport const createAudioWorkletProcessorPromise = async (\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n","import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): Promise<IAudioWorkletNodeOptions> => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            reject(data);\n        };\n\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeBiquadFilterNodeFactory } from '../types';\n\nexport const createNativeBiquadFilterNode: TNativeBiquadFilterNodeFactory = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n\n    return nativeBiquadFilterNode;\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nimport { TNativeChannelSplitterNodeFactory } from '../types';\n\nexport const createNativeChannelSplitterNode: TNativeChannelSplitterNodeFactory = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n\n    return nativeChannelSplitterNode;\n};\n","import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeChannelSplitterNode } from '../types';\n\nexport const wrapChannelSplitterNode = (channelSplitterNode: TNativeChannelSplitterNode): void => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n","import { TNativeAudioNode } from '../types';\n\nexport const interceptConnections = <T extends object>(\n    original: T,\n    interceptor: TNativeAudioNode\n): T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] } => {\n    (<T & { connect: TNativeAudioNode['connect'] }>original).connect = interceptor.connect.bind(interceptor);\n\n    (<T & { disconnect: TNativeAudioNode['disconnect'] }>original).disconnect = interceptor.disconnect.bind(interceptor);\n\n    return <T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] }>original;\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDelayNodeFactory } from '../types';\n\nexport const createNativeDelayNode: TNativeDelayNodeFactory = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n\n    return nativeDelayNode;\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeGainNodeFactory } from '../types';\n\nexport const createNativeGainNode: TNativeGainNodeFactory = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n\n    return nativeGainNode;\n};\n","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeIIRFilterNode, TNativeIIRFilterNodeFakerFactoryFactory } from '../types';\n\nfunction divide(a: [number, number], b: [number, number]): [number, number] {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a: [number, number], b: [number, number]): [number, number] {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient: Float64Array, z: [number, number]): [number, number] {\n    let result: [number, number] = [0, 0];\n\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n\n        result[0] += coefficient[i];\n    }\n\n    return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory: TNativeIIRFilterNodeFakerFactoryFactory = (\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n\n        const bufferLength = 32;\n        const bufferIndexes: number[] = [];\n        const xBuffers: Float32Array[] = [];\n        const yBuffers: Float32Array[] = [];\n\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event: AudioProcessingEvent) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n\n            const numberOfChannels = inputBuffer.numberOfChannels;\n\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n\n                bufferIndexes[i] = filterBuffer(\n                    convertedFeedback,\n                    feedbackLength,\n                    convertedFeedforward,\n                    feedforwardLength,\n                    minLength,\n                    xBuffers[i],\n                    yBuffers[i],\n                    bufferIndexes[i],\n                    bufferLength,\n                    input,\n                    output\n                );\n            }\n        };\n\n        const nyquist = nativeContext.sampleRate / 2;\n\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeIIRFilterNode['channelCountMode'] {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeIIRFilterNode['channelInterpretation'] {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context(): TNativeIIRFilterNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs(): number {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args: any[]): void {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n\n                const length = frequencyHz.length;\n\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z: [number, number] = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n","import { TNativeScriptProcessorNodeFactory } from '../types';\n\nexport const createNativeScriptProcessorNode: TNativeScriptProcessorNodeFactory = (\n    nativeContext,\n    bufferSize,\n    numberOfInputChannels,\n    numberOfOutputChannels\n) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n","import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => new DOMException('', 'NotSupportedError');\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TNativeOfflineAudioContext, TOfflineAudioContextConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createOfflineAudioContextConstructor: TOfflineAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor<IOfflineAudioContext> implements IOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions);\n        constructor(numberOfChannels: number, length: number, sampleRate: number);\n        constructor(a: number | IOfflineAudioContextOptions, b?: number, c?: number) {\n            let options: IOfflineAudioContextOptions;\n\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            } else if (typeof a === 'object') {\n                options = a;\n            } else {\n                throw new Error('The given parameters are not valid.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n","import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport {\n    IAudioParam,\n    IAudioScheduledSourceNodeEventMap,\n    IMinimalOfflineAudioContext,\n    IOscillatorNode,\n    IOscillatorNodeRenderer,\n    IOscillatorOptions\n} from '../interfaces';\nimport {\n    TContext,\n    TEventHandler,\n    TNativeOscillatorNode,\n    TOscillatorNodeConstructorFactory,\n    TOscillatorNodeRenderer,\n    TOscillatorType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max', // This attribute has no effect for nodes with no inputs.\n    channelInterpretation: 'speakers', // This attribute has no effect for nodes with no inputs.\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n} as const;\n\nexport const createOscillatorNodeConstructor: TOscillatorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class OscillatorNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IOscillatorNode<T>\n    {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _nativeOscillatorNode: TNativeOscillatorNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _oscillatorNodeRenderer: TOscillatorNodeRenderer<T>;\n\n        constructor(context: T, options?: Partial<IOscillatorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = <TOscillatorNodeRenderer<T>>(isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                (<IOscillatorNodeRenderer<IMinimalOfflineAudioContext>>this._oscillatorNodeRenderer).periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeOscillatorNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get type(): TOscillatorType {\n            return this._nativeOscillatorNode.type;\n        }\n\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n\n        public setPeriodicWave(periodicWave: PeriodicWave): void {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n\n        public start(when = 0): void {\n            this._nativeOscillatorNode.start(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeOscillatorNode.stop(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IPannerNode, IPannerOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TContext,\n    TDistanceModelType,\n    TNativePannerNode,\n    TPannerNodeConstructorFactory,\n    TPanningModelType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n} as const;\n\nexport const createPannerNodeConstructor: TPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class PannerNode<T extends TContext> extends audioNodeConstructor<T> implements IPannerNode<T> {\n        private _nativePannerNode: TNativePannerNode;\n\n        private _orientationX: IAudioParam;\n\n        private _orientationY: IAudioParam;\n\n        private _orientationZ: IAudioParam;\n\n        private _positionX: IAudioParam;\n\n        private _positionY: IAudioParam;\n\n        private _positionZ: IAudioParam;\n\n        constructor(context: T, options?: Partial<IPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createPannerNodeRenderer() : null);\n\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get coneInnerAngle(): number {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n\n        get coneOuterAngle(): number {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n\n        get coneOuterGain(): number {\n            return this._nativePannerNode.coneOuterGain;\n        }\n\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n\n        get distanceModel(): TDistanceModelType {\n            return this._nativePannerNode.distanceModel;\n        }\n\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n\n        get maxDistance(): number {\n            return this._nativePannerNode.maxDistance;\n        }\n\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n\n        get orientationX(): IAudioParam {\n            return this._orientationX;\n        }\n\n        get orientationY(): IAudioParam {\n            return this._orientationY;\n        }\n\n        get orientationZ(): IAudioParam {\n            return this._orientationZ;\n        }\n\n        get panningModel(): TPanningModelType {\n            return this._nativePannerNode.panningModel;\n        }\n\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n\n        get positionX(): IAudioParam {\n            return this._positionX;\n        }\n\n        get positionY(): IAudioParam {\n            return this._positionY;\n        }\n\n        get positionZ(): IAudioParam {\n            return this._positionZ;\n        }\n\n        get refDistance(): number {\n            return this._nativePannerNode.refDistance;\n        }\n\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n\n        get rolloffFactor(): number {\n            return this._nativePannerNode.rolloffFactor;\n        }\n\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n","import { IPeriodicWave, IPeriodicWaveOptions } from '../interfaces';\nimport { TContext, TPeriodicWaveConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n} as const;\n\nexport const createPeriodicWaveConstructor: TPeriodicWaveConstructorFactory = (\n    createNativePeriodicWave,\n    getNativeContext,\n    periodicWaveStore,\n    sanitizePeriodicWaveOptions\n) => {\n    return class PeriodicWave<T extends TContext> implements IPeriodicWave {\n        constructor(context: T, options?: Partial<IPeriodicWaveOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n\n            periodicWaveStore.add(periodicWave);\n\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(<any>instance)\n            );\n        }\n    };\n};\n","import { IAudioParam, IStereoPannerNode, IStereoPannerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TStereoPannerNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n} as const;\n\nexport const createStereoPannerNodeConstructor: TStereoPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class StereoPannerNode<T extends TContext> extends audioNodeConstructor<T> implements IStereoPannerNode<T> {\n        private _pan: IAudioParam;\n\n        constructor(context: T, options?: Partial<IStereoPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createStereoPannerNodeRenderer() : null);\n\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n\n        get pan(): IAudioParam {\n            return this._pan;\n        }\n    };\n};\n","import { TUnknownErrorFactory } from '../types';\n\nexport const createUnknownError: TUnknownErrorFactory = () => new DOMException('', 'UnknownError');\n","import { IWaveShaperNode, IWaveShaperOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TNativeWaveShaperNode, TOverSampleType, TWaveShaperNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n} as const;\n\nexport const createWaveShaperNodeConstructor: TWaveShaperNodeConstructorFactory = (\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class WaveShaperNode<T extends TContext> extends audioNodeConstructor<T> implements IWaveShaperNode<T> {\n        private _isCurveNullified: boolean;\n\n        private _nativeWaveShaperNode: TNativeWaveShaperNode;\n\n        constructor(context: T, options?: Partial<IWaveShaperOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createWaveShaperNodeRenderer() : null);\n\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get curve(): null | Float32Array {\n            if (this._isCurveNullified) {\n                return null;\n            }\n\n            return this._nativeWaveShaperNode.curve;\n        }\n\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n\n        get oversample(): TOverSampleType {\n            return this._nativeWaveShaperNode.oversample;\n        }\n\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n","import { TGetFirstSampleFunction } from '../types';\n\nexport const getFirstSample: TGetFirstSampleFunction = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n\n    return buffer[0];\n};\n","import { TIsDCCurveFunction } from '../types';\n\nexport const isDCCurve: TIsDCCurveFunction = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n\n    const length = curve.length;\n\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n","import { TOverwriteAccessorsFunction } from '../types';\n\nexport const overwriteAccessors: TOverwriteAccessorsFunction = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n\n    const { get, set } = <Required<PropertyDescriptor>>Object.getOwnPropertyDescriptor(prototype, property);\n\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n","import { TSetValueAtTimeUntilPossibleFunction } from '../types';\n\nexport const setValueAtTimeUntilPossible: TSetValueAtTimeUntilPossibleFunction = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    } catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n\n        return true;\n    } catch {\n        return false;\n    }\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n","/*\n * Bug #122: Edge up to version v18 did not allow to construct a DOMException'. It also had a couple more bugs but since this is easy to\n * test it's used here as a placeholder.\n *\n * Bug #27: Edge up to version v18 did reject an invalid arrayBuffer passed to decodeAudioData() with a DOMException.\n *\n * Bug #50: Edge up to version v18 did not allow to create AudioNodes on a closed context.\n *\n * Bug #57: Edge up to version v18 did not throw an error when assigning the type of an OscillatorNode to 'custom'.\n *\n * Bug #63: Edge up to version v18 did not expose the mediaElement property of a MediaElementAudioSourceNode.\n *\n * Bug #64: Edge up to version v18 did not support the MediaStreamAudioDestinationNode.\n *\n * Bug #71: Edge up to version v18 did not allow to set the buffer of an AudioBufferSourceNode to null.\n *\n * Bug #93: Edge up to version v18 did set the sampleRate of an AudioContext to zero when it was closed.\n *\n * Bug #101: Edge up to version v18 refused to execute decodeAudioData() on a closed context.\n *\n * Bug #106: Edge up to version v18 did not expose the maxValue and minValue properties of the pan AudioParam of a StereoPannerNode.\n *\n * Bug #110: Edge up to version v18 did not expose the maxValue and minValue properties of the attack, knee, ratio, release and threshold AudioParams of a DynamicsCompressorNode.\n *\n * Bug #123: Edge up to version v18 did not support HRTF as the panningModel for a PannerNode.\n *\n * Bug #145: Edge up to version v18 did throw an IndexSizeError when an OfflineAudioContext was created with a sampleRate of zero.\n *\n * Bug #161: Edge up to version v18 did not expose the maxValue and minValue properties of the delayTime AudioParam of a DelayNode.\n */\nexport const testDomExceptionConstructorSupport = () => {\n    try {\n        new DOMException(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","// Safari at version 11 did not support transferables.\nexport const testTransferablesSupport = () =>\n    new Promise<boolean>((resolve) => {\n        const arrayBuffer = new ArrayBuffer(0);\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => resolve(data !== null);\n        port2.postMessage(arrayBuffer, [arrayBuffer]);\n    });\n","import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n","import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n","import {\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent\n} from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport {\n    AUDIO_NODE_CONNECTIONS_STORE,\n    AUDIO_NODE_STORE,\n    AUDIO_PARAM_CONNECTIONS_STORE,\n    AUDIO_PARAM_STORE,\n    CONTEXT_STORE,\n    CYCLE_COUNTERS\n} from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\nimport {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioContext,\n    IAudioNode,\n    IAudioWorkletNode,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IOfflineAudioContextConstructor,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IStereoPannerNode,\n    IWaveShaperNode\n} from './interfaces';\nimport {\n    TActiveAudioWorkletNodeInputsStore,\n    TAddAudioWorkletModuleFunction,\n    TAnalyserNodeConstructor,\n    TAudioBufferConstructor,\n    TAudioBufferSourceNodeConstructor,\n    TAudioBufferStore,\n    TAudioContextConstructor,\n    TAudioParamAudioNodeStore,\n    TAudioWorkletNodeConstructor,\n    TBackupOfflineAudioContextStore,\n    TBiquadFilterNodeConstructor,\n    TChannelMergerNodeConstructor,\n    TChannelSplitterNodeConstructor,\n    TConstantSourceNodeConstructor,\n    TContext,\n    TConvolverNodeConstructor,\n    TDecodeAudioDataFunction,\n    TDelayNodeConstructor,\n    TDynamicsCompressorNodeConstructor,\n    TGainNodeConstructor,\n    TIIRFilterNodeConstructor,\n    TMediaElementAudioSourceNodeConstructor,\n    TMediaStreamAudioDestinationNodeConstructor,\n    TMediaStreamAudioSourceNodeConstructor,\n    TMediaStreamTrackAudioSourceNodeConstructor,\n    TMinimalAudioContextConstructor,\n    TMinimalOfflineAudioContextConstructor,\n    TOscillatorNodeConstructor,\n    TPannerNodeConstructor,\n    TPeriodicWaveConstructor,\n    TStereoPannerNodeConstructor,\n    TUnrenderedAudioWorkletNodeStore,\n    TWaveShaperNodeConstructor\n} from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore: TAudioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(\n    createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),\n    createAddConnectionToAudioNode(\n        addActiveInputConnectionToAudioNode,\n        addPassiveInputConnectionToAudioNode,\n        connectNativeAudioNodeToNativeAudioNode,\n        deleteActiveInputConnectionToAudioNode,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getAudioNodeTailTime,\n        getEventListenersOfAudioNode,\n        getNativeAudioNode,\n        insertElementInSet,\n        isActiveAudioNode,\n        isPartOfACycle,\n        isPassiveAudioNode\n    ),\n    cacheTestResult,\n    createIncrementCycleCounterFactory(\n        CYCLE_COUNTERS,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        isActiveAudioNode\n    ),\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    createDecrementCycleCounter(\n        connectNativeAudioNodeToNativeAudioNode,\n        CYCLE_COUNTERS,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        getNativeContext,\n        isActiveAudioNode,\n        isNativeOfflineAudioContext\n    ),\n    createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey),\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n);\nconst analyserNodeConstructor: TAnalyserNodeConstructor = createAnalyserNodeConstructor(\n    audioNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\n\ntype analyserNodeConstructor<T extends TContext> = IAnalyserNode<T>;\n\nexport { analyserNodeConstructor as AnalyserNode };\n\nconst audioBufferStore: TAudioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor: TAudioBufferConstructor = createAudioBufferConstructor(\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\ntype audioBufferConstructor = IAudioBuffer;\n\nexport { audioBufferConstructor as AudioBuffer };\n\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClamping,\n    createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst createAudioParam = createAudioParamFactory(\n    createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),\n    audioParamAudioNodeStore,\n    AUDIO_PARAM_STORE,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n);\nconst audioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\n\ntype audioBufferSourceNodeConstructor<T extends TContext> = IAudioBufferSourceNode<T>;\n\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\n\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors),\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor: TBiquadFilterNodeConstructor = createBiquadFilterNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelMergerNodeConstructor: TChannelMergerNodeConstructor = createChannelMergerNodeConstructor(\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelSplitterNodeConstructor: TChannelSplitterNodeConstructor = createChannelSplitterNodeConstructor(\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst constantSourceNodeConstructor: TConstantSourceNodeConstructor = createConstantSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRenderer,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst convolverNodeConstructor: TConvolverNodeConstructor = createConvolverNodeConstructor(\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst delayNodeConstructor: TDelayNodeConstructor = createDelayNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst dynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createGainNodeRenderer = createGainNodeRendererFactory(\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst gainNodeConstructor: TGainNodeConstructor = createGainNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor)\n);\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor: TIIRFilterNodeConstructor = createIIRFilterNodeConstructor(\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createAudioListener = createAudioListenerFactory(\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n);\nconst unrenderedAudioWorkletNodeStore: TUnrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst oscillatorNodeConstructor: TOscillatorNodeConstructor = createOscillatorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst pannerNodeConstructor: TPannerNodeConstructor = createPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor: TPeriodicWaveConstructor = createPeriodicWaveConstructor(\n    createNativePeriodicWave,\n    getNativeContext,\n    new WeakSet(),\n    sanitizePeriodicWaveOptions\n);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst stereoPannerNodeConstructor: TStereoPannerNodeConstructor = createStereoPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst waveShaperNodeConstructor: TWaveShaperNodeConstructor = createWaveShaperNodeConstructor(\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore: TBackupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n);\n\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule: undefined | TAddAudioWorkletModuleFunction = isSecureContext\n    ? createAddAudioWorkletModule(\n          cacheTestResult,\n          createNotSupportedError,\n          createEvaluateSource(window),\n          exposeCurrentFrameAndCurrentTime,\n          createFetchSource(createAbortError),\n          getNativeContext,\n          getOrCreateBackupOfflineAudioContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          new WeakMap(),\n          new WeakMap(),\n          createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n          // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n          <NonNullable<typeof window>>window\n      )\n    : undefined;\n\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n\nexport const decodeAudioData: TDecodeAudioDataFunction = createDecodeAudioData(\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    new WeakSet(),\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n);\nconst mediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructor =\n    createMediaStreamAudioDestinationNodeConstructor(\n        audioNodeConstructor,\n        createNativeMediaStreamAudioDestinationNode,\n        getNativeContext,\n        isNativeOfflineAudioContext\n    );\nconst mediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructor =\n    createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor: TAudioContextConstructor = createAudioContextConstructor(\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n);\n\ntype audioContextConstructor = IAudioContext;\n\nexport { audioContextConstructor as AudioContext };\n\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore: TActiveAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor: undefined | TAudioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(\n          addUnrenderedAudioWorkletNode,\n          audioNodeConstructor,\n          createAudioParam,\n          createAudioWorkletNodeRenderer,\n          createNativeAudioWorkletNode,\n          getAudioNodeConnections,\n          getBackupOfflineAudioContext,\n          getNativeContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          sanitizeAudioWorkletNodeOptions,\n          setActiveAudioWorkletNodeInputs,\n          testAudioWorkletNodeOptionsClonability,\n          wrapEventListener\n      )\n    : undefined;\n\ntype audioWorkletNodeConstructor<T extends TContext> = undefined | IAudioWorkletNode<T>;\n\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\n\ntype biquadFilterNodeConstructor<T extends TContext> = IBiquadFilterNode<T>;\n\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\n\ntype channelMergerNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelMergerNodeConstructor as ChannelMergerNode };\n\ntype channelSplitterNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\n\ntype constantSourceNodeConstructor<T extends TContext> = IConstantSourceNode<T>;\n\nexport { convolverNodeConstructor as ConvolverNode };\n\ntype convolverNodeConstructor<T extends TContext> = IConvolverNode<T>;\n\nexport { constantSourceNodeConstructor as ConstantSourceNode };\n\ntype delayNodeConstructor<T extends TContext> = IDelayNode<T>;\n\nexport { delayNodeConstructor as DelayNode };\n\ntype dynamicsCompressorNodeConstructor<T extends TContext> = IDynamicsCompressorNode<T>;\n\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\n\ntype gainNodeConstructor<T extends TContext> = IGainNode<T>;\n\nexport { gainNodeConstructor as GainNode };\n\ntype iIRFilterNodeConstructor<T extends TContext> = IIIRFilterNode<T>;\n\nexport { iIRFilterNodeConstructor as IIRFilterNode };\n\ntype mediaElementAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaElementAudioSourceNode<T>;\n\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\n\ntype mediaStreamAudioDestinationNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioDestinationNode<T>;\n\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\n\ntype mediaStreamAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioSourceNode<T>;\n\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\n\ntype mediaStreamTrackAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamTrackAudioSourceNode<T>;\n\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\n\nconst minimalAudioContextConstructor: TMinimalAudioContextConstructor = createMinimalAudioContextConstructor(\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n);\n\ntype minimalAudioContextConstructor = IMinimalAudioContext;\n\nexport { minimalAudioContextConstructor as MinimalAudioContext };\n\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n);\nconst startRendering = createStartRendering(\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\nconst minimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n);\n\ntype minimalOfflineAudioContextConstructor = IMinimalOfflineAudioContext;\n\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\n\nconst offlineAudioContextConstructor: IOfflineAudioContextConstructor = createOfflineAudioContextConstructor(\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n);\n\ntype offlineAudioContextConstructor = IOfflineAudioContext;\n\nexport { offlineAudioContextConstructor as OfflineAudioContext };\n\ntype oscillatorNodeConstructor<T extends TContext> = IOscillatorNode<T>;\n\nexport { oscillatorNodeConstructor as OscillatorNode };\n\ntype pannerNodeConstructor<T extends TContext> = IPannerNode<T>;\n\nexport { pannerNodeConstructor as PannerNode };\n\ntype periodicWaveConstructor = IPeriodicWave;\n\nexport { periodicWaveConstructor as PeriodicWave };\n\ntype stereoPannerNodeConstructor<T extends TContext> = IStereoPannerNode<T>;\n\nexport { stereoPannerNodeConstructor as StereoPannerNode };\n\ntype waveShaperNodeConstructor<T extends TContext> = IWaveShaperNode<T>;\n\nexport { waveShaperNodeConstructor as WaveShaperNode };\n\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n\nexport const isSupported = () =>\n    createIsSupportedPromise(\n        cacheTestResult,\n        createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor),\n        createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextOptionsSupport(nativeAudioContextConstructor),\n        createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n        createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        testDomExceptionConstructorSupport,\n        createTestIsSecureContextSupport(window),\n        createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor),\n        createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor),\n        testTransferablesSupport\n    );\n","import { TAddActiveInputConnectionToAudioNodeFactory } from '../types/add-active-input-connection-to-audio-node-factory';\n\nexport const createAddActiveInputConnectionToAudioNode: TAddActiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(\n            activeInputs[input],\n            [source, output, eventListener],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n            ignoreDuplicates\n        );\n    };\n};\n","import { TAddPassiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createAddPassiveInputConnectionToAudioNode: TAddPassiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n            insertElementInSet(\n                passiveInputConnections,\n                [output, input, eventListener],\n                (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input,\n                ignoreDuplicates\n            );\n        }\n    };\n};\n","import { TDeleteActiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createDeleteActiveInputConnectionToAudioNode: TDeleteActiveInputConnectionToAudioNodeFactory = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(\n            activeInputs[input],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n        );\n    };\n};\n","import { TGetAudioNodeTailTimeFactory } from '../types';\n\nexport const createGetAudioNodeTailTime: TGetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode) => audioNodeTailTimeStore.get(audioNode) ?? 0;\n};\n","import { TCacheTestResultFactory } from '../types';\n\nexport const createCacheTestResult: TCacheTestResultFactory = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n\n        const ongoingTest = ongoingTests.get(tester);\n\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n\n        try {\n            const synchronousTestResult = test();\n\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                        ongoingTests.delete(tester);\n                        testResults.set(tester, finalTestResult);\n\n                        return finalTestResult;\n                    });\n            }\n\n            testResults.set(tester, synchronousTestResult);\n\n            return synchronousTestResult;\n        } catch {\n            testResults.set(tester, false);\n\n            return false;\n        }\n    };\n};\n","import { TWindow, TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nimport { TNativeAnalyserNodeFactoryFactory } from '../types';\n\nexport const createNativeAnalyserNodeFactory: TNativeAnalyserNodeFactoryFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (\n            !cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () =>\n                testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode)\n            )\n        ) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n\n        return nativeAnalyserNode;\n    };\n};\n","import { TNativeAnalyserNode } from '../types';\n\nexport const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode: TNativeAnalyserNode): void => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array: Float32Array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n\n        return array;\n    };\n};\n","import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGetAudioNodeRendererFactory } from '../types';\n\nexport const createGetAudioNodeRenderer: TGetAudioNodeRendererFactory = (getAudioNodeConnections) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioNode: IAudioNode<T>\n    ): IAudioNodeRenderer<T, IAudioNode<T>> => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n\n        return <IAudioNodeRenderer<T, IAudioNode<T>>>audioNodeConnections.renderer;\n    };\n};\n","import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAnalyserNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAnalyserNodeRendererFactoryFactory, TNativeAnalyserNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAnalyserNodeRendererFactory: TAnalyserNodeRendererFactoryFactory = (\n    createNativeAnalyserNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAnalyserNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAnalyserNode>();\n\n        const createAnalyserNode = async (proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode<T, TNativeAnalyserNode>(proxy);\n\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n\n            return nativeAnalyserNode;\n        };\n\n        return {\n            render(proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAnalyserNode> {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TContext, TGetNativeContextFactory, TNativeAudioContext, TNativeOfflineAudioContext } from '../types';\nimport { createInvalidStateError } from './invalid-state-error';\n\nexport const createGetNativeContext: TGetNativeContextFactory = (contextStore) => {\n    return <T extends TContext>(\n        context: T\n    ): T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext => {\n        const nativeContext = contextStore.get(context);\n\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n\n        return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext>(\n            nativeContext\n        );\n    };\n};\n","import { TNativeOfflineAudioContextConstructorFactory } from '../types';\n\nexport const createNativeOfflineAudioContextConstructor: TNativeOfflineAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? (<any>window).webkitOfflineAudioContext : null;\n};\n","import { TIsNativeOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsNativeOfflineAudioContext: TIsNativeOfflineAudioContextFactory = (nativeOfflineAudioContextConstructor) => {\n    return (anything): anything is TNativeOfflineAudioContext => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n","import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        constructor(private _nativeEventTarget: TNativeEventTarget) {\n            this._listeners = new WeakMap();\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n","import { TNativeAudioContextConstructorFactory } from '../types';\n\nexport const createNativeAudioContextConstructor: TNativeAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n\n    return window.hasOwnProperty('webkitAudioContext') ? (<any>window).webkitAudioContext : null;\n};\n","import { TIsNativeAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeAudioContext: TIsNativeAudioContextFactory = (nativeAudioContextConstructor) => {\n    return (anything): anything is TNativeAudioContext => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n","import { TIsNativeAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsNativeAudioNode: TIsNativeAudioNodeFactory = (window) => {\n    return (anything): anything is TNativeAudioNode => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n","import { TIsNativeAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsNativeAudioParam: TIsNativeAudioParamFactory = (window) => {\n    return (anything): anything is TNativeAudioParam => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n","import { TNativeAudioWorkletNodeConstructorFactory } from '../types';\n\nexport const createNativeAudioWorkletNodeConstructor: TNativeAudioWorkletNodeConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n","import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TActiveInputConnection, TAddAudioNodeConnectionsFactory, TContext, TNativeAudioNode } from '../types';\n\nexport const createAddAudioNodeConnections: TAddAudioNodeConnectionsFactory = (audioNodeConnectionsStore) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null,\n        nativeAudioNode: TNativeAudioNode\n    ) => {\n        const activeInputs = [];\n\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set<TActiveInputConnection<T>>());\n        }\n\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n","import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { IAudioNode } from '../interfaces';\nimport { TAddConnectionToAudioNodeFactory, TContext, TInternalStateEventListener } from '../types';\n\nexport const createAddConnectionToAudioNode: TAddConnectionToAudioNodeFactory = (\n    addActiveInputConnectionToAudioNode,\n    addPassiveInputConnectionToAudioNode,\n    connectNativeAudioNodeToNativeAudioNode,\n    deleteActiveInputConnectionToAudioNode,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getAudioNodeTailTime,\n    getEventListenersOfAudioNode,\n    getNativeAudioNode,\n    insertElementInSet,\n    isActiveAudioNode,\n    isPartOfACycle,\n    isPassiveAudioNode\n) => {\n    const tailTimeTimeoutIds = new WeakMap<IAudioNode<TContext>, number>();\n\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n\n        const eventListener: TInternalStateEventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            } else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                const tailTime = getAudioNodeTailTime(destination);\n\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                } else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n\n                    tailTimeTimeoutIds.set(\n                        destination,\n                        setTimeout(() => {\n                            if (isActiveAudioNode(destination)) {\n                                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                            }\n                        }, tailTime * 1000)\n                    );\n                }\n            }\n        };\n\n        if (\n            insertElementInSet(\n                outputs,\n                [destination, output, input],\n                (outputConnection) =>\n                    outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input,\n                true\n            )\n        ) {\n            eventListeners.add(eventListener);\n\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            } else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n};\n","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TIncrementCycleCounterFactoryFactory } from '../types';\n\nexport const createIncrementCycleCounterFactory: TIncrementCycleCounterFactoryFactory = (\n    cycleCounters,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    isActiveAudioNode\n) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                            disconnectNativeAudioNodeFromNativeAudioNode(\n                                nativeSourceAudioNode,\n                                nativeDestinationAudioNode,\n                                output[1],\n                                output[2]\n                            );\n                        } else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n\n                cycleCounters.set(audioNode, count);\n            } else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n","import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TDecrementCycleCounterFactory } from '../types';\n\nexport const createDecrementCycleCounter: TDecrementCycleCounterFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    cycleCounters,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    getNativeContext,\n    isActiveAudioNode,\n    isNativeOfflineAudioContext\n) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    } else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        } else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nimport { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext, TDetectCyclesFactory } from '../types';\n\nexport const createDetectCycles: TDetectCyclesFactory = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles<T extends TContext>(chain: IAudioNode<T>[], nextLink: IAudioNode<T> | IAudioParam): IAudioNode<T>[][] {\n        const audioNode = isAudioNode(nextLink) ? nextLink : <IAudioNode<T>>getValueForKey(audioParamAudioNodeStore, nextLink);\n\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n\n        const { outputs } = getAudioNodeConnections(audioNode);\n\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n","import { IAudioNode, IDelayNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isDelayNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IDelayNode<T> => {\n    return 'delayTime' in audioNode;\n};\n","import { TNativeAudioBufferConstructorFactory } from '../types';\n\nexport const createNativeAudioBufferConstructor: TNativeAudioBufferConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n\n    return null;\n};\n","import { TConvertNumberToUnsignedLongFactory } from '../types';\n\nexport const createConvertNumberToUnsignedLong: TConvertNumberToUnsignedLongFactory = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n\n        return unit32Array[0];\n    };\n};\n","import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethods: TWrapAudioBufferCopyChannelMethodsFactory = (\n    convertNumberToUnsignedLong,\n    createIndexSizeError\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n","import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethodsOutOfBounds: TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory = (\n    convertNumberToUnsignedLong\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n","import { TTestAudioBufferConstructorSupportFactory } from '../types';\n\n// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport: TTestAudioBufferConstructorSupportFactory = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n","import { TAddSilentConnectionFactory } from '../types';\n\nexport const createAddSilentConnection: TAddSilentConnectionFactory = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n","import { IAudioParam, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TNativeAudioParam, TNativeOfflineAudioContext, TRenderInputsOfAudioParamFactory } from '../types';\n\nexport const createRenderInputsOfAudioParam: TRenderInputsOfAudioParamFactory = (\n    getAudioNodeRenderer,\n    getAudioParamConnections,\n    isPartOfACycle\n) => {\n    return async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioParam: IAudioParam,\n        nativeOfflineAudioContext: TNativeOfflineAudioContext,\n        nativeAudioParam: TNativeAudioParam\n    ): Promise<void> => {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        await Promise.all(\n            Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n                const audioNodeRenderer = getAudioNodeRenderer(source);\n                const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n\n                if (!isPartOfACycle(source)) {\n                    renderedNativeAudioNode.connect(nativeAudioParam, output);\n                }\n            })\n        );\n    };\n};\n","import { TConnectAudioParamFactory } from '../types';\n\nexport const createConnectAudioParam: TConnectAudioParamFactory = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeAudioBufferSourceNodeFactory: TNativeAudioBufferSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClampling,\n    wrapAudioBufferSourceNodeStopMethodNullifiedBuffer,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n\n        // Bug #149: Safari does not yet support the detune AudioParam.\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () =>\n                testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () =>\n                testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () =>\n                testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n\n        return nativeAudioBufferSourceNode;\n    };\n};\n","import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n\n        return (when = 0, offset = 0, duration?: number) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.start();\n    } catch {\n        return true;\n    }\n\n    return false;\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n","import { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            } else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n","import { TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory } from '../types';\n\nexport const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer: TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory = (\n    overwriteAccessors\n) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n\n        overwriteAccessors(\n            nativeAudioBufferSourceNode,\n            'buffer',\n            (get) => () => {\n                const value = get.call(nativeAudioBufferSourceNode);\n\n                return value === nullifiedBuffer ? null : value;\n            },\n            (set) => (value) => {\n                return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n            }\n        );\n    };\n};\n","import { TRenderAutomationFactory } from '../types';\n\nexport const createRenderAutomation: TRenderAutomationFactory = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n\n        audioParamRenderer.replay(nativeAudioParam);\n\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n","import { IMinimalOfflineAudioContext } from '../interfaces';\nimport { TGetAudioParamRendererFactory } from '../types';\n\nexport const createGetAudioParamRenderer: TGetAudioParamRendererFactory = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections<IMinimalOfflineAudioContext>(audioParam);\n\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n\n        return audioParamConnections.renderer;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioBufferSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioBufferSourceNodeRendererFactoryFactory, TNativeAudioBufferSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAudioBufferSourceNodeRendererFactory: TAudioBufferSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode>();\n\n        let start: null | [number, number] | [number, number, number] = null;\n        let stop: null | number = null;\n\n        const createAudioBufferSourceNode = async (\n            proxy: IAudioBufferSourceNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode<T, TNativeAudioBufferSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            } else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            return nativeAudioBufferSourceNode;\n        };\n\n        return {\n            set start(value: [number, number] | [number, number, number]) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IAudioBufferSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode> {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { AutomationEventList } from 'automation-events';\nimport { IAudioNode, IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioParamFactoryFactory, TContext, TNativeAudioParam } from '../types';\n\nexport const createAudioParamFactory: TAudioParamFactoryFactory = (\n    addAudioParamConnections,\n    audioParamAudioNodeStore,\n    audioParamStore,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        isAudioParamOfOfflineAudioContext: boolean,\n        nativeAudioParam: TNativeAudioParam,\n        maxValue: null | number = null,\n        minValue: null | number = null\n    ): IAudioParam => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue(): number {\n                return defaultValue;\n            },\n            get maxValue(): number {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue(): number {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value(): number {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime: number): IAudioParam {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                } else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n\n                    const currentLastEvent = Array.from(automationEventList).pop();\n\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        } else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(\n                                currentLastEvent.values,\n                                currentLastEvent.startTime,\n                                currentLastEvent.duration\n                            );\n                        }\n                    }\n                }\n\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            linearRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            setTargetAtTime(target: number, startTime: number, timeConstant: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n\n                return audioParam;\n            },\n            setValueAtTime(value: number, startTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n\n                return audioParam;\n            },\n            setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): IAudioParam {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n\n                    const timeOfLastSample = lastSample / sampleRate;\n\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                } else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n\n                return audioParam;\n            }\n        };\n\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n\n        addAudioParamConnections(\n            audioParam,\n            <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null>audioParamRenderer\n        );\n\n        return audioParam;\n    };\n};\n","import { IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAddAudioParamConnectionsFactory, TContext } from '../types';\n\nexport const createAddAudioParamConnections: TAddAudioParamConnectionsFactory = (audioParamConnectionsStore) => {\n    return <T extends TContext>(\n        audioParam: IAudioParam,\n        audioParamRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null\n    ) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n","import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n","import { IAudioDestinationNode } from '../interfaces';\nimport {\n    TAudioDestinationNodeConstructorFactory,\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TNativeAudioDestinationNode\n} from '../types';\n\nexport const createAudioDestinationNodeConstructor: TAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n) => {\n    return class AudioDestinationNode<T extends TContext> extends audioNodeConstructor<T> implements IAudioDestinationNode<T> {\n        private _isNodeOfNativeOfflineAudioContext: boolean;\n\n        private _nativeAudioDestinationNode: TNativeAudioDestinationNode;\n\n        constructor(context: T, channelCount: number) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null)\n            );\n\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n\n        get maxChannelCount(): number {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n","import { IAudioDestinationNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TAudioDestinationNodeRendererFactory,\n    TNativeAudioDestinationNode,\n    TNativeOfflineAudioContext,\n    TRenderInputsOfAudioNodeFunction\n} from '../types';\n\nexport const createAudioDestinationNodeRenderer: TAudioDestinationNodeRendererFactory = <\n    T extends IMinimalOfflineAudioContext | IOfflineAudioContext\n>(\n    renderInputsOfAudioNode: TRenderInputsOfAudioNodeFunction\n) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioDestinationNode>();\n\n    const createAudioDestinationNode = async (proxy: IAudioDestinationNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        return nativeAudioDestinationNode;\n    };\n\n    return {\n        render(\n            proxy: IAudioDestinationNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ): Promise<TNativeAudioDestinationNode> {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n","import { TNativeAudioDestinationNode, TNativeAudioDestinationNodeFactoryFactory, TNativeGainNode } from '../types';\n\nexport const createNativeAudioDestinationNodeFactory: TNativeAudioDestinationNodeFactoryFactory = (\n    createNativeGainNode,\n    overwriteAccessors\n) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            } catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n\n        overwriteAccessors(\n            gainNode,\n            'channelCount',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n\n                try {\n                    nativeAudioDestinationNode.channelCount = value;\n                } catch (err) {\n                    // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                    if (value > nativeAudioDestinationNode.maxChannelCount) {\n                        throw err;\n                    }\n                }\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelCountMode',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelCountMode = value;\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelInterpretation',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelInterpretation = value;\n            }\n        );\n\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n\n        return <{ maxChannelCount: TNativeAudioDestinationNode['maxChannelCount'] } & TNativeGainNode>gainNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IBiquadFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TBiquadFilterNodeRendererFactoryFactory, TNativeBiquadFilterNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createBiquadFilterNodeRendererFactory: TBiquadFilterNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeBiquadFilterNodes = new WeakMap<TNativeOfflineAudioContext, TNativeBiquadFilterNode>();\n\n        const createBiquadFilterNode = async (proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode<T, TNativeBiquadFilterNode>(proxy);\n\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            return nativeBiquadFilterNode;\n        };\n\n        return {\n            render(proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeBiquadFilterNode> {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TSetAudioNodeTailTimeFactory } from '../types';\n\nexport const createSetAudioNodeTailTime: TSetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n","import { TMonitorConnectionsFactory, TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const createMonitorConnections: TMonitorConnectionsFactory = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set<[TNativeAudioNode, number, number] | [TNativeAudioParam, number]>();\n\n        nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n                const wasDisconnected = connections.size === 0;\n\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    (<(destination: TNativeAudioNode, output?: number, input?: number) => TNativeAudioNode>connect).call(\n                        nativeAudioNode,\n                        destination,\n                        output,\n                        input\n                    );\n\n                    insertElementInSet(\n                        connections,\n                        [destination, output, input],\n                        (connection) => connection[0] === destination && connection[1] === output && connection[2] === input,\n                        true\n                    );\n\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n\n                    return destination;\n                }\n\n                connect.call(nativeAudioNode, destination, output);\n\n                insertElementInSet(\n                    connections,\n                    [destination, output],\n                    (connection) => connection[0] === destination && connection[1] === output,\n                    true\n                );\n\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n\n                return;\n            };\n        })(nativeAudioNode.connect);\n\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n                const wasConnected = connections.size > 0;\n\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n\n                    connections.clear();\n                } else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    (<(output: number) => void>disconnect).call(nativeAudioNode, destinationOrOutput);\n\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                } else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        (<(destination: TNativeAudioNode, output?: number, input?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output,\n                            input\n                        );\n                    } else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        (<(destination: TNativeAudioParam, output?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output\n                        );\n                    }\n\n                    for (const connection of connections) {\n                        if (\n                            connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)\n                        ) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n\n                const isDisconnected = connections.size === 0;\n\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n\n        return nativeAudioNode;\n    };\n};\n","import { TWrapChannelMergerNodeFactory } from '../types';\n\nexport const createWrapChannelMergerNode: TWrapChannelMergerNodeFactory = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeChannelMergerNodeFactoryFactory } from '../types';\n\nexport const createNativeChannelMergerNodeFactory: TNativeChannelMergerNodeFactoryFactory = (\n    nativeAudioContextConstructor,\n    wrapChannelMergerNode\n) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n\n        return nativeChannelMergerNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelMergerNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelMergerNodeRendererFactory: TChannelMergerNodeRendererFactoryFactory = (\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelSplitterNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelSplitterNodeRendererFactory: TChannelSplitterNodeRendererFactoryFactory = (\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TSanitizeChannelSplitterOptionsFunction } from '../types';\n\nexport const sanitizeChannelSplitterOptions: TSanitizeChannelSplitterOptionsFunction = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n","import { interceptConnections } from '../helpers/intercept-connections';\nimport {\n    TNativeAudioBufferSourceNode,\n    TNativeAudioNode,\n    TNativeConstantSourceNode,\n    TNativeConstantSourceNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeConstantSourceNodeFakerFactory: TNativeConstantSourceNodeFakerFactoryFactory = (\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeConstantSourceNode['channelCountMode'] {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeConstantSourceNode['channelInterpretation'] {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context(): TNativeConstantSourceNode['context'] {\n                return gainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [];\n            },\n            get numberOfInputs(): number {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return gainNode.numberOfOutputs;\n            },\n            get offset(): TNativeConstantSourceNode['offset'] {\n                return gainNode.gain;\n            },\n            get onended(): TNativeConstantSourceNode['onended'] {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = <TNativeAudioBufferSourceNode['onended']>value;\n            },\n            addEventListener(...args: any[]): void {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0): void {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0): void {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeConstantSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeConstantSourceNodeFactory: TNativeConstantSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n\n        return nativeConstantSourceNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConstantSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConstantSourceNodeRendererFactoryFactory, TNativeConstantSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConstantSourceNodeRendererFactory: TConstantSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConstantSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConstantSourceNode>();\n\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createConstantSourceNode = async (proxy: IConstantSourceNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode<T, TNativeConstantSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            return nativeConstantSourceNode;\n        };\n\n        return {\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IConstantSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeConstantSourceNode> {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeConvolverNodeFactoryFactory } from '../types';\n\nexport const createNativeConvolverNodeFactory: TNativeConvolverNodeFactoryFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCount',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCountMode',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        return nativeConvolverNode;\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConvolverNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConvolverNodeRendererFactoryFactory, TNativeConvolverNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConvolverNodeRendererFactory: TConvolverNodeRendererFactoryFactory = (\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConvolverNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConvolverNode>();\n\n        const createConvolverNode = async (proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode<T, TNativeConvolverNode>(proxy);\n\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            }\n\n            return nativeConvolverNode;\n        };\n\n        return {\n            render(proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeConvolverNode> {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDelayNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDelayNodeRendererFactoryFactory, TNativeDelayNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDelayNodeRendererFactory: TDelayNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(maxDelayTime: number) => {\n        const renderedNativeDelayNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDelayNode>();\n\n        const createDelayNode = async (proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode<T, TNativeDelayNode>(proxy);\n\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n\n            return nativeDelayNode;\n        };\n\n        return {\n            render(proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeDelayNode> {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDynamicsCompressorNodeFactoryFactory } from '../types';\n\nexport const createNativeDynamicsCompressorNodeFactory: TNativeDynamicsCompressorNodeFactoryFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n\n        return nativeDynamicsCompressorNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDynamicsCompressorNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDynamicsCompressorNodeRendererFactoryFactory, TNativeDynamicsCompressorNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDynamicsCompressorNodeRendererFactory: TDynamicsCompressorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDynamicsCompressorNode>();\n\n        const createDynamicsCompressorNode = async (\n            proxy: IDynamicsCompressorNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode<T, TNativeDynamicsCompressorNode>(proxy);\n\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            return nativeDynamicsCompressorNode;\n        };\n\n        return {\n            render(\n                proxy: IDynamicsCompressorNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeDynamicsCompressorNode> {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IGainNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGainNodeRendererFactoryFactory, TNativeGainNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createGainNodeRendererFactory: TGainNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeGainNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode>();\n\n        const createGainNode = async (proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode<T, TNativeGainNode>(proxy);\n\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n\n            return nativeGainNode;\n        };\n\n        return {\n            render(proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeGainNode> {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IOfflineAudioCompletionEvent } from '../interfaces';\nimport { TNativeAudioBuffer, TRenderNativeOfflineAudioContextFactory } from '../types';\n\nexport const createRenderNativeOfflineAudioContext: TRenderNativeOfflineAudioContextFactory = (\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    testOfflineAudioContextCurrentTimeSupport\n) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(\n                cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)\n            ).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n\n        return new Promise<TNativeAudioBuffer>((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n\n            nativeOfflineAudioContext.oncomplete = (event: IOfflineAudioCompletionEvent) => {\n                gainNode.disconnect();\n\n                resolve(event.renderedBuffer);\n            };\n\n            gainNode.connect(nativeOfflineAudioContext.destination);\n\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n","import { TTestOfflineAudioContextCurrentTimeSupportFactory } from '../types';\n\nexport const createTestOfflineAudioContextCurrentTimeSupport: TTestOfflineAudioContextCurrentTimeSupportFactory = (\n    createNativeGainNode,\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n","import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IIIRFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TIIRFilterNodeRendererFactoryFactory,\n    TNativeAudioBuffer,\n    TNativeAudioBufferSourceNode,\n    TNativeIIRFilterNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst filterFullBuffer = (\n    renderedBuffer: TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    feedback: Iterable<number>,\n    feedforward: Iterable<number>\n) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(\n        renderedBuffer.numberOfChannels,\n        renderedBuffer.length,\n        renderedBuffer.sampleRate\n    );\n\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n\n        filterBuffer(\n            convertedFeedback,\n            feedbackLength,\n            convertedFeedforward,\n            feedforwardLength,\n            minLength,\n            xBuffer,\n            yBuffer,\n            0,\n            bufferLength,\n            input,\n            output\n        );\n    }\n\n    return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory: TIIRFilterNodeRendererFactoryFactory = (\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(feedback: Iterable<number>, feedforward: Iterable<number>) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode | TNativeIIRFilterNode>();\n\n        let filteredBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IIIRFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode: null | TNativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode<T, TNativeIIRFilterNode>(proxy);\n\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(<number[]>feedforward, <number[]>feedback);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode\n            );\n\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                        proxy.context.destination.channelCount,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n\n                const filteredBuffer = await filteredBufferPromise;\n\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n\n                return nativeAudioBufferSourceNode;\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n\n            return nativeIIRFilterNode;\n        };\n\n        return {\n            render(\n                proxy: IIIRFilterNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode | TNativeIIRFilterNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeIIRFilterNodeFactoryFactory } from '../types';\n\nexport const createNativeIIRFilterNodeFactory: TNativeIIRFilterNodeFactoryFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(<number[]>options.feedforward, <number[]>options.feedback);\n\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n\n        return nativeIIRFilterNode;\n    };\n};\n","import { createInvalidAccessError } from '../factories/invalid-access-error';\nimport { TNativeIIRFilterNode } from '../types';\n\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode: TNativeIIRFilterNode): void => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioListenerFactoryFactory } from '../types';\n\nexport const createAudioListenerFactory: TAudioListenerFactoryFactory = (\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation: [number, number, number, number, number, number] = [0, 0, -1, 0, 1, 0];\n            let lastPosition: [number, number, number] = [0, 0, 0];\n\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n\n                isScriptProcessorNodeCreated = true;\n\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation: [number, number, number, number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                        lastOrientation = orientation;\n                    }\n\n                    const positon: [number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n                        lastPosition = positon;\n                    }\n                };\n\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index: number) => (value: number) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index: number) => (value: number) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input: number, initialValue: number, setValue: (value: number) => void) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n\n                constantSourceNode.connect(channelMergerNode, 0, input);\n\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get(): number {\n                        return initialValue;\n                    }\n                });\n\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam(\n                    <any>{ context },\n                    isOffline,\n                    constantSourceNode.offset,\n                    MOST_POSITIVE_SINGLE_FLOAT,\n                    MOST_NEGATIVE_SINGLE_FLOAT\n                );\n\n                overwriteAccessors(\n                    audioParam,\n                    'value',\n                    (get) => () => get.call(audioParam),\n                    (set) => (value) => {\n                        try {\n                            set.call(audioParam, value);\n                        } catch (err) {\n                            if (err.code !== 9) {\n                                throw err;\n                            }\n                        }\n\n                        createScriptProcessorNode();\n\n                        if (isOffline) {\n                            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                            setValue(value);\n                        }\n                    }\n                );\n\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelAndHoldAtTime']>) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelScheduledValues']>) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['exponentialRampToValueAtTime']>) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['linearRampToValueAtTime']>) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setTargetAtTime']>) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueAtTime']>) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueCurveAtTime']>) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n\n                return audioParam;\n            };\n\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } =\n            nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n\n        return {\n            get forwardX(): IAudioParam {\n                return forwardX;\n            },\n            get forwardY(): IAudioParam {\n                return forwardY;\n            },\n            get forwardZ(): IAudioParam {\n                return forwardZ;\n            },\n            get positionX(): IAudioParam {\n                return positionX;\n            },\n            get positionY(): IAudioParam {\n                return positionY;\n            },\n            get positionZ(): IAudioParam {\n                return positionZ;\n            },\n            get upX(): IAudioParam {\n                return upX;\n            },\n            get upY(): IAudioParam {\n                return upY;\n            },\n            get upZ(): IAudioParam {\n                return upZ;\n            }\n        };\n    };\n};\n","import { CONTEXT_STORE } from '../globals';\nimport { IAudioDestinationNode, IAudioListener, IMinimalBaseAudioContext, IMinimalBaseAudioContextEventMap } from '../interfaces';\nimport { TAudioContextState, TContext, TEventHandler, TMinimalBaseAudioContextConstructorFactory, TNativeContext } from '../types';\n\nexport const createMinimalBaseAudioContextConstructor: TMinimalBaseAudioContextConstructorFactory = (\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n) => {\n    return class MinimalBaseAudioContext<T extends TContext>\n        extends eventTargetConstructor<IMinimalBaseAudioContextEventMap>\n        implements IMinimalBaseAudioContext<T>\n    {\n        private _destination: IAudioDestinationNode<T>;\n\n        private _listener: IAudioListener;\n\n        private _onstatechange: null | TEventHandler<T>;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext);\n\n            CONTEXT_STORE.set(<T>(<unknown>this), _nativeContext);\n\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n\n            this._destination = new audioDestinationNodeConstructor(<T>(<unknown>this), numberOfChannels);\n            this._listener = createAudioListener(<T>(<unknown>this), _nativeContext);\n            this._onstatechange = null;\n        }\n\n        get currentTime(): number {\n            return this._nativeContext.currentTime;\n        }\n\n        get destination(): IAudioDestinationNode<T> {\n            return this._destination;\n        }\n\n        get listener(): IAudioListener {\n            return this._listener;\n        }\n\n        get onstatechange(): null | TEventHandler<T> {\n            return this._onstatechange;\n        }\n\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeContext.onstatechange = wrappedListener;\n\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n\n        get sampleRate(): number {\n            return this._nativeContext.sampleRate;\n        }\n\n        get state(): TAudioContextState {\n            return this._nativeContext.state;\n        }\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeOscillatorNodeFactoryFactory } from '../types';\n\nexport const createNativeOscillatorNodeFactory: TNativeOscillatorNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n\n        return nativeOscillatorNode;\n    };\n};\n","import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IOscillatorNode, IPeriodicWave } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeOscillatorNode, TOscillatorNodeRendererFactoryFactory } from '../types';\n\nexport const createOscillatorNodeRendererFactory: TOscillatorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeOscillatorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeOscillatorNode>();\n\n        let periodicWave: null | IPeriodicWave = null;\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createOscillatorNode = async (proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode<T, TNativeOscillatorNode>(proxy);\n\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n\n            return nativeOscillatorNode;\n        };\n\n        return {\n            set periodicWave(value: null | IPeriodicWave) {\n                periodicWave = value;\n            },\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeOscillatorNode> {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TConnectedNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createConnectedNativeAudioBufferSourceNodeFactory: TConnectedNativeAudioBufferSourceNodeFactoryFactory = (\n    createNativeAudioBufferSourceNode\n) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeWaveShaperNodeFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFactory: TNativeWaveShaperNodeFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined\n        ) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n\n        overwriteAccessors(\n            nativeWaveShaperNode,\n            'curve',\n            (get) => () => get.call(nativeWaveShaperNode),\n            (set) => (value) => {\n                set.call(nativeWaveShaperNode, value);\n\n                if (isConnected) {\n                    if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(\n                            nativeContext,\n                            nativeWaveShaperNode\n                        );\n                    } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n\n                return value;\n            }\n        );\n\n        const whenConnected = () => {\n            isConnected = true;\n\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativePannerNode, TNativePannerNodeFakerFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFakerFactory: TNativePannerNodeFakerFactoryFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n) => {\n    return (\n        nativeContext,\n        {\n            coneInnerAngle,\n            coneOuterAngle,\n            coneOuterGain,\n            distanceModel,\n            maxDistance,\n            orientationX,\n            orientationY,\n            orientationZ,\n            panningModel,\n            positionX,\n            positionY,\n            positionZ,\n            refDistance,\n            rolloffFactor,\n            ...audioNodeOptions\n        }\n    ) => {\n        const pannerNode = nativeContext.createPanner();\n\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        } as const;\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n\n        let lastOrientation: [number, number, number] = [orientationX, orientationY, orientationZ];\n        let lastPosition: [number, number, number] = [positionX, positionY, positionZ];\n\n        const buffer = new Float32Array(1);\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 0),\n                getFirstSample(inputBuffer, buffer, 1),\n                getFirstSample(inputBuffer, buffer, 2)\n            ];\n\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                lastOrientation = orientation;\n            }\n\n            const positon: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 3),\n                getFirstSample(inputBuffer, buffer, 4),\n                getFirstSample(inputBuffer, buffer, 5)\n            ];\n\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n                lastPosition = positon;\n            }\n        };\n\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n\n        const nativePannerNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode(): TNativePannerNode['channelCountMode'] {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativePannerNode['channelInterpretation'] {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle(): TNativePannerNode['coneInnerAngle'] {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle(): TNativePannerNode['coneOuterAngle'] {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain(): TNativePannerNode['coneOuterGain'] {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n\n                pannerNode.coneOuterGain = value;\n            },\n            get context(): TNativePannerNode['context'] {\n                return pannerNode.context;\n            },\n            get distanceModel(): TNativePannerNode['distanceModel'] {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get maxDistance(): TNativePannerNode['maxDistance'] {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs(): number {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX(): TNativePannerNode['orientationX'] {\n                return orientationXGainNode.gain;\n            },\n            get orientationY(): TNativePannerNode['orientationY'] {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ(): TNativePannerNode['orientationZ'] {\n                return orientationZGainNode.gain;\n            },\n            get panningModel(): TNativePannerNode['panningModel'] {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX(): TNativePannerNode['positionX'] {\n                return positionXGainNode.gain;\n            },\n            get positionY(): TNativePannerNode['positionY'] {\n                return positionYGainNode.gain;\n            },\n            get positionZ(): TNativePannerNode['positionZ'] {\n                return positionZGainNode.gain;\n            },\n            get refDistance(): TNativePannerNode['refDistance'] {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor(): TNativePannerNode['rolloffFactor'] {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativePannerNodeFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFactory: TNativePannerNodeFactoryFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n\n        return nativePannerNode;\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, INativePannerNodeFaker, IOfflineAudioContext, IPannerNode } from '../interfaces';\nimport {\n    TNativeAudioBuffer,\n    TNativeGainNode,\n    TNativeOfflineAudioContext,\n    TNativePannerNode,\n    TPannerNodeRendererFactoryFactory\n} from '../types';\n\nexport const createPannerNodeRendererFactory: TPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode | TNativePannerNode>();\n\n        let renderedBufferPromise: null | Promise<TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode: null | TNativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode<T, TNativePannerNode>(proxy);\n\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            } else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        6,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all(\n                            [\n                                proxy.orientationX,\n                                proxy.orientationY,\n                                proxy.orientationZ,\n                                proxy.positionX,\n                                proxy.positionY,\n                                proxy.positionZ\n                            ].map(async (audioParam, index) => {\n                                const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: index === 0 ? 1 : 0\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n\n                                return nativeConstantSourceNode;\n                            })\n                        );\n\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n\n                const channelDatas: Float32Array[] = [];\n\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n\n                inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation: [number, number, number] = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon: [number, number, number] = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n                    if (\n                        orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])\n                    ) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n\n                        inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n\n                return nativeGainNode;\n            }\n\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n\n            return nativePannerNode;\n        };\n\n        return {\n            render(\n                proxy: IPannerNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeGainNode | TNativePannerNode> {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TNativePeriodicWaveFactoryFactory } from '../types';\n\nexport const createNativePeriodicWaveFactory: TNativePeriodicWaveFactoryFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n\n        return nativePeriodicWave;\n    };\n};\n","import { TSanitizePeriodicWaveOptionsFunction } from '../types';\n\nexport const sanitizePeriodicWaveOptions: TSanitizePeriodicWaveOptionsFunction = (options) => {\n    const { imag, real } = options;\n\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n\n    return { ...options, imag, real };\n};\n","import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeStereoPannerNodeFactoryFactory } from '../types';\n\nexport const createNativeStereoPannerNodeFactory: TNativeStereoPannerNodeFactoryFactory = (\n    createNativeStereoPannerNodeFaker,\n    createNotSupportedError\n) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n\n        return nativeStereoPannerNode;\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IStereoPannerNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeStereoPannerNode, TStereoPannerNodeRendererFactoryFactory } from '../types';\n\nexport const createStereoPannerNodeRendererFactory: TStereoPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeStereoPannerNodes = new WeakMap<TNativeOfflineAudioContext, TNativeStereoPannerNode>();\n\n        const createStereoPannerNode = async (proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode<T, TNativeStereoPannerNode>(proxy);\n\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n\n            return nativeStereoPannerNode;\n        };\n\n        return {\n            render(proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeStereoPannerNode> {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n","import { TIsSecureContextFactory } from '../types';\n\nexport const createIsSecureContext: TIsSecureContextFactory = (window) => window !== null && window.isSecureContext;\n","import { TExposeCurrentFrameAndCurrentTimeFactory } from '../types';\n\nexport const createExposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFactory = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get(): number {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get(): number {\n                    return currentTime;\n                }\n            }\n        });\n\n        try {\n            return fn();\n        } finally {\n            if (window !== null) {\n                delete (<any>window).currentFrame;\n                delete (<any>window).currentTime;\n            }\n        }\n    };\n};\n","import { TGetOrCreateBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetOrCreateBackupOfflineAudioContext: TGetOrCreateBackupOfflineAudioContextFactory = (\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n\n        return backupOfflineAudioContext;\n    };\n};\n","import { TEvaluateSourceFactory } from '../types';\n\nexport const createEvaluateSource: TEvaluateSourceFactory = (window) => {\n    return (source) =>\n        new Promise((resolve, reject) => {\n            if (window === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n\n                return;\n            }\n\n            const head = window.document.head;\n\n            if (head === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            } else {\n                const script = window.document.createElement('script');\n                // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n                const blob = new Blob([source], { type: 'application/javascript' });\n                const url = URL.createObjectURL(blob);\n\n                const originalOnErrorHandler = window.onerror;\n\n                const removeErrorEventListenerAndRevokeUrl = () => {\n                    window.onerror = originalOnErrorHandler;\n\n                    URL.revokeObjectURL(url);\n                };\n\n                window.onerror = (message, src, lineno, colno, error) => {\n                    // @todo Edge thinks the source is the one of the html document.\n                    if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                        removeErrorEventListenerAndRevokeUrl();\n                        reject(error);\n\n                        return false;\n                    }\n\n                    if (originalOnErrorHandler !== null) {\n                        return originalOnErrorHandler(message, src, lineno, colno, error);\n                    }\n                };\n\n                script.onerror = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    reject(new SyntaxError());\n                };\n                script.onload = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    resolve();\n                };\n                script.src = url;\n                script.type = 'module';\n\n                head.appendChild(script);\n            }\n        });\n};\n","import { TFetchSourceFactory } from '../types';\n\nexport const createFetchSource: TFetchSourceFactory = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        } catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n\n        throw createAbortError();\n    };\n};\n","import { TTestAudioWorkletProcessorPostMessageSupportFactory } from '../types';\n\n// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport: TTestAudioWorkletProcessorPostMessageSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            ['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n\n            // Bug #197: Safari does not deliver the messages before the promise returned by startRendering() resolves.\n            await new Promise((resolve) => setTimeout(resolve));\n        } catch {\n            // Ignore errors.\n        } finally {\n            URL.revokeObjectURL(url);\n        }\n\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n","import { TIsNativeContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeContext: TIsNativeContextFactory = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything): anything is TNativeAudioContext => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n","import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TDecodeAudioDataFactory } from '../types';\n\nexport const createDecodeAudioData: TDecodeAudioDataFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    detachedArrayBuffers,\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n\n            return Promise.reject(err);\n        }\n\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                detachArrayBuffer(audioData).catch(() => {\n                    // Ignore errors.\n                });\n\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n        }\n\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = async () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    await detachArrayBuffer(audioData);\n                } catch {\n                    // Ignore errors.\n                }\n            };\n\n            const fail = (err: DOMException | Error) => {\n                reject(err);\n                complete();\n            };\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(\n                    audioData,\n                    (audioBuffer) => {\n                        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                        if (typeof audioBuffer.copyFromChannel !== 'function') {\n                            wrapAudioBufferCopyChannelMethods(audioBuffer);\n                            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                        }\n\n                        audioBufferStore.add(audioBuffer);\n\n                        complete().then(() => resolve(audioBuffer));\n                    },\n                    (err: DOMException | Error) => {\n                        // Bug #4: Safari returns null instead of an error.\n                        if (err === null) {\n                            fail(createEncodingError());\n                        } else {\n                            fail(err);\n                        }\n                    }\n                );\n            } catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n","import { TDataCloneErrorFactory } from '../types';\n\nexport const createDataCloneError: TDataCloneErrorFactory = () => new DOMException('', 'DataCloneError');\n","import { TEncodingErrorFactory } from '../types';\n\nexport const createEncodingError: TEncodingErrorFactory = () => new DOMException('', 'EncodingError');\n","import {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioNode,\n    IAudioWorklet,\n    IBaseAudioContext,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IPeriodicWaveConstraints,\n    IStereoPannerNode,\n    IWaveShaperNode,\n    IWorkletOptions\n} from '../interfaces';\nimport { TBaseAudioContextConstructorFactory, TContext, TDecodeErrorCallback, TDecodeSuccessCallback, TNativeContext } from '../types';\n\nexport const createBaseAudioContextConstructor: TBaseAudioContextConstructorFactory = (\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n) => {\n    return class BaseAudioContext<T extends TContext> extends minimalBaseAudioContextConstructor<T> implements IBaseAudioContext<T> {\n        private _audioWorklet: undefined | IAudioWorklet;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext, numberOfChannels);\n\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                          addModule: (moduleURL: string, options?: IWorkletOptions) => {\n                              return addAudioWorkletModule(<T>(<unknown>this), moduleURL, options);\n                          }\n                      };\n        }\n\n        get audioWorklet(): undefined | IAudioWorklet {\n            return this._audioWorklet;\n        }\n\n        public createAnalyser(): IAnalyserNode<T> {\n            return new analyserNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBiquadFilter(): IBiquadFilterNode<T> {\n            return new biquadFilterNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBuffer(numberOfChannels: number, length: number, sampleRate: number): IAudioBuffer {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n\n        public createBufferSource(): IAudioBufferSourceNode<T> {\n            return new audioBufferSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createChannelMerger(numberOfInputs = 6): IAudioNode<T> {\n            return new channelMergerNodeConstructor(<T>(<unknown>this), { numberOfInputs });\n        }\n\n        public createChannelSplitter(numberOfOutputs = 6): IAudioNode<T> {\n            return new channelSplitterNodeConstructor(<T>(<unknown>this), { numberOfOutputs });\n        }\n\n        public createConstantSource(): IConstantSourceNode<T> {\n            return new constantSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createConvolver(): IConvolverNode<T> {\n            return new convolverNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createDelay(maxDelayTime = 1): IDelayNode<T> {\n            return new delayNodeConstructor(<T>(<unknown>this), { maxDelayTime });\n        }\n\n        public createDynamicsCompressor(): IDynamicsCompressorNode<T> {\n            return new dynamicsCompressorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createGain(): IGainNode<T> {\n            return new gainNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIIRFilterNode<T> {\n            return new iIRFilterNodeConstructor(<T>(<unknown>this), { feedback, feedforward });\n        }\n\n        public createOscillator(): IOscillatorNode<T> {\n            return new oscillatorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPanner(): IPannerNode<T> {\n            return new pannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPeriodicWave(\n            real: Iterable<number>,\n            imag: Iterable<number>,\n            constraints: Partial<IPeriodicWaveConstraints> = { disableNormalization: false }\n        ): IPeriodicWave {\n            return new periodicWaveConstructor(<T>(<unknown>this), { ...constraints, imag, real });\n        }\n\n        public createStereoPanner(): IStereoPannerNode<T> {\n            return new stereoPannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createWaveShaper(): IWaveShaperNode<T> {\n            return new waveShaperNodeConstructor(<T>(<unknown>this));\n        }\n\n        public decodeAudioData(\n            audioData: ArrayBuffer,\n            successCallback?: TDecodeSuccessCallback,\n            errorCallback?: TDecodeErrorCallback\n        ): Promise<IAudioBuffer> {\n            return decodeAudioData(this._nativeContext, audioData).then(\n                (audioBuffer) => {\n                    if (typeof successCallback === 'function') {\n                        successCallback(audioBuffer);\n                    }\n\n                    return audioBuffer;\n                },\n                (err) => {\n                    if (typeof errorCallback === 'function') {\n                        errorCallback(err);\n                    }\n\n                    throw err;\n                }\n            );\n        }\n    };\n};\n","import { IAudioContext, IMediaElementAudioSourceNode, IMediaElementAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaElementAudioSourceNodeConstructorFactory, TNativeMediaElementAudioSourceNode } from '../types';\n\nexport const createMediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaElementAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaElementAudioSourceNode<T> {\n        private _nativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNode;\n\n        constructor(context: T, options: IMediaElementAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n\n            super(context, true, nativeMediaElementAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n\n        get mediaElement(): HTMLMediaElement {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n","import { TNativeMediaElementAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNodeFactory = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeMediaStreamAudioDestinationNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNodeFactory = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n};\n","import { IAudioContext, IMediaStreamAudioSourceNode, IMediaStreamAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioSourceNodeConstructorFactory, TNativeMediaStreamAudioSourceNode } from '../types';\n\nexport const createMediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioSourceNode<T> {\n        private _nativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNode;\n\n        constructor(context: T, options: IMediaStreamAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            super(context, true, nativeMediaStreamAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n\n        get mediaStream(): MediaStream {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n","import { TNativeMediaStreamAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNodeFactory = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n\n    return nativeMediaStreamAudioSourceNode;\n};\n","import { TNativeMediaStreamTrackAudioSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeMediaStreamTrackAudioSourceNodeFactory: TNativeMediaStreamTrackAudioSourceNodeFactoryFactory = (\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n","import { IAudioContext, IMediaStreamTrackAudioSourceNode, IMediaStreamTrackAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamTrackAudioSourceNodeConstructorFactory } from '../types';\n\nexport const createMediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamTrackAudioSourceNode,\n    getNativeContext\n) => {\n    return class MediaStreamTrackAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamTrackAudioSourceNode<T> {\n        constructor(context: T, options: IMediaStreamTrackAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, <TAudioNodeRenderer<T>>null);\n        }\n    };\n};\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport {\n    IAudioContext,\n    IAudioContextOptions,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode\n} from '../interfaces';\nimport { TAudioContextConstructorFactory, TAudioContextState, TNativeAudioContext, TNativeGainNode, TNativeOscillatorNode } from '../types';\n\nexport const createAudioContextConstructor: TAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class AudioContext extends baseAudioContextConstructor<IAudioContext> implements IAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public createMediaElementSource(mediaElement: HTMLMediaElement): IMediaElementAudioSourceNode<this> {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n\n        public createMediaStreamDestination(): IMediaStreamAudioDestinationNode<this> {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n\n        public createMediaStreamSource(mediaStream: MediaStream): IMediaStreamAudioSourceNode<this> {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n\n        public createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): IMediaStreamTrackAudioSourceNode<this> {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n","import { TGetUnrenderedAudioWorkletNodesFactory } from '../types';\n\nexport const createGetUnrenderedAudioWorkletNodes: TGetUnrenderedAudioWorkletNodesFactory = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n\n        return unrenderedAudioWorkletNodes;\n    };\n};\n","import { TAddUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createAddUnrenderedAudioWorkletNode: TAddUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n","import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TConnectMultipleOutputsFactory } from '../types';\n\nexport const createConnectMultipleOutputs: TConnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n","import { TDeleteUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createDeleteUnrenderedAudioWorkletNode: TDeleteUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n","import { TActiveInputConnection, TContext, TGetActiveAudioWorkletNodeInputsFactory, TNativeAudioWorkletNode } from '../types';\n\nexport const createGetActiveAudioWorkletNodeInputs: TGetActiveAudioWorkletNodeInputsFactory = (\n    activeAudioWorkletNodeInputsStore,\n    getValueForKey\n) => {\n    return <T extends TContext>(nativeAudioWorkletNode: TNativeAudioWorkletNode) =>\n        <Set<TActiveInputConnection<T>>[]>getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { IAudioWorkletProcessor } from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeFakerFactoryFactory,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeConstantSourceNode,\n    TNativeGainNode\n} from '../types';\n\nexport const createNativeAudioWorkletNodeFakerFactory: TNativeAudioWorkletNodeFakerFactoryFactory = (\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters =\n            processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n\n        const messageChannel = new MessageChannel();\n        const gainNodes: TNativeGainNode[] = [];\n        const inputChannelSplitterNodes: TNativeChannelSplitterNode[] = [];\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(\n                createNativeGainNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                })\n            );\n            inputChannelSplitterNodes.push(\n                createNativeChannelSplitterNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                })\n            );\n        }\n\n        const constantSourceNodes: TNativeConstantSourceNode[] = [];\n\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset:\n                        options.parameterData[name] !== undefined\n                            ? options.parameterData[name]\n                            : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(\n            nativeContext,\n            bufferSize,\n            numberOfInputChannels + numberOfParameters,\n            // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n            Math.max(1, numberOfOutputChannels)\n        );\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(\n                createNativeChannelMergerNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                })\n            );\n        }\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n\n        const parameterMap = new ReadOnlyMap(\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                      const constantSourceNode = constantSourceNodes[index];\n\n                      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                      constantSourceNode.start(0);\n\n                      return <[string, TNativeAudioParam]>[name, constantSourceNode.offset];\n                  })\n        );\n\n        inputChannelMergerNode.connect(scriptProcessorNode);\n\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode(): TNativeAudioWorkletNode['channelCountMode'] {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation(): TNativeAudioWorkletNode['channelInterpretation'] {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n\n                channelInterpretation = value;\n            },\n            get context(): TNativeAudioWorkletNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return gainNodes;\n            },\n            get numberOfInputs(): number {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror(): TNativeAudioWorkletNode['onprocessorerror'] {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n\n                onprocessorerror = typeof value === 'function' ? value : null;\n\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters(): TNativeAudioWorkletNode['parameters'] {\n                return parameterMap;\n            },\n            get port(): TNativeAudioWorkletNode['port'] {\n                return messageChannel.port2;\n            },\n            addEventListener(...args: any[]): void {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        const patchedEventListeners: Map<EventListenerOrEventListenerObject, NonNullable<MessagePort['onmessage']>> = new Map();\n\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener =\n                        typeof args[1] === 'function'\n                            ? args[1]\n                            : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                        if (patchedEventListener !== undefined) {\n                            args[1] = <EventListenerOrEventListenerObject>patchedEventListener;\n                        } else {\n                            args[1] = (event: Event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                                    unpatchedEventListener(event)\n                                );\n                            };\n\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args: any[]): void => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n\n                        args[1] = patchedEventListener;\n                    }\n                }\n\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n\n        let onmessage: MessagePort['onmessage'] = null;\n\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n\n                onmessage = typeof value === 'function' ? value : null;\n\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n\n        processorConstructor.prototype.port = messageChannel.port1;\n\n        let audioWorkletProcessor: null | IAudioWorkletProcessor = null;\n\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(\n            nativeContext,\n            nativeAudioWorkletNodeFaker,\n            processorConstructor,\n            options\n        );\n\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters: { [name: string]: Float32Array } =\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.reduce(\n                      (prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n                      {}\n                  );\n\n        let isActive = true;\n\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n\n        const activeInputIndexes = new Map<number, number>();\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }: AudioProcessingEvent) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n\n                                return input;\n                            }\n\n                            const count = activeInputIndexes.get(index);\n\n                            if (count === undefined) {\n                                return [];\n                            }\n\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                } else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n\n                            return input;\n                        });\n\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                            nativeContext.currentTime + i / nativeContext.sampleRate,\n                            nativeContext.sampleRate,\n                            () => (<IAudioWorkletProcessor>audioWorkletProcessor).process(potentiallyEmptyInputs, outputs, parameters)\n                        );\n\n                        isActive = activeSourceFlag;\n\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    } catch (error) {\n                        isActive = false;\n\n                        nativeAudioWorkletNodeFaker.dispatchEvent(\n                            new ErrorEvent('processorerror', {\n                                colno: error.colno,\n                                filename: error.filename,\n                                lineno: error.lineno,\n                                message: error.message\n                            })\n                        );\n                    }\n\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        } else {\n                            disconnectFakeGraph();\n                        }\n\n                        break;\n                    }\n                }\n            }\n        };\n\n        let isConnected = false;\n\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n\n            isConnected = false;\n        };\n\n        connectFakeGraph();\n\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TNativeAudioWorkletNode, TNativeContext } from '../types';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\n\nexport const createAudioWorkletProcessor = (\n    nativeContext: TNativeContext,\n    nativeAudioWorkletNode: TNativeAudioWorkletNode,\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n\n    return audioWorkletProcessorPromise;\n};\n","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nimport { TNativeAudioWorkletNode, TNativeAudioWorkletNodeFactoryFactory, TNativeAudioWorkletNodeOptions } from '../types';\n\nexport const createNativeAudioWorkletNodeFactory: TNativeAudioWorkletNodeFactoryFactory = (\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(\n                    nativeContext,\n                    name,\n                    <TNativeAudioWorkletNodeOptions>options\n                );\n                const patchedEventListeners: Map<\n                    EventListenerOrEventListenerObject,\n                    NonNullable<TNativeAudioWorkletNode['onprocessorerror']>\n                > = new Map();\n\n                let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n\n                            onprocessorerror = typeof value === 'function' ? value : null;\n\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener =\n                                typeof args[1] === 'function'\n                                    ? args[1]\n                                    : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                } else {\n                                    args[1] = (event: Event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n\n                                            unpatchedEventListener(event);\n                                        } else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args: any[]): void => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n\n                                args[1] = patchedEventListener;\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n\n                return nativeAudioWorkletNode;\n            } catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n        }\n\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n\n        testClonabilityOfAudioWorkletNodeOptions(options);\n\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n","import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): void => {\n    const { port1 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n    }\n};\n","import { TGetBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetBackupOfflineAudioContext: TGetBackupOfflineAudioContextFactory = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n","import { TSetActiveAudioWorkletNodeInputsFactory } from '../types';\n\nexport const createSetActiveAudioWorkletNodeInputs: TSetActiveAudioWorkletNodeInputsFactory = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n","import { TSanitizeAudioWorkletNodeOptionsFunction } from '../types';\n\nexport const sanitizeAudioWorkletNodeOptions: TSanitizeAudioWorkletNodeOptionsFunction = (options) => {\n    return {\n        ...options,\n        outputChannelCount:\n            options.outputChannelCount !== undefined\n                ? options.outputChannelCount\n                : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                  [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n","import { TTestAudioWorkletNodeOptionsClonabilityFunction } from '../types';\n\nexport const testAudioWorkletNodeOptionsClonability: TTestAudioWorkletNodeOptionsClonabilityFunction = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n        port2.close();\n    }\n};\n","import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport { IAudioContextOptions, IMinimalAudioContext } from '../interfaces';\nimport {\n    TAudioContextState,\n    TMinimalAudioContextConstructorFactory,\n    TNativeAudioContext,\n    TNativeGainNode,\n    TNativeOscillatorNode\n} from '../types';\n\nexport const createMinimalAudioContextConstructor: TMinimalAudioContextConstructorFactory = (\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor<IMinimalAudioContext> implements IMinimalAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n","import { TCreateNativeOfflineAudioContextFactory } from '../types';\n\nexport const createCreateNativeOfflineAudioContext: TCreateNativeOfflineAudioContextFactory = (\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n\n            throw err;\n        }\n    };\n};\n","import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TStartRenderingFactory } from '../types';\n\nexport const createStartRendering: TStartRenderingFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (destination, nativeOfflineAudioContext) =>\n        getAudioNodeRenderer(destination)\n            .render(destination, nativeOfflineAudioContext)\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n             * destination.\n             */\n            .then(() =>\n                Promise.all(\n                    Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) =>\n                        getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)\n                    )\n                )\n            )\n            .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n            .then((audioBuffer) => {\n                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                if (typeof audioBuffer.copyFromChannel !== 'function') {\n                    wrapAudioBufferCopyChannelMethods(audioBuffer);\n                    wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                } else if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n};\n","import { IAudioContext, IMinimalAudioContext } from '../interfaces';\nimport { TIsAnyAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsAnyAudioContext: TIsAnyAudioContextFactory = (contextStore, isNativeAudioContext) => {\n    return (anything): anything is IAudioContext | IMinimalAudioContext | TNativeAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n","import { IAudioNode } from '../interfaces';\nimport { TIsAnyAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsAnyAudioNode: TIsAnyAudioNodeFactory = (audioNodeStore, isNativeAudioNode) => {\n    return (anything): anything is IAudioNode<any> | TNativeAudioNode => audioNodeStore.has(<any>anything) || isNativeAudioNode(anything);\n};\n","import { IAudioParam } from '../interfaces';\nimport { TIsAnyAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsAnyAudioParam: TIsAnyAudioParamFactory = (audioParamStore, isNativeAudioParam) => {\n    return (anything): anything is IAudioParam | TNativeAudioParam => audioParamStore.has(<any>anything) || isNativeAudioParam(anything);\n};\n","import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TIsAnyOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsAnyOfflineAudioContext: TIsAnyOfflineAudioContextFactory = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything): anything is IMinimalOfflineAudioContext | IOfflineAudioContext | TNativeOfflineAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n","import { TIsSupportedPromiseFactory } from '../types';\n\nexport const createIsSupportedPromise: TIsSupportedPromiseFactory = async (\n    cacheTestResult,\n    testAudioBufferCopyChannelMethodsSubarraySupport,\n    testAudioContextCloseMethodSupport,\n    testAudioContextDecodeAudioDataMethodTypeErrorSupport,\n    testAudioContextOptionsSupport,\n    testAudioNodeConnectMethodSupport,\n    testAudioWorkletProcessorNoOutputsSupport,\n    testChannelMergerNodeChannelCountSupport,\n    testConstantSourceNodeAccurateSchedulingSupport,\n    testConvolverNodeBufferReassignabilitySupport,\n    testConvolverNodeChannelCountSupport,\n    testDomExceptionContrucorSupport,\n    testIsSecureContextSupport,\n    testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport,\n    testStereoPannerNodeDefaultValueSupport,\n    testTransferablesSupport\n) => {\n    if (\n        cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) &&\n        cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) &&\n        cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) &&\n        cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) &&\n        cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) &&\n        cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) &&\n        cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) &&\n        cacheTestResult(testConvolverNodeChannelCountSupport, testConvolverNodeChannelCountSupport) &&\n        cacheTestResult(testDomExceptionContrucorSupport, testDomExceptionContrucorSupport) &&\n        cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) &&\n        cacheTestResult(\n            testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport,\n            testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport\n        )\n    ) {\n        const results = await Promise.all([\n            cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport),\n            cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport),\n            cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport),\n            cacheTestResult(testTransferablesSupport, testTransferablesSupport)\n        ]);\n\n        return results.every((result) => result);\n    }\n\n    return false;\n};\n","import { TTestAudioBufferCopyChannelMethodsSubarraySupportFactory } from '../types';\n\n/*\n * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n * is enough to know if the other one is supported as well.\n */\nexport const createTestAudioBufferCopyChannelMethodsSubarraySupport: TTestAudioBufferCopyChannelMethodsSubarraySupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100);\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        if (nativeAudioBuffer.copyToChannel === undefined) {\n            return true;\n        }\n\n        const source = new Float32Array(2);\n\n        try {\n            nativeAudioBuffer.copyFromChannel(source, 0, 0);\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n","import { TTestAudioContextCloseMethodSupportFactory } from '../types';\n\nexport const createTestAudioContextCloseMethodSupport: TTestAudioContextCloseMethodSupportFactory = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n\n        // Try to check the prototype before constructing the AudioContext.\n        if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n            return true;\n        }\n\n        const audioContext = new nativeAudioContextConstructor();\n\n        const isAudioContextClosable = audioContext.close !== undefined;\n\n        try {\n            audioContext.close();\n        } catch {\n            // Ignore errors.\n        }\n\n        return isAudioContextClosable;\n    };\n};\n","import { TTestAudioContextDecodeAudioDataMethodTypeErrorSupportFactory } from '../types';\n\n/**\n * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n * did not refuse to decode invalid parameters with a TypeError.\n */\nexport const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport: TTestAudioContextDecodeAudioDataMethodTypeErrorSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            let isPending = true;\n\n            const resolvePromise = (err: Error) => {\n                if (isPending) {\n                    isPending = false;\n\n                    offlineAudioContext.startRendering();\n\n                    resolve(err instanceof TypeError);\n                }\n            };\n\n            let promise;\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                promise = offlineAudioContext\n                    // Bug #1: Safari requires a successCallback.\n                    .decodeAudioData(\n                        <any>null,\n                        () => {\n                            // Ignore the success callback.\n                        },\n                        resolvePromise\n                    );\n            } catch (err) {\n                resolvePromise(err);\n            }\n\n            // Bug #21: Safari does not support promises yet.\n            if (promise !== undefined) {\n                // Bug #6: Chrome, Edge and Firefox do not call the errorCallback.\n                promise.catch(resolvePromise);\n            }\n        });\n    };\n};\n","import { TTestAudioContextOptionsSupportFactory } from '../types';\n\nexport const createTestAudioContextOptionsSupport: TTestAudioContextOptionsSupportFactory = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n\n        let audioContext;\n\n        try {\n            audioContext = new nativeAudioContextConstructor({ latencyHint: 'balanced' });\n        } catch {\n            return false;\n        }\n\n        audioContext.close();\n\n        return true;\n    };\n};\n","import { TTestAudioNodeConnectMethodSupportFactory } from '../types';\n\n// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\nexport const createTestAudioNodeConnectMethodSupport: TTestAudioNodeConnectMethodSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeGainNode = nativeOfflineAudioContext.createGain();\n        const isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n\n        nativeGainNode.disconnect(nativeGainNode);\n\n        return isSupported;\n    };\n};\n","import { TTestAudioWorkletProcessorNoOutputsSupportFactory } from '../types';\n\n/**\n * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n * enabled by default in version 66.\n */\nexport const createTestAudioWorkletProcessorNoOutputsSupport: TTestAudioWorkletProcessorNoOutputsSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            [\n                'let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor(\"a\",A)'\n            ],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        const messageChannel = new MessageChannel();\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isCallingProcess = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            await new Promise<void>((resolve) => {\n                audioWorkletNode.port.onmessage = () => resolve();\n                audioWorkletNode.port.postMessage(messageChannel.port2, [messageChannel.port2]);\n            });\n\n            audioWorkletNode.port.onmessage = () => (isCallingProcess = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n\n            isCallingProcess = await new Promise((resolve) => {\n                messageChannel.port1.onmessage = ({ data }) => resolve(data === 1);\n                messageChannel.port1.postMessage(0);\n            });\n        } catch {\n            // Ignore errors.\n        } finally {\n            messageChannel.port1.close();\n            URL.revokeObjectURL(url);\n        }\n\n        return isCallingProcess;\n    };\n};\n","import { TTestChannelMergerNodeChannelCountSupportFactory } from '../types';\n\n/**\n * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n */\nexport const createTestChannelMergerNodeChannelCountSupport: TTestChannelMergerNodeChannelCountSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeChannelMergerNode = offlineAudioContext.createChannelMerger();\n\n        /**\n         * Bug #15: Safari does not return the default properties. It still needs to be patched. This test is supposed to test the support\n         * in other browsers.\n         */\n        if (nativeChannelMergerNode.channelCountMode === 'max') {\n            return true;\n        }\n\n        try {\n            nativeChannelMergerNode.channelCount = 2;\n        } catch {\n            return true;\n        }\n\n        return false;\n    };\n};\n","import { TTestConstantSourceNodeAccurateSchedulingSupportFactory } from '../types';\n\nexport const createTestConstantSourceNodeAccurateSchedulingSupport: TTestConstantSourceNodeAccurateSchedulingSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return true;\n        }\n\n        const nativeConstantSourceNode = nativeOfflineAudioContext.createConstantSource();\n\n        /*\n         * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n         * the implementation of Firefox right now, but it could probably be done in a better way.\n         */\n        return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n    };\n};\n","import { TTestConvolverNodeBufferReassignabilitySupportFactory } from '../types';\n\n// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\nexport const createTestConvolverNodeBufferReassignabilitySupport: TTestConvolverNodeBufferReassignabilitySupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeConvolverNode = offlineAudioContext.createConvolver();\n\n        nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n\n        try {\n            nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n","import { TTestConvolverNodeChannelCountSupportFactory } from '../types';\n\n// Chrome up to version v80, Edge up to version v80 and Opera up to version v67 did not allow to set the channelCount property of a ConvolverNode to 1. They also did not allow to set the channelCountMode to 'explicit'.\nexport const createTestConvolverNodeChannelCountSupport: TTestConvolverNodeChannelCountSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeConvolverNode = offlineAudioContext.createConvolver();\n\n        try {\n            nativeConvolverNode.channelCount = 1;\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n","import { TTestIsSecureContextSupportFactory } from '../types';\n\nexport const createTestIsSecureContextSupport: TTestIsSecureContextSupportFactory = (window) => {\n    return () => window !== null && window.hasOwnProperty('isSecureContext');\n};\n","import { TTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupportFactory } from '../types';\n\n// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\nexport const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport: TTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupportFactory =\n    (nativeAudioContextConstructor) => {\n        return () => {\n            if (nativeAudioContextConstructor === null) {\n                return false;\n            }\n\n            const audioContext = new nativeAudioContextConstructor();\n\n            try {\n                audioContext.createMediaStreamSource(new MediaStream());\n\n                return false;\n            } catch (err) {\n                return true;\n            } finally {\n                audioContext.close();\n            }\n        };\n    };\n","import { TTestStereoPannerNodeDefaultValueSupportFactory } from '../types';\n\n/**\n * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n */\nexport const createTestStereoPannerNodeDefaultValueSupport: TTestStereoPannerNodeDefaultValueSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        /*\n         * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n         * support the tested behaviour.\n         */\n        if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n            return Promise.resolve(true);\n        }\n\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return Promise.resolve(true);\n        }\n\n        const constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        const stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n\n        constantSourceNode.channelCount = 1;\n        constantSourceNode.offset.value = 1;\n\n        stereoPanner.channelCount = 1;\n\n        constantSourceNode.start();\n\n        constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n\n        return nativeOfflineAudioContext.startRendering().then((buffer) => buffer.getChannelData(0)[0] !== 1);\n    };\n};\n","import { Note } from \"../type/Units.js\";\n\n/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn arg === undefined;\n}\n\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn arg !== undefined;\n}\n\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn typeof arg === \"number\";\n}\n\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (\n\t\tObject.prototype.toString.call(arg) === \"[object Object]\" &&\n\t\targ.constructor === Object\n\t);\n}\n\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn typeof arg === \"boolean\";\n}\n\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn Array.isArray(arg);\n}\n\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn typeof arg === \"string\";\n}\n\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { isUndef } from \"./TypeCheck.js\";\nimport type { BaseContext } from \"../context/BaseContext.js\";\nimport type { Time } from \"../type/Units.js\";\n\n/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement: boolean, error: string): asserts statement {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value: number, gte: number, lte = Infinity): void {\n\tif (!(gte <= value && value <= lte)) {\n\t\tthrow new RangeError(\n\t\t\t`Value must be within [${gte}, ${lte}], got: ${value}`\n\t\t);\n\t}\n}\n\n/**\n * Warn if the context is not running.\n */\nexport function assertContextRunning(context: BaseContext): void {\n\t// add a warning if the context is not started\n\tif (!context.isOffline && context.state !== \"running\") {\n\t\twarn(\n\t\t\t'The AudioContext is \"suspended\". Invoke Tone.start() from a user action to start the audio.'\n\t\t);\n\t}\n}\n\n/**\n * If it is currently inside a scheduled callback\n */\nlet isInsideScheduledCallback = false;\nlet printedScheduledWarning = false;\n\n/**\n * Notify that the following block of code is occurring inside a Transport callback.\n */\nexport function enterScheduledCallback(insideCallback: boolean): void {\n\tisInsideScheduledCallback = insideCallback;\n}\n\n/**\n * Make sure that a time was passed into\n */\nexport function assertUsedScheduleTime(time?: Time): void {\n\tif (\n\t\tisUndef(time) &&\n\t\tisInsideScheduledCallback &&\n\t\t!printedScheduledWarning\n\t) {\n\t\tprintedScheduledWarning = true;\n\t\twarn(\n\t\t\t\"Events scheduled inside of scheduled callbacks should use the passed in scheduling time. See https://github.com/Tonejs/Tone.js/wiki/Accurate-Timing\"\n\t\t);\n\t}\n}\n\n/**\n * A basic logging interface\n */\ninterface Logger {\n\tlog: (args?: any[]) => void;\n\twarn: (args?: any[]) => void;\n}\n\n/**\n * The default logger is the console\n */\nlet defaultLogger: Logger = console;\n\n/**\n * Set the logging interface\n */\nexport function setLogger(logger: Logger): void {\n\tdefaultLogger = logger;\n}\n\n/**\n * Log anything\n */\nexport function log(...args: any[]): void {\n\tdefaultLogger.log(...args);\n}\n\n/**\n * Warn anything\n */\nexport function warn(...args: any[]): void {\n\tdefaultLogger.warn(...args);\n}\n","import {\n\tAudioContext as stdAudioContext,\n\tAudioWorkletNode as stdAudioWorkletNode,\n\tOfflineAudioContext as stdOfflineAudioContext,\n} from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\n\n/**\n * Create a new AudioContext\n */\nexport function createAudioContext(\n\toptions?: AudioContextOptions\n): AudioContext {\n\treturn new stdAudioContext(options) as unknown as AudioContext;\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(\n\tchannels: number,\n\tlength: number,\n\tsampleRate: number\n): OfflineAudioContext {\n\treturn new stdOfflineAudioContext(\n\t\tchannels,\n\t\tlength,\n\t\tsampleRate\n\t) as unknown as OfflineAudioContext;\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n\tBaseAudioContext: any;\n\tAudioWorkletNode: any;\n}\n\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow: ToneWindow | null =\n\ttypeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext =\n\ttheWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") ||\n\t\ttheWindow.hasOwnProperty(\"webkitAudioContext\"));\n\nexport function createAudioWorkletNode(\n\tcontext: AnyAudioContext,\n\tname: string,\n\toptions?: Partial<AudioWorkletNodeOptions>\n): AudioWorkletNode {\n\tassert(\n\t\tisDefined(stdAudioWorkletNode),\n\t\t\"AudioWorkletNode only works in a secure context (https or localhost)\"\n\t);\n\treturn new (\n\t\tcontext instanceof theWindow?.BaseAudioContext\n\t\t\t? theWindow?.AudioWorkletNode\n\t\t\t: stdAudioWorkletNode\n\t)(context, name, options);\n}\n\n/**\n * This promise resolves to a boolean which indicates if the\n * functionality is supported within the currently used browse.\n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\nexport { isSupported as supported } from \"standardized-audio-context\";\n","import { Seconds } from \"../type/Units.js\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval!: Seconds;\n\n\t/**\n\t * The lowest allowable interval, preferably calculated from context sampleRate\n\t */\n\tprivate _minimumUpdateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(\n\t\tcallback: () => void,\n\t\ttype: TickerClockSource,\n\t\tupdateInterval: Seconds,\n\t\tcontextSampleRate?: number\n\t) {\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._minimumUpdateInterval = Math.max(\n\t\t\t128 / (contextSampleRate || 44100),\n\t\t\t0.001\n\t\t);\n\t\tthis.updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\t\tconst blob = new Blob(\n\t\t\t[\n\t\t\t\t/* javascript */ `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`,\n\t\t\t],\n\t\t\t{ type: \"text/javascript\" }\n\t\t);\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, this._minimumUpdateInterval);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker?.postMessage(this._updateInterval * 1000);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import {\n\tAudioBuffer,\n\tisAnyAudioContext,\n\tisAnyAudioNode,\n\tisAnyAudioParam,\n\tisAnyOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn isAnyAudioParam(arg);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn isAnyAudioNode(arg);\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn isAnyOfflineAudioContext(arg);\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn isAnyAudioContext(arg);\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof AudioBuffer;\n}\n","import {\n\tisAudioBuffer,\n\tisAudioNode,\n\tisAudioParam,\n} from \"./AdvancedTypeCheck.js\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck.js\";\nimport type { BaseToneOptions } from \"../Tone.js\";\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn (\n\t\tkey === \"value\" ||\n\t\tisAudioParam(arg) ||\n\t\tisAudioNode(arg) ||\n\t\tisAudioBuffer(arg)\n\t);\n}\n\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V\n): T & U & V;\nexport function deepMerge<T, U, V, W>(\n\ttarget: T,\n\tsource1: U,\n\tsource2: V,\n\tsource3: W\n): T & U & V & W;\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target;\n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} });\n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals<T>(arrayA: T[], arrayB: T[]): boolean {\n\treturn (\n\t\tarrayA.length === arrayB.length &&\n\t\tarrayA.every((element, index) => arrayB[index] === element)\n\t);\n}\n\n/**\n * Convert an args array into an object.\n * @internal\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: Array<keyof T> = [],\n\tobjKey?: keyof T\n): T {\n\tconst opts: Partial<T> = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some((key) =>\n\t\t\tReflect.has(defaults, key)\n\t\t);\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n * @internal\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(\n\tobj: T,\n\tomit: O\n): Omit<T, keyof O> {\n\tomit.forEach((prop) => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2024 Yotam Mann\n */\nimport { version } from \"../version.js\";\nimport { theWindow } from \"./context/AudioContext.js\";\nimport { log } from \"./util/Debug.js\";\n\n//-------------------------------------\n// \tTONE\n//-------------------------------------\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n * Tone is the base class of all other classes.\n *\n * @category Core\n * @constructor\n */\nexport abstract class Tone {\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Returns all of the default options belonging to the class.\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t//-------------------------------------\n\t// \tDEBUGGING\n\t//-------------------------------------\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * // prints all logs originating from this oscillator\n\t * osc.debug = true;\n\t * // calls to start/stop will print in the console\n\t * osc.start();\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (\n\t\t\tthis.debug ||\n\t\t\t(theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)\n\t\t) {\n\t\t\tlog(this, ...args);\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tDISPOSING\n\t//-------------------------------------\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed = false;\n\n\t/**\n\t * disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * console.log(osc.toString());\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n}\n","/**\n * The threshold for correctness for operators. Less than one sample even\n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n\n/**\n * Test if A is greater than B\n */\nexport function GT(a: number, b: number): boolean {\n\treturn a > b + EPSILON;\n}\n\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a: number, b: number): boolean {\n\treturn GT(a, b) || EQ(a, b);\n}\n\n/**\n * Test if A is less than B\n */\nexport function LT(a: number, b: number): boolean {\n\treturn a + EPSILON < b;\n}\n\n/**\n * Test if A is less than B\n */\nexport function EQ(a: number, b: number): boolean {\n\treturn Math.abs(a - b) < EPSILON;\n}\n\n/**\n * Clamp the value within the given range\n */\nexport function clamp(value: number, min: number, max: number): number {\n\treturn Math.max(Math.min(value, max), min);\n}\n","import { Tone } from \"../Tone.js\";\nimport { Seconds } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"./Defaults.js\";\nimport { assert } from \"./Debug.js\";\nimport { EQ, GT, GTE, LT } from \"./Math.js\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n * @internal\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last\n\t * element on the list.\n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tTimeline.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"memory\"]\n\t\t);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tassert(\n\t\t\tReflect.has(event, \"time\"),\n\t\t\t\"Timeline: events must have a time attribute\"\n\t\t);\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tassert(\n\t\t\t\tGTE(event.time, lastValue.time),\n\t\t\t\t\"The time must be greater than or equal to the last scheduled time\"\n\t\t\t);\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(\n\t\ttime: number,\n\t\tparam: TimelineSearchParam = \"time\"\n\t): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t * @deprecated\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t * @deprecated\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(\n\t\ttime: number,\n\t\tparam: TimelineSearchParam = \"time\"\n\t): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (EQ(this._timeline[index].time, after)) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (EQ(this._timeline[i].time, after)) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (GTE(this._timeline[0].time, after)) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t */\n\tprotected _search(\n\t\ttime: number,\n\t\tparam: TimelineSearchParam = \"time\"\n\t): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0,\n\t\tupperBound = this._timeline.length - 1\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(\n\t\ttime: Seconds,\n\t\tcallback: (event: GenericEvent) => void\n\t): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(\n\t\tstartTime: number,\n\t\tendTime: number,\n\t\tcallback: (event: GenericEvent) => void\n\t): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n\t\t\tlet lowerBound = upperBound;\n\t\t\tfor (let i = upperBound; i >= 0; i--) {\n\t\t\t\tif (EQ(this._timeline[i].time, time)) {\n\t\t\t\t\tlowerBound = i;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._iterate(\n\t\t\t\t(event) => {\n\t\t\t\t\tcallback(event);\n\t\t\t\t},\n\t\t\t\tlowerBound,\n\t\t\t\tupperBound\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\nimport type { Context } from \"./Context.js\";\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach((cb) => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is closed\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// remove any additional modules\n\tnotifyCloseContext.forEach((cb) => cb(ctx));\n}\n","import { Tone } from \"../Tone.js\";\nimport { isUndef } from \"./TypeCheck.js\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach((eventName) => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach((eventName) => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(eventName)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[eventName] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[eventName];\n\t\t\t\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event: EventType, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach((name) => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(\n\t\t\t\tEmitter.prototype,\n\t\t\t\tname\n\t\t\t) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { AnyAudioContext } from \"./AudioContext.js\";\nimport type { DrawClass as Draw } from \"../util/Draw.js\";\nimport type { DestinationClass as Destination } from \"./Destination.js\";\nimport type { TransportClass as Transport } from \"../clock/Transport.js\";\nimport type { ListenerClass as Listener } from \"./Listener.js\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext =\n\t| \"onstatechange\"\n\t| \"addEventListener\"\n\t| \"removeEventListener\"\n\t| \"listener\"\n\t| \"dispatchEvent\"\n\t| \"audioWorklet\"\n\t| \"destination\"\n\t| \"createScriptProcessor\";\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<\n\tBaseAudioContext,\n\tExcludedFromBaseAudioContext\n>;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory;\n\nexport abstract class BaseContext\n\textends Emitter<\"statechange\" | \"tick\">\n\timplements BaseAudioContextSubset\n{\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tabstract createAnalyser(): AnalyserNode;\n\n\tabstract createOscillator(): OscillatorNode;\n\n\tabstract createBufferSource(): AudioBufferSourceNode;\n\n\tabstract createBiquadFilter(): BiquadFilterNode;\n\n\tabstract createBuffer(\n\t\t_numberOfChannels: number,\n\t\t_length: number,\n\t\t_sampleRate: number\n\t): AudioBuffer;\n\n\tabstract createChannelMerger(\n\t\t_numberOfInputs?: number | undefined\n\t): ChannelMergerNode;\n\n\tabstract createChannelSplitter(\n\t\t_numberOfOutputs?: number | undefined\n\t): ChannelSplitterNode;\n\n\tabstract createConstantSource(): ConstantSourceNode;\n\n\tabstract createConvolver(): ConvolverNode;\n\n\tabstract createDelay(_maxDelayTime?: number | undefined): DelayNode;\n\n\tabstract createDynamicsCompressor(): DynamicsCompressorNode;\n\n\tabstract createGain(): GainNode;\n\n\tabstract createIIRFilter(\n\t\t_feedForward: number[] | Float32Array,\n\t\t_feedback: number[] | Float32Array\n\t): IIRFilterNode;\n\n\tabstract createPanner(): PannerNode;\n\n\tabstract createPeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined\n\t): PeriodicWave;\n\n\tabstract createStereoPanner(): StereoPannerNode;\n\n\tabstract createWaveShaper(): WaveShaperNode;\n\n\tabstract createMediaStreamSource(\n\t\t_stream: MediaStream\n\t): MediaStreamAudioSourceNode;\n\n\tabstract createMediaElementSource(\n\t\t_element: HTMLMediaElement\n\t): MediaElementAudioSourceNode;\n\n\tabstract createMediaStreamDestination(): MediaStreamAudioDestinationNode;\n\n\tabstract decodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer>;\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tabstract createAudioWorkletNode(\n\t\t_name: string,\n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode;\n\n\tabstract get rawContext(): AnyAudioContext;\n\n\tabstract addAudioWorkletModule(_url: string): Promise<void>;\n\n\tabstract lookAhead: number;\n\n\tabstract latencyHint: ContextLatencyHint | Seconds;\n\n\tabstract resume(): Promise<void>;\n\n\tabstract setTimeout(\n\t\t_fn: (...args: any[]) => void,\n\t\t_timeout: Seconds\n\t): number;\n\n\tabstract clearTimeout(_id: number): this;\n\n\tabstract setInterval(\n\t\t_fn: (...args: any[]) => void,\n\t\t_interval: Seconds\n\t): number;\n\n\tabstract clearInterval(_id: number): this;\n\n\tabstract getConstant(_val: number): AudioBufferSourceNode;\n\n\tabstract get currentTime(): Seconds;\n\n\tabstract get state(): AudioContextState;\n\n\tabstract get sampleRate(): number;\n\n\tabstract get listener(): Listener;\n\n\tabstract get transport(): Transport;\n\n\tabstract get draw(): Draw;\n\n\tabstract get destination(): Destination;\n\n\tabstract now(): Seconds;\n\n\tabstract immediate(): Seconds;\n\n\t/*\n\t * This is a placeholder so that JSON.stringify does not throw an error\n\t * This matches what JSON.stringify(audioContext) returns on a native\n\t * audioContext instance.\n\t */\n\ttoJSON(): Record<string, any> {\n\t\treturn {};\n\t}\n\n\treadonly isOffline: boolean = false;\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker.js\";\nimport { Seconds } from \"../type/Units.js\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport {\n\tAnyAudioContext,\n\tcreateAudioContext,\n\tcreateAudioWorkletNode,\n} from \"./AudioContext.js\";\nimport { closeContext, initializeContext } from \"./ContextInitialization.js\";\nimport { BaseContext, ContextLatencyHint } from \"./BaseContext.js\";\nimport { assert } from \"../util/Debug.js\";\nimport type { DrawClass as Draw } from \"../util/Draw.js\";\nimport type { DestinationClass as Destination } from \"./Destination.js\";\nimport type { TransportClass as Transport } from \"../clock/Transport.js\";\nimport type { ListenerClass as Listener } from \"./Listener.js\";\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n\treadonly name: string = \"Context\";\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t * The default latency hint\n\t */\n\tprivate _latencyHint!: ContextLatencyHint | Seconds;\n\n\t/**\n\t * An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t * All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t * The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Listener singleton belonging to this context\n\t */\n\tprivate _listener!: Listener;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _draw!: Draw;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized = false;\n\n\t/**\n\t * Private indicator if a close() has been called on the context, since close is async\n\t */\n\tprivate _closeStarted = false;\n\n\t/**\n\t * Indicates if the context is an OfflineAudioContext or an AudioContext\n\t */\n\treadonly isOffline: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\n\t\t\t\"context\",\n\t\t]);\n\n\t\tif (options.context) {\n\t\t\tthis._context = options.context;\n\t\t\t// custom context provided, latencyHint unknown (unless explicitly provided in options)\n\t\t\tthis._latencyHint = arguments[0]?.latencyHint || \"\";\n\t\t} else {\n\t\t\tthis._context = createAudioContext({\n\t\t\t\tlatencyHint: options.latencyHint,\n\t\t\t});\n\t\t\tthis._latencyHint = options.latencyHint;\n\t\t}\n\n\t\tthis._ticker = new Ticker(\n\t\t\tthis.emit.bind(this, \"tick\"),\n\t\t\toptions.clockSource,\n\t\t\toptions.updateInterval,\n\t\t\tthis._context.sampleRate\n\t\t);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.onstatechange = () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t};\n\n\t\t// if no custom updateInterval provided, updateInterval will be derived by lookAhead setter\n\t\tthis[\n\t\t\targuments[0]?.hasOwnProperty(\"updateInterval\")\n\t\t\t\t? \"_lookAhead\"\n\t\t\t\t: \"lookAhead\"\n\t\t] = options.lookAhead;\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.05,\n\t\t} as ContextOptions;\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tprivate initialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(\n\t\tnumberOfChannels: number,\n\t\tlength: number,\n\t\tsampleRate: number\n\t): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(\n\t\tnumberOfInputs?: number | undefined\n\t): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(\n\t\tnumberOfOutputs?: number | undefined\n\t): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(\n\t\tfeedForward: number[] | Float32Array,\n\t\tfeedback: number[] | Float32Array\n\t): IIRFilterNode {\n\t\t// @ts-ignore\n\t\treturn this._context.createIIRFilter(feedForward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tcreateMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode {\n\t\tassert(\n\t\t\tisAudioContext(this._context),\n\t\t\t\"Not available if OfflineAudioContext\"\n\t\t);\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaStreamSource(stream);\n\t}\n\tcreateMediaElementSource(\n\t\telement: HTMLMediaElement\n\t): MediaElementAudioSourceNode {\n\t\tassert(\n\t\t\tisAudioContext(this._context),\n\t\t\t\"Not available if OfflineAudioContext\"\n\t\t);\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaElementSource(element);\n\t}\n\tcreateMediaStreamDestination(): MediaStreamAudioDestinationNode {\n\t\tassert(\n\t\t\tisAudioContext(this._context),\n\t\t\t\"Not available if OfflineAudioContext\"\n\t\t);\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaStreamDestination();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\n\t/**\n\t * The listener\n\t */\n\tget listener(): Listener {\n\t\tthis.initialize();\n\t\treturn this._listener;\n\t}\n\tset listener(l) {\n\t\tassert(\n\t\t\t!this._initialized,\n\t\t\t\"The listener cannot be set after initialization.\"\n\t\t);\n\t\tthis._listener = l;\n\t}\n\n\t/**\n\t * There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.initialize();\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tassert(\n\t\t\t!this._initialized,\n\t\t\t\"The transport cannot be set after initialization.\"\n\t\t);\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n\t */\n\tget draw(): Draw {\n\t\tthis.initialize();\n\t\treturn this._draw;\n\t}\n\tset draw(d) {\n\t\tassert(!this._initialized, \"Draw cannot be set after initialization.\");\n\t\tthis._draw = d;\n\t}\n\n\t/**\n\t * A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.initialize();\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tassert(\n\t\t\t!this._initialized,\n\t\t\t\"The destination cannot be set after initialization.\"\n\t\t);\n\t\tthis._destination = d;\n\t}\n\n\t//--------------------------------------------\n\t// AUDIO WORKLET\n\t//--------------------------------------------\n\n\t/**\n\t * Maps a module name to promise of the addModule method\n\t */\n\tprivate _workletPromise: null | Promise<void> = null;\n\n\t/**\n\t * Create an audio worklet node from a name and options. The module\n\t * must first be loaded using {@link addAudioWorkletModule}.\n\t */\n\tcreateAudioWorkletNode(\n\t\tname: string,\n\t\toptions?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn createAudioWorkletNode(this.rawContext, name, options);\n\t}\n\n\t/**\n\t * Add an AudioWorkletProcessor module\n\t * @param url The url of the module\n\t */\n\tasync addAudioWorkletModule(url: string): Promise<void> {\n\t\tassert(\n\t\t\tisDefined(this.rawContext.audioWorklet),\n\t\t\t\"AudioWorkletNode is only available in a secure context (https or localhost)\"\n\t\t);\n\t\tif (!this._workletPromise) {\n\t\t\tthis._workletPromise = this.rawContext.audioWorklet.addModule(url);\n\t\t}\n\t\tawait this._workletPromise;\n\t}\n\n\t/**\n\t * Returns a promise which resolves when all of the worklets have been loaded on this context\n\t */\n\tprotected async workletsAreReady(): Promise<void> {\n\t\t(await this._workletPromise) ? this._workletPromise : Promise.resolve();\n\t}\n\n\t//---------------------------\n\t// TICKER\n\t//---------------------------\n\n\t/**\n\t * How often the interval callback is invoked.\n\t * This number corresponds to how responsive the scheduling\n\t * can be. Setting to 0 will result in the lowest practial interval\n\t * based on context properties. context.updateInterval + context.lookAhead\n\t * gives you the total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t * What the source of the clock is, either \"worker\" (default),\n\t * \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t * Adjusting this value also affects the {@link updateInterval}.\n\t */\n\tget lookAhead(): Seconds {\n\t\treturn this._lookAhead;\n\t}\n\tset lookAhead(time: Seconds) {\n\t\tthis._lookAhead = time;\n\t\t// if lookAhead is 0, default to .01 updateInterval\n\t\tthis.updateInterval = time ? time / 2 : 0.01;\n\t}\n\tprivate _lookAhead!: Seconds;\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance).\n\t * @example\n\t * // prioritize sustained playback\n\t * const context = new Tone.Context({ latencyHint: \"playback\" });\n\t * // set this context as the global Context\n\t * Tone.setContext(context);\n\t * // the global context is gettable with Tone.getContext()\n\t * console.log(Tone.getContext().latencyHint);\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\n\t/**\n\t * The unwrapped AudioContext or OfflineAudioContext\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short {@link lookAhead}.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(\"now\", Tone.now());\n\t * }, 100);\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this._lookAhead;\n\t}\n\n\t/**\n\t * The current audio context time without the {@link lookAhead}.\n\t * In most cases it is better to use {@link now} instead of {@link immediate} since\n\t * with {@link now} the {@link lookAhead} is applied equally to _all_ components including internal components,\n\t * to making sure that everything is scheduled in sync. Mixing {@link now} and {@link immediate}\n\t * can cause some timing issues. If no lookAhead is desired, you can set the {@link lookAhead} to `0`.\n\t */\n\timmediate(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\n\t/**\n\t * Starts the audio context from a suspended state. This is required\n\t * to initially start the AudioContext.\n\t * @see {@link start}\n\t */\n\tresume(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Close the context. Once closed, the context can no longer be used and\n\t * any AudioNodes created from the context will be silent.\n\t */\n\tasync close(): Promise<void> {\n\t\tif (\n\t\t\tisAudioContext(this._context) &&\n\t\t\tthis.state !== \"closed\" &&\n\t\t\t!this._closeStarted\n\t\t) {\n\t\t\tthis._closeStarted = true;\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t * **Internal** Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(\n\t\t\t\t1,\n\t\t\t\t128,\n\t\t\t\tthis._context.sampleRate\n\t\t\t);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t * Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map((val) =>\n\t\t\tthis._constants[val].disconnect()\n\t\t);\n\t\tthis.close();\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// TIMEOUTS\n\t//---------------------------\n\n\t/**\n\t * The private loop which keeps track of the context scheduled timeouts\n\t * Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void {\n\t\tconst now = this.now();\n\t\tthis._timeouts.forEachBefore(now, (event) => {\n\t\t\t// invoke the callback\n\t\t\tevent.callback();\n\t\t\tthis._timeouts.remove(event);\n\t\t});\n\t}\n\n\t/**\n\t * A setTimeout which is guaranteed by the clock source.\n\t * Also runs in the offline context.\n\t * @param  fn       The callback to invoke\n\t * @param  timeout  The timeout in seconds\n\t * @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback: fn,\n\t\t\tid: this._timeoutIds,\n\t\t\ttime: now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t * Clears a previously scheduled timeout with Tone.context.setTimeout\n\t * @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): this {\n\t\tthis._timeouts.forEach((event) => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear the function scheduled by {@link setInterval}\n\t */\n\tclearInterval(id: number): this {\n\t\treturn this.clearTimeout(id);\n\t}\n\n\t/**\n\t * Adds a repeating event to the context's callback clock\n\t */\n\tsetInterval(fn: (...args: any[]) => void, interval: Seconds): number {\n\t\tconst id = ++this._timeoutIds;\n\t\tconst intervalFn = () => {\n\t\t\tconst now = this.now();\n\t\t\tthis._timeouts.add({\n\t\t\t\tcallback: () => {\n\t\t\t\t\t// invoke the callback\n\t\t\t\t\tfn();\n\t\t\t\t\t// invoke the event to repeat it\n\t\t\t\t\tintervalFn();\n\t\t\t\t},\n\t\t\t\tid,\n\t\t\t\ttime: now + interval,\n\t\t\t});\n\t\t};\n\t\t// kick it off\n\t\tintervalFn();\n\t\treturn id;\n\t}\n}\n","import { isArray } from \"./TypeCheck.js\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach((str) => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach((str) => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no operation here!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?: T[P] extends Array<infer U>\n\t\t? Array<RecursivePartial<U>>\n\t\t: T[P] extends object\n\t\t\t? RecursivePartial<T[P]>\n\t\t\t: T[P];\n};\n","import { getContext } from \"../Global.js\";\nimport { Tone } from \"../Tone.js\";\nimport { Samples, Seconds } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { noOp } from \"../util/Interface.js\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck.js\";\nimport { assert } from \"../util/Debug.js\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffer.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"url\", \"onload\", \"onerror\"]\n\t\t);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t} else if (options.url) {\n\t\t\tthis.set(options.url);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst doneLoading: Promise<void> = ToneAudioBuffer.load(url).then(\n\t\t\t(audioBuffer) => {\n\t\t\t\tthis.set(audioBuffer);\n\t\t\t\t// invoke the onload method\n\t\t\t\tthis.onload(this);\n\t\t\t}\n\t\t);\n\t\tToneAudioBuffer.downloads.push(doneLoading);\n\t\ttry {\n\t\t\tawait doneLoading;\n\t\t} finally {\n\t\t\t// remove the downloaded file\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional\n\t\t\t? (array[0] as Float32Array).length\n\t\t\t: array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] =\n\t\t\t!isMultidimensional && channels === 1\n\t\t\t\t? [array as Float32Array]\n\t\t\t\t: (array as Float32Array[]);\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map((sample) => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tassert(this.loaded, \"Buffer is not loaded\");\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tassert(\n\t\t\tstartSamples < endSamples,\n\t\t\t\"The start time must be less than the end time\"\n\t\t);\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(\n\t\t\tthis.numberOfChannels,\n\t\t\tlength,\n\t\t\tthis.sampleRate\n\t\t);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(\n\t\t\t\tthis.getChannelData(channel).subarray(startSamples, endSamples),\n\t\t\t\tchannel\n\t\t\t);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn new ToneAudioBuffer().fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<void>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\t\t// make sure there is a slash between the baseUrl and the url\n\t\tconst baseUrl =\n\t\t\tToneAudioBuffer.baseUrl === \"\" ||\n\t\t\tToneAudioBuffer.baseUrl.endsWith(\"/\")\n\t\t\t\t? ToneAudioBuffer.baseUrl\n\t\t\t\t: ToneAudioBuffer.baseUrl + \"/\";\n\n\t\tconst response = await fetch(baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document\n\t\t\t.createElement(\"audio\")\n\t\t\t.canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\t// this makes sure that the function is always async\n\t\tawait Promise.resolve();\n\t\twhile (ToneAudioBuffer.downloads.length) {\n\t\t\tawait ToneAudioBuffer.downloads[0];\n\t\t}\n\t}\n}\n","import { createOfflineAudioContext } from \"../context/AudioContext.js\";\nimport { Context } from \"../context/Context.js\";\nimport { Seconds } from \"../type/Units.js\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(channels: number, duration: Seconds, sampleRate: number);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0])\n\t\t\t\t? arguments[0]\n\t\t\t\t: createOfflineAudioContext(\n\t\t\t\t\t\targuments[0],\n\t\t\t\t\t\targuments[1] * arguments[2],\n\t\t\t\t\t\targuments[2]\n\t\t\t\t\t),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0])\n\t\t\t\t? 128 / arguments[0].sampleRate\n\t\t\t\t: 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0])\n\t\t\t? arguments[0].length / arguments[0].sampleRate\n\t\t\t: arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise((done) => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n","import { version } from \"../version.js\";\nimport {\n\tAnyAudioContext,\n\thasAudioContext,\n\ttheWindow,\n} from \"./context/AudioContext.js\";\nimport { Context } from \"./context/Context.js\";\nimport { DummyContext } from \"./context/DummyContext.js\";\nimport { BaseContext } from \"./context/BaseContext.js\";\nimport { OfflineContext } from \"./context/OfflineContext.js\";\nimport {\n\tisAudioContext,\n\tisOfflineAudioContext,\n} from \"./util/AdvancedTypeCheck.js\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext = new DummyContext();\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseContext = dummyContext;\n\n/**\n * Returns the default system-wide {@link Context}\n * @category Core\n */\nexport function getContext(): BaseContext {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n * @param context\n * @param disposeOld Pass `true` if you don't need the old context to dispose it.\n * @category Core\n */\nexport function setContext(\n\tcontext: BaseContext | AnyAudioContext,\n\tdisposeOld = false\n): void {\n\tif (disposeOld) {\n\t\tglobalContext.dispose();\n\t}\n\n\tif (isAudioContext(context)) {\n\t\tglobalContext = new Context(context);\n\t} else if (isOfflineAudioContext(context)) {\n\t\tglobalContext = new OfflineContext(context);\n\t} else {\n\t\tglobalContext = context;\n\t}\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\nexport function start(): Promise<void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// eslint-disable-next-line no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { BaseContext } from \"./BaseContext.js\";\nimport { Seconds } from \"../type/Units.js\";\nimport { AnyAudioContext } from \"./AudioContext.js\";\nimport type { DrawClass as Draw } from \"../util/Draw.js\";\nimport type { DestinationClass as Destination } from \"./Destination.js\";\nimport type { TransportClass as Transport } from \"../clock/Transport.js\";\nimport type { ListenerClass as Listener } from \"./Listener.js\";\n\nexport class DummyContext extends BaseContext {\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn {} as AnalyserNode;\n\t}\n\n\tcreateOscillator(): OscillatorNode {\n\t\treturn {} as OscillatorNode;\n\t}\n\n\tcreateBufferSource() {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn {} as BiquadFilterNode;\n\t}\n\n\tcreateBuffer(\n\t\t_numberOfChannels: number,\n\t\t_length: number,\n\t\t_sampleRate: number\n\t): AudioBuffer {\n\t\treturn {} as AudioBuffer;\n\t}\n\n\tcreateChannelMerger(\n\t\t_numberOfInputs?: number | undefined\n\t): ChannelMergerNode {\n\t\treturn {} as ChannelMergerNode;\n\t}\n\n\tcreateChannelSplitter(\n\t\t_numberOfOutputs?: number | undefined\n\t): ChannelSplitterNode {\n\t\treturn {} as ChannelSplitterNode;\n\t}\n\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn {} as ConstantSourceNode;\n\t}\n\n\tcreateConvolver(): ConvolverNode {\n\t\treturn {} as ConvolverNode;\n\t}\n\n\tcreateDelay(_maxDelayTime?: number | undefined): DelayNode {\n\t\treturn {} as DelayNode;\n\t}\n\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn {} as DynamicsCompressorNode;\n\t}\n\n\tcreateGain(): GainNode {\n\t\treturn {} as GainNode;\n\t}\n\n\tcreateIIRFilter(\n\t\t_feedForward: number[] | Float32Array,\n\t\t_feedback: number[] | Float32Array\n\t): IIRFilterNode {\n\t\treturn {} as IIRFilterNode;\n\t}\n\n\tcreatePanner(): PannerNode {\n\t\treturn {} as PannerNode;\n\t}\n\n\tcreatePeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined\n\t): PeriodicWave {\n\t\treturn {} as PeriodicWave;\n\t}\n\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn {} as StereoPannerNode;\n\t}\n\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn {} as WaveShaperNode;\n\t}\n\n\tcreateMediaStreamSource(_stream: MediaStream): MediaStreamAudioSourceNode {\n\t\treturn {} as MediaStreamAudioSourceNode;\n\t}\n\n\tcreateMediaElementSource(\n\t\t_element: HTMLMediaElement\n\t): MediaElementAudioSourceNode {\n\t\treturn {} as MediaElementAudioSourceNode;\n\t}\n\n\tcreateMediaStreamDestination(): MediaStreamAudioDestinationNode {\n\t\treturn {} as MediaStreamAudioDestinationNode;\n\t}\n\n\tdecodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn Promise.resolve({} as AudioBuffer);\n\t}\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAudioWorkletNode(\n\t\t_name: string,\n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn {} as AudioWorkletNode;\n\t}\n\n\tget rawContext(): AnyAudioContext {\n\t\treturn {} as AnyAudioContext;\n\t}\n\n\tasync addAudioWorkletModule(_url: string): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tlookAhead = 0;\n\n\tlatencyHint = 0;\n\n\tresume(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsetTimeout(_fn: (...args: any[]) => void, _timeout: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearTimeout(_id: number): this {\n\t\treturn this;\n\t}\n\n\tsetInterval(_fn: (...args: any[]) => void, _interval: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearInterval(_id: number): this {\n\t\treturn this;\n\t}\n\n\tgetConstant(_val: number): AudioBufferSourceNode {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tget currentTime(): Seconds {\n\t\treturn 0;\n\t}\n\n\tget state(): AudioContextState {\n\t\treturn {} as AudioContextState;\n\t}\n\n\tget sampleRate(): number {\n\t\treturn 0;\n\t}\n\n\tget listener(): Listener {\n\t\treturn {} as Listener;\n\t}\n\n\tget transport(): Transport {\n\t\treturn {} as Transport;\n\t}\n\n\tget draw(): Draw {\n\t\treturn {} as Draw;\n\t}\n\tset draw(_d) {}\n\n\tget destination(): Destination {\n\t\treturn {} as Destination;\n\t}\n\tset destination(_d: Destination) {}\n\n\tnow() {\n\t\treturn 0;\n\t}\n\n\timmediate() {\n\t\treturn 0;\n\t}\n\n\treadonly isOffline: boolean = false;\n}\n","import {\n\tDecibels,\n\tGainFactor,\n\tHertz,\n\tInterval,\n\tMidiNote,\n\tNormalRange,\n} from \"./Units.js\";\n\n/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, interval / 12);\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { BaseContext } from \"../context/BaseContext.js\";\nimport { Tone } from \"../Tone.js\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck.js\";\nimport {\n\tBPM,\n\tHertz,\n\tMidiNote,\n\tMilliseconds,\n\tSamples,\n\tSeconds,\n\tTicks,\n\tTime,\n} from \"./Units.js\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit =\n\t| \"s\"\n\t| \"n\"\n\t| \"t\"\n\t| \"m\"\n\t| \"i\"\n\t| \"hz\"\n\t| \"tr\"\n\t| \"samples\"\n\t| \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport abstract class TimeBaseClass<\n\tType extends number,\n\tUnit extends string,\n> extends Tone {\n\treadonly context: BaseContext;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: BaseContext, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(\n\t\t\t\t\t\tparseInt(value, 10) * this._getTimeSignature()\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn (this._beatsToUnits(this._getTimeSignature()) *\n\t\t\t\t\t\t\tscalar) as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn (this._beatsToUnits(4 / numericValue) *\n\t\t\t\t\t\t\tscalar) as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn (parseInt(value, 10) /\n\t\t\t\t\t\tthis.context.sampleRate) as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(\n\t\t\t\t\t\t8 / (Math.floor(numericValue) * 3)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(\n\t\t\t\t\t\t\tthis._getTimeSignature() * parseFloat(m)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t//-------------------------------------\n\t// \tVALUE OF\n\t//-------------------------------------\n\n\t/**\n\t * Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\tconst time =\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tnew this.constructor(this.context, typeName).valueOf() *\n\t\t\t\t\t\tquantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn (1 / freq) as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn ((60 / this._getBpm()) * beats) as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn ((ticks * this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t * With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t//-------------------------------------\n\t// \tTEMPO CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t//-------------------------------------\n\t// \tCONVERSION INTERFACE\n\t//-------------------------------------\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t * Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t * Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t * Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t * Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","import { getContext } from \"../Global.js\";\nimport { ftom } from \"./Conversions.js\";\nimport {\n\tTimeBaseClass,\n\tTimeBaseUnit,\n\tTimeExpression,\n\tTimeValue,\n} from \"./TimeBase.js\";\nimport {\n\tBarsBeatsSixteenths,\n\tMidiNote,\n\tSeconds,\n\tSubdivision,\n\tTicks,\n\tTime,\n} from \"./Units.js\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass<\n\tType extends Seconds | Ticks = Seconds,\n\tUnit extends string = TimeBaseUnit,\n> extends TimeBaseClass<Type, Unit> {\n\treadonly name: string = \"TimeClass\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn (this._now() +\n\t\t\t\t\t\tnew (this.constructor as typeof TimeClass)(\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\tcapture\n\t\t\t\t\t\t).valueOf()) as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tcapture\n\t\t\t\t\t).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(\n\t\t\t\t\t\tthis.context.transport.nextSubdivision(quantTo)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  subdiv    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Tone.Time(21).quantize(2); // returns 22\n\t * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(\n\t\t\tthis.context,\n\t\t\tsubdiv\n\t\t).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn (value + diff * percent) as Type;\n\t}\n\n\t//-------------------------------------\n\t// CONVERSIONS\n\t//-------------------------------------\n\t/**\n\t * Convert a Time to Notation. The notation values are will be the\n\t * closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * // if the Transport is at 120bpm:\n\t * Tone.Time(2).toNotation(); // returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push((subdiv + \"n.\") as Subdivision);\n\t\t\ttestNotations.push((subdiv + \"n\") as Subdivision);\n\t\t\ttestNotations.push((subdiv + \"t\") as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(\n\t\t\tthis.context,\n\t\t\ttestNotations[0]\n\t\t).toSeconds();\n\t\ttestNotations.forEach((notation) => {\n\t\t\tconst notationSeconds = new TimeClass(\n\t\t\t\tthis.context,\n\t\t\t\tnotation\n\t\t\t).toSeconds();\n\t\t\tif (\n\t\t\t\tMath.abs(notationSeconds - time) <\n\t\t\t\tMath.abs(closestSeconds - time)\n\t\t\t) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t * Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\") as BarsBeatsSixteenths;\n\t}\n\n\t/**\n\t * Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn quarters * this._getPPQ();\n\t}\n\n\t/**\n\t * Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use {@link TimeClass}\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(\n\tvalue?: TimeValue,\n\tunits?: TimeBaseUnit\n): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","/* eslint-disable key-spacing */\nimport { getContext } from \"../Global.js\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions.js\";\nimport { ftom, getA4, setA4 } from \"./Conversions.js\";\nimport { TimeClass } from \"./Time.js\";\nimport { TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase.js\";\nimport {\n\tFrequency,\n\tHertz,\n\tInterval,\n\tMidiNote,\n\tNote,\n\tSeconds,\n\tTicks,\n} from \"./Units.js\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `valueOf` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<\n\tType,\n\tFrequencyUnit\n> {\n\treadonly name: string = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t//-------------------------------------\n\t// \tAUGMENT BASE EXPRESSIONS\n\t//-------------------------------------\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote: {\n\t\t\t\tregexp: /^([a-g]{1}(?:b|#|##|x|bb|###|#x|x#|bbb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(\n\t\t\t\t\t\t\tthis._getTimeSignature() * parseFloat(m)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tEXPRESSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return  A new transposed frequency\n\t * @example\n\t * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(\n\t\t\tthis.context,\n\t\t\tthis.valueOf() * intervalToFrequencyRatio(interval)\n\t\t);\n\t}\n\n\t/**\n\t * Takes an array of semitone intervals and returns\n\t * an array of frequencies transposed by those intervals.\n\t * @return  Returns an array of Frequencies\n\t * @example\n\t * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map((interval) => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Frequency(\"C4\").toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn (noteName + octave.toString()) as Note;\n\t}\n\n\t/**\n\t * Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t * Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS HELPERS\n\t//-------------------------------------\n\n\t/**\n\t * With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (1 / ((ticks * 60) / (this._getBpm() * this._getPPQ()))) as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (1 / super._beatsToUnits(beats)) as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn (1 / seconds) as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index.\n * @hidden\n */\nconst noteToScaleIndex = {\n\tcbbb: -3,\n\tcbb: -2,\n\tcb: -1,\n\tc: 0,\n\t\"c#\": 1,\n\tcx: 2,\n\t\"c##\": 2,\n\t\"c###\": 3,\n\t\"cx#\": 3,\n\t\"c#x\": 3,\n\tdbbb: -1,\n\tdbb: 0,\n\tdb: 1,\n\td: 2,\n\t\"d#\": 3,\n\tdx: 4,\n\t\"d##\": 4,\n\t\"d###\": 5,\n\t\"dx#\": 5,\n\t\"d#x\": 5,\n\tebbb: 1,\n\tebb: 2,\n\teb: 3,\n\te: 4,\n\t\"e#\": 5,\n\tex: 6,\n\t\"e##\": 6,\n\t\"e###\": 7,\n\t\"ex#\": 7,\n\t\"e#x\": 7,\n\tfbbb: 2,\n\tfbb: 3,\n\tfb: 4,\n\tf: 5,\n\t\"f#\": 6,\n\tfx: 7,\n\t\"f##\": 7,\n\t\"f###\": 8,\n\t\"fx#\": 8,\n\t\"f#x\": 8,\n\tgbbb: 4,\n\tgbb: 5,\n\tgb: 6,\n\tg: 7,\n\t\"g#\": 8,\n\tgx: 9,\n\t\"g##\": 9,\n\t\"g###\": 10,\n\t\"gx#\": 10,\n\t\"g#x\": 10,\n\tabbb: 6,\n\tabb: 7,\n\tab: 8,\n\ta: 9,\n\t\"a#\": 10,\n\tax: 11,\n\t\"a##\": 11,\n\t\"a###\": 12,\n\t\"ax#\": 12,\n\t\"a#x\": 12,\n\tbbbb: 8,\n\tbbb: 9,\n\tbb: 10,\n\tb: 11,\n\t\"b#\": 12,\n\tbx: 13,\n\t\"b##\": 13,\n\t\"b###\": 14,\n\t\"bx#\": 14,\n\t\"b#x\": 14,\n};\n\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\n\t\"C\",\n\t\"C#\",\n\t\"D\",\n\t\"D#\",\n\t\"E\",\n\t\"F\",\n\t\"F#\",\n\t\"G\",\n\t\"G#\",\n\t\"A\",\n\t\"A#\",\n\t\"B\",\n];\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n * @example\n * const midi = Tone.Frequency(\"C3\").toMidi();\n * console.log(midi);\n * @example\n * const hertz = Tone.Frequency(38, \"midi\").toFrequency();\n * console.log(hertz);\n */\nexport function Frequency(\n\tvalue?: TimeValue | Frequency,\n\tunits?: FrequencyUnit\n): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global.js\";\nimport { Seconds, Ticks } from \"../type/Units.js\";\nimport { TimeClass } from \"./Time.js\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase.js\";\n\n/**\n * TransportTime is a time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass<\n\tType extends Seconds | Ticks = Seconds,\n> extends TimeClass<Type> {\n\treadonly name: string = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(\n\tvalue?: TimeValue,\n\tunits?: TimeBaseUnit\n): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global.js\";\nimport { Tone } from \"../Tone.js\";\nimport { FrequencyClass } from \"../type/Frequency.js\";\nimport { TimeClass } from \"../type/Time.js\";\nimport { TransportTimeClass } from \"../type/TransportTime.js\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { assertUsedScheduleTime } from \"../util/Debug.js\";\nimport {\n\tgetDefaultsFromInstance,\n\toptionsFromArguments,\n} from \"../util/Defaults.js\";\nimport { RecursivePartial } from \"../util/Interface.js\";\nimport {\n\tisArray,\n\tisBoolean,\n\tisDefined,\n\tisNumber,\n\tisString,\n\tisUndef,\n} from \"../util/TypeCheck.js\";\nimport { BaseContext } from \"./BaseContext.js\";\nimport type { TransportClass } from \"../clock/Transport.js\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: BaseContext;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<\n\tOptions extends ToneWithContextOptions,\n> extends Tone {\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: BaseContext;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor.\n\t * Probably should not be set manually. Used internally.\n\t * @hidden\n\t */\n\treadonly defaultContext?: BaseContext;\n\n\t/**\n\t * Pass in a constructor as the first argument\n\t */\n\tconstructor(context?: BaseContext);\n\tconstructor(options?: Partial<ToneWithContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneWithContext.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"context\"]\n\t\t);\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(Tone.now());\n\t * }, 100);\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(Tone.immediate());\n\t * }, 100);\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t * @example\n\t * console.log(Tone.Destination.blockTime);\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds.\n\t * This is calculated against the current {@link TransportClass} bpm\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * setInterval(() => console.log(gain.toSeconds(\"4n\")), 100);\n\t * // ramp the tempo to 60 bpm over 30 seconds\n\t * Tone.getTransport().bpm.rampTo(60, 30);\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\tassertUsedScheduleTime(time);\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toFrequency(\"4n\"));\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toTicks(\"4n\"));\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t//-------------------------------------\n\t// \tGET/SET\n\t//-------------------------------------\n\n\t/**\n\t * Get a subset of the properties which are in the partial props\n\t */\n\tprotected _getPartialProperties(props: Options): Partial<Options> {\n\t\tconst options = this.get();\n\t\t// remove attributes from the prop that are not in the partial\n\t\tObject.keys(options).forEach((name) => {\n\t\t\tif (isUndef(props[name])) {\n\t\t\t\tdelete options[name];\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * console.log(osc.get());\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach((attribute) => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (\n\t\t\t\t\tisDefined(member) &&\n\t\t\t\t\tisDefined(member.value) &&\n\t\t\t\t\tisDefined(member.setValueAtTime)\n\t\t\t\t) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member._getPartialProperties(\n\t\t\t\t\t\tdefaults[attribute]\n\t\t\t\t\t);\n\t\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (\n\t\t\t\t\tisArray(member) ||\n\t\t\t\t\tisNumber(member) ||\n\t\t\t\t\tisString(member) ||\n\t\t\t\t\tisBoolean(member)\n\t\t\t\t) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set multiple properties at once with an object.\n\t * @example\n\t * const filter = new Tone.Filter().toDestination();\n\t * // set values using an object\n\t * filter.set({\n\t * \tfrequency: \"C6\",\n\t * \ttype: \"highpass\"\n\t * });\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3\").connect(filter);\n\t * player.autostart = true;\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach((attribute) => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (\n\t\t\t\t\tthis[attribute] &&\n\t\t\t\t\tisDefined(this[attribute].value) &&\n\t\t\t\t\tisDefined(this[attribute].setValueAtTime)\n\t\t\t\t) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units.js\";\nimport { Timeline, TimelineEvent } from \"./Timeline.js\";\nimport { assertRange } from \"./Debug.js\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n * @internal\n */\nexport class StateTimeline<\n\tAdditionalOptions extends Record<string, any> = Record<string, any>,\n> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t\tthis.setStateAtTime(this._initial, 0);\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(\n\t\tstate: PlaybackState,\n\t\ttime: Seconds,\n\t\toptions?: AdditionalOptions\n\t): this {\n\t\tassertRange(time, 0);\n\t\tthis.add(\n\t\t\tObject.assign({}, options, {\n\t\t\t\tstate,\n\t\t\t\ttime,\n\t\t\t})\n\t\t);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(\n\t\tstate: PlaybackState,\n\t\ttime: number\n\t): (StateTimelineEvent & AdditionalOptions) | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(\n\t\tstate: PlaybackState,\n\t\ttime: number\n\t): (StateTimelineEvent & AdditionalOptions) | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam.js\";\nimport { dbToGain, gainToDb } from \"../type/Conversions.js\";\nimport {\n\tDecibels,\n\tFrequency,\n\tPositive,\n\tTime,\n\tUnitMap,\n\tUnitName,\n} from \"../type/Units.js\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext.js\";\nimport { EQ } from \"../util/Math.js\";\nimport { assert, assertRange } from \"../util/Debug.js\";\n\nexport interface ParamOptions<TypeName extends UnitName>\n\textends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType =\n\t| \"linearRampToValueAtTime\"\n\t| \"exponentialRampToValueAtTime\"\n\t| \"setValueAtTime\"\n\t| \"setTargetAtTime\"\n\t| \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName>\n{\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method.\n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\n\t\t\t\"param\",\n\t\t\t\"units\",\n\t\t\t\"convert\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tassert(\n\t\t\tisDefined(options.param) &&\n\t\t\t\t(isAudioParam(options.param) || options.param instanceof Param),\n\t\t\t\"param must be an AudioParam\"\n\t\t);\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable)\n\t\t\t? options.swappable\n\t\t\t: false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (\n\t\t\tisDefined(options.value) &&\n\t\t\toptions.value !== this._toType(this._initialValue)\n\t\t) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (\n\t\t\tthis.units === \"time\" ||\n\t\t\tthis.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" ||\n\t\t\tthis.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" ||\n\t\t\tthis.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" ||\n\t\t\tthis.units === \"hertz\" ||\n\t\t\tthis.units === \"samples\"\n\t\t) {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (\n\t\t\tthis.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\"\n\t\t) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(\n\t\t\t\tvalue,\n\t\t\t\tthis._fromType(this.minValue),\n\t\t\t\tthis._fromType(this.maxValue)\n\t\t\t);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`\n\t\t);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (\n\t\t\tbefore.type === \"setTargetAtTime\" &&\n\t\t\t(after === null || after.type === \"setValueAtTime\")\n\t\t) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(\n\t\t\t\t\tbefore.time,\n\t\t\t\t\tpreviousVal,\n\t\t\t\t\tbefore.value,\n\t\t\t\t\tbefore.constant,\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (\n\t\t\tafter.type === \"linearRampToValueAtTime\" ||\n\t\t\tafter.type === \"exponentialRampToValueAtTime\"\n\t\t) {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(\n\t\t\t\t\tbefore.time,\n\t\t\t\t\tbeforeValue,\n\t\t\t\t\tafter.time,\n\t\t\t\t\tafter.value,\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(\n\t\t\t\t\tbefore.time,\n\t\t\t\t\tbeforeValue,\n\t\t\t\t\tafter.time,\n\t\t\t\t\tafter.value,\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`\n\t\t);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\tendTime: Time\n\t): this {\n\t\tlet numericValue = this._fromType(value);\n\t\t// the value can't be 0\n\t\tnumericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`\n\t\t);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\n\t\t\tthis.units,\n\t\t\t\"exponentialRampToValueAtTime\",\n\t\t\tvalue,\n\t\t\tcomputedTime\n\t\t);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(\n\t\t\tvalue,\n\t\t\tstartTime + this.toSeconds(rampTime)\n\t\t);\n\t\treturn this;\n\t}\n\n\tlinearRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(\n\t\t\tvalue,\n\t\t\tstartTime + this.toSeconds(rampTime)\n\t\t);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\ttime: Time,\n\t\trampTime: Time\n\t): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\tstartTime: Time,\n\t\ttimeConstant: Positive\n\t): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(\n\t\t\tisFinite(timeConstant) && timeConstant > 0,\n\t\t\t\"timeConstant must be a number greater than 0\"\n\t\t);\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(\n\t\t\tisFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`\n\t\t);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(\n\t\t\tthis.units,\n\t\t\t\"setTargetAtTime\",\n\t\t\tvalue,\n\t\t\tcomputedTime,\n\t\t\ttimeConstant\n\t\t);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(\n\t\tvalues: UnitMap[TypeName][],\n\t\tstartTime: Time,\n\t\tduration: Time,\n\t\tscaling = 1\n\t): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(\n\t\t\t\tthis._toType(numericValue),\n\t\t\t\tstartTime + i * segTime\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(\n\t\t\tisFinite(computedTime),\n\t\t\t`Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`\n\t\t);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(\n\t\t\tisFinite(computedTime),\n\t\t\t`Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`\n\t\t);\n\n\t\tthis.log(\n\t\t\tthis.units,\n\t\t\t\"cancelAndHoldAtTime\",\n\t\t\tcomputedTime,\n\t\t\t\"value=\" + valueAtTime\n\t\t);\n\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(\n\t\t\t\t\tthis._toType(valueAtTime),\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(\n\t\t\t\t\tthis._toType(valueAtTime),\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time = 0.1,\n\t\tstartTime?: Time\n\t): this {\n\t\tif (\n\t\t\tthis.units === \"frequency\" ||\n\t\t\tthis.units === \"bpm\" ||\n\t\t\tthis.units === \"decibels\"\n\t\t) {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(\n\t\t\t\t\tthis.getValueAtTime(i) as number,\n\t\t\t\t\ti\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, (event) => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves\n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(\n\t\t\tthis._swappable,\n\t\t\t\"The Param must be assigned as 'swappable' in the constructor\"\n\t\t);\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(\n\t\tt0: number,\n\t\tv0: number,\n\t\tv1: number,\n\t\ttimeConstant: number,\n\t\tt: number\n\t): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(\n\t\tt0: number,\n\t\tv0: number,\n\t\tt1: number,\n\t\tv1: number,\n\t\tt: number\n\t): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(\n\t\tt0: number,\n\t\tv0: number,\n\t\tt1: number,\n\t\tv1: number,\n\t\tt: number\n\t): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { Param } from \"./Param.js\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext.js\";\nimport { assert, warn } from \"../util/Debug.js\";\n\nexport type InputNode = ToneAudioNode | AudioNode | Param<any> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n * ToneAudioNode is the base class for classes which process audio.\n * @category Core\n */\nexport abstract class ToneAudioNode<\n\tOptions extends ToneAudioNodeOptions = ToneAudioNodeOptions,\n> extends ToneWithContext<Options> {\n\t/**\n\t * The name of the class\n\t */\n\tabstract readonly name: string;\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t * The number of inputs feeding into the AudioNode.\n\t * For source nodes, this will be 0.\n\t * @example\n\t * const node = new Tone.Gain();\n\t * console.log(node.numberOfInputs);\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of outputs of the AudioNode.\n\t * @example\n\t * const node = new Tone.Gain();\n\t * console.log(node.numberOfOutputs);\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t//-------------------------------------\n\t// AUDIO PROPERTIES\n\t//-------------------------------------\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn (\n\t\t\tisDefined(node) &&\n\t\t\t(node instanceof ToneAudioNode || isAudioNode(node))\n\t\t);\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach((node) => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tassert(\n\t\t\tnodeList.length > 0,\n\t\t\t\"ToneAudioNode does not have any internal nodes\"\n\t\t);\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t * channelCount is the number of channels used when up-mixing and down-mixing\n\t * connections to any inputs to the node. The default value is 2 except for\n\t * specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t * channelCountMode determines how channels will be counted when up-mixing and\n\t * down-mixing connections to any inputs to the node.\n\t * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t * channelInterpretation determines how individual channels will be treated\n\t * when up-mixing and down-mixing connections to any inputs to the node.\n\t * The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(\n\t\t\tObject.assign(props, { channelInterpretation })\n\t\t);\n\t}\n\n\t//-------------------------------------\n\t// CONNECTIONS\n\t//-------------------------------------\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param destination The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * @example\n\t * const osc = new Tone.Oscillator(\"C2\").start();\n\t * osc.toDestination();\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * @see {@link toDestination}\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\twarn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t * disconnect the output\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output of this node to the rest of the nodes in series.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n\t * player.autostart = true;\n\t * const filter = new Tone.AutoFilter(4).start();\n\t * const distortion = new Tone.Distortion(0.5);\n\t * // connect the player to the filter, distortion and then to the master output\n\t * player.chain(filter, distortion, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the output of this node to the rest of the nodes in parallel.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n\t * player.autostart = true;\n\t * const pitchShift = new Tone.PitchShift(4).toDestination();\n\t * const filter = new Tone.Filter(\"G5\").toDestination();\n\t * // connect a node to the pitch shift and filter in parallel\n\t * player.fan(pitchShift, filter);\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach((node) => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(\n\tsrcNode: OutputNode,\n\tdstNode: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0\n): void {\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(\n\t\t\tdstNode.numberOfInputs > 0,\n\t\t\t\"Cannot connect to node with no inputs\"\n\t\t);\n\t}\n\tassert(\n\t\tsrcNode.numberOfOutputs > 0,\n\t\t\"Cannot connect from node with no outputs\"\n\t);\n\n\t// resolve the input of the dstNode\n\twhile (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0\n): void {\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!isAudioNode(srcNode)) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n\n/**\n * Connect the output of one or more source nodes to a single destination node\n * @param nodes One or more source nodes followed by one destination node\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n * const player1 = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n * const filter = new Tone.Filter(\"G5\").toDestination();\n * // connect nodes to a common destination\n * Tone.fanIn(player, player1, filter);\n */\nexport function fanIn(...nodes: OutputNode[]): void {\n\tconst dstNode = nodes.pop();\n\n\tif (isDefined(dstNode)) {\n\t\tnodes.forEach((node) => connect(node, dstNode));\n\t}\n}\n","import { Param } from \"../context/Param.js\";\nimport { UnitMap, UnitName } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode.js\";\n\ninterface GainOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tgain: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst gainNode = new Tone.Gain(0).toDestination();\n * \tconst osc = new Tone.Oscillator(30).connect(gainNode).start();\n * \tgainNode.gain.rampTo(1, 0.1);\n * \tgainNode.gain.rampTo(0, 0.4, 0.2);\n * }, 0.7, 1);\n */\nexport class Gain<\n\tTypeName extends \"gain\" | \"decibels\" | \"normalRange\" = \"gain\",\n> extends ToneAudioNode<GainOptions<TypeName>> {\n\treadonly name: string = \"Gain\";\n\n\t/**\n\t * The gain parameter of the gain node.\n\t * @example\n\t * const gainNode = new Tone.Gain(0).toDestination();\n\t * const osc = new Tone.Oscillator().connect(gainNode).start();\n\t * gainNode.gain.rampTo(1, 0.1);\n\t * gainNode.gain.rampTo(0, 2, \"+0.5\");\n\t */\n\treadonly gain: Param<TypeName>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * @param  gain The initial gain of the GainNode\n\t * @param units The units of the gain parameter.\n\t */\n\tconstructor(gain?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<GainOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\n\t\t\t\"gain\",\n\t\t\t\"units\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._gainNode.gain,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.gain,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tgain: 1,\n\t\t\tunits: \"gain\",\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline.js\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<\n\tOptions extends ToneAudioNodeOptions,\n> extends ToneAudioNode<Options> {\n\t/**\n\t * The callback to invoke after the\n\t * source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The start time\n\t */\n\tprotected _startTime = -1;\n\n\t/**\n\t * The stop time\n\t */\n\tprotected _stopTime = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tassert(\n\t\t\tthis._startTime === -1,\n\t\t\t\"Source cannot be started more than once\"\n\t\t);\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime + fadeInTime\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime,\n\t\t\t\t\tfadeInTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tassert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.now());\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail =\n\t\t\t\tthis._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended === noOp) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.onended(this);\n\t\t// overwrite onended to make sure it only is called once\n\t\tthis.onended = noOp;\n\t\t// dispose when it's ended to free up for garbage collection only in the online context\n\t\tif (!this.context.isOffline) {\n\t\t\tconst disposeCallback = () => this.dispose();\n\t\t\tif (typeof requestIdleCallback !== \"undefined\") {\n\t\t\t\trequestIdleCallback(disposeCallback);\n\t\t\t} else {\n\t\t\t\tsetTimeout(disposeCallback, 10);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the playback state at the given time\n\t */\n\tgetStateAtTime = function (time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (\n\t\t\tthis._startTime !== -1 &&\n\t\t\tcomputedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)\n\t\t) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tassert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(\n\t\t\tthis._startTime + this.sampleTime\n\t\t);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\tthis.onended = noOp;\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../core/context/ToneAudioNode.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { Seconds, Time, UnitMap, UnitName } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport {\n\tOneShotSource,\n\tOneShotSourceOptions,\n} from \"../source/OneShotSource.js\";\n\nexport interface ToneConstantSourceOptions<TypeName extends UnitName>\n\textends OneShotSourceOptions {\n\tconvert: boolean;\n\toffset: UnitMap[TypeName];\n\tunits: TypeName;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource<\n\tTypeName extends UnitName = \"number\",\n> extends OneShotSource<ToneConstantSourceOptions<TypeName>> {\n\treadonly name: string = \"ToneConstantSource\";\n\n\t/**\n\t * The signal generator\n\t */\n\tprivate _source = this.context.createConstantSource();\n\n\t/**\n\t * The offset of the signal generator\n\t */\n\treadonly offset: Param<TypeName>;\n\n\t/**\n\t * @param  offset   The offset value\n\t */\n\tconstructor(offset: UnitMap[TypeName]);\n\tconstructor(options?: Partial<ToneConstantSourceOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tToneConstantSource.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"offset\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tconnect(this._source, this._gainNode);\n\n\t\tthis.offset = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._source.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.offset,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneConstantSourceOptions<any> {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\toffset: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the source\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._source.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._source.stop(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._source.disconnect();\n\t\tthis.offset.dispose();\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../core/context/AbstractParam.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { connect } from \"../core/context/ToneAudioNode.js\";\nimport { Time, UnitMap, UnitName } from \"../core/type/Units.js\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { ToneConstantSource } from \"./ToneConstantSource.js\";\n\nexport interface SignalOptions<TypeName extends UnitName>\n\textends ToneAudioNodeOptions {\n\tvalue: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\nexport class Signal<TypeName extends UnitName = \"number\">\n\textends ToneAudioNode<SignalOptions<any>>\n\timplements AbstractParam<TypeName>\n{\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ToneConstantSource<TypeName>;\n\treadonly output: OutputNode;\n\tprotected _param: Param<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\n\t\t\t\"value\",\n\t\t\t\"units\",\n\t\t]) as SignalOptions<TypeName>;\n\t\tsuper(options);\n\n\t\tthis.output = this._constantSource = new ToneConstantSource({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = this._constantSource.offset;\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\t// start it only when connected to something\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: Time\n\t): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\ttime: Time,\n\t\trampTime: Time\n\t): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\tstartTime: Time,\n\t\ttimeConstant: number\n\t): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(\n\t\tvalues: UnitMap[TypeName][],\n\t\tstartTime: Time,\n\t\tduration: Time,\n\t\tscaling?: number\n\t): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\treturn this._param.value;\n\t}\n\tset value(value: UnitMap[TypeName]) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n\n\t/**\n\t * @see {@link Param.apply}.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tthis._param.apply(param);\n\t\treturn this;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(\n\tsignal: OutputNode,\n\tdestination: InputNode,\n\toutputNum?: number,\n\tinputNum?: number\n): void {\n\tif (\n\t\tdestination instanceof Param ||\n\t\tisAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)\n\t) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { AutomationEvent, Param, ParamOptions } from \"../context/Param.js\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isUndef } from \"../util/TypeCheck.js\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName>\n\textends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the {@link Param} class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<\n\tTypeName extends \"hertz\" | \"bpm\",\n> extends Param<TypeName> {\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tTickParam.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"value\"]\n\t\t);\n\t\tsuper(options);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\ttime: Time,\n\t\tconstant: number\n\t): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(\n\t\t\t\tprevEvent.time,\n\t\t\t\tprevEvent.value,\n\t\t\t\tcomputedValue,\n\t\t\t\tconstant,\n\t\t\t\tsegTime\n\t\t\t);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(\n\t\t\tpreviousEvent,\n\t\t\tcomputedTime\n\t\t);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(\n\t\t\tpreviousEvent,\n\t\t\tcomputedTime\n\t\t);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = (time - prevEvent.time) / segments;\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(\n\t\t\t\tprevEvent.time,\n\t\t\t\tprevEvent.value,\n\t\t\t\ttime,\n\t\t\t\tcomputedVal,\n\t\t\t\tsegTime\n\t\t\t);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(\n\t\tevent: TickAutomationEvent | null,\n\t\ttime: number\n\t): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (\n\t\t\tonTheLineEvent &&\n\t\t\tonTheLineEvent.time === time &&\n\t\t\tonTheLineEvent.type === \"setValueAtTime\"\n\t\t) {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (\n\t\t\tbefore &&\n\t\t\tafter &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value\n\t\t) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(\n\t\t\t\tMath.pow(val0, 2) - 2 * delta * (before.ticks - tick)\n\t\t\t);\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of {@link ticksToTime}. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn ((val / this.multiplier) * 60) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.cancelScheduledValues(0);\n\t\tthis.setValueAtTime(currentVal, 0);\n\t}\n}\n","import { Signal, SignalOptions } from \"../../signal/Signal.js\";\nimport { InputNode } from \"../context/ToneAudioNode.js\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { TickParam } from \"./TickParam.js\";\n\ninterface TickSignalOptions<TypeName extends UnitName>\n\textends SignalOptions<TypeName> {\n\tvalue: UnitMap[TypeName];\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal<\n\tTypeName extends \"hertz\" | \"bpm\",\n> extends Signal<TypeName> {\n\treadonly name: string = \"TickSignal\";\n\n\t/**\n\t * The param which controls the output signal value\n\t */\n\tprotected _param: TickParam<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: UnitMap[TypeName]);\n\tconstructor(options: Partial<TickSignalOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tTickSignal.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"value\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.input = this._param = new TickParam({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tmultiplier: options.multiplier,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): TickSignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this._param.ticksToTime(ticks, when);\n\t}\n\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\treturn this._param.timeToTicks(duration, when);\n\t}\n\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\treturn this._param.getTimeOfTick(tick);\n\t}\n\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\treturn this._param.getDurationOfTicks(ticks, time);\n\t}\n\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._param.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._param.multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\tthis._param.multiplier = m;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport {\n\tPlaybackState,\n\tStateTimeline,\n\tStateTimelineEvent,\n} from \"../util/StateTimeline.js\";\nimport { Timeline, TimelineEvent } from \"../util/Timeline.js\";\nimport { isDefined } from \"../util/TypeCheck.js\";\nimport { TickSignal } from \"./TickSignal.js\";\nimport { EQ } from \"../util/Math.js\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent extends TimelineEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\ninterface TickSourceTicksAtTimeEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\ttime: number;\n\tticks: number;\n}\n\ninterface TickSourceSecondsAtTimeEvent extends TimelineEvent {\n\tstate: PlaybackState;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<\n\tTypeName extends \"bpm\" | \"hertz\",\n> extends ToneWithContext<TickSourceOptions> {\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * Memoized values of getTicksAtTime at events with state other than \"started\"\n\t */\n\tprivate _ticksAtTime: Timeline<TickSourceTicksAtTimeEvent> =\n\t\tnew Timeline<TickSourceTicksAtTimeEvent>();\n\n\t/**\n\t * Memoized values of getSecondsAtTime at events with state other than \"started\"\n\t */\n\tprivate _secondsAtTime: Timeline<TickSourceSecondsAtTimeEvent> =\n\t\tnew Timeline<TickSourceSecondsAtTimeEvent>();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tTickSource.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign(\n\t\t\t{\n\t\t\t\tfrequency: 1,\n\t\t\t\tunits: \"hertz\" as const,\n\t\t\t},\n\t\t\tToneWithContext.getDefaults()\n\t\t);\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t\tthis._ticksAtTime.cancel(computedTime);\n\t\t\tthis._secondsAtTime.cancel(computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\tthis._ticksAtTime.cancel(computedTime);\n\t\tthis._secondsAtTime.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._ticksAtTime.cancel(computedTime);\n\t\t\tthis._secondsAtTime.cancel(computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._ticksAtTime.cancel(time);\n\t\tthis._secondsAtTime.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\n\t\t\t\"stopped\",\n\t\t\tcomputedTime\n\t\t) as StateTimelineEvent;\n\n\t\t// get previously memoized ticks if available\n\t\tconst memoizedEvent = this._ticksAtTime.get(computedTime);\n\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = {\n\t\t\tstate: \"paused\",\n\t\t\ttime: computedTime,\n\t\t};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = memoizedEvent ? memoizedEvent : stopEvent;\n\t\tlet elapsedTicks = memoizedEvent ? memoizedEvent.ticks : 0;\n\t\tlet eventToMemoize: TickSourceTicksAtTimeEvent | null = null;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(\n\t\t\tlastState.time,\n\t\t\tcomputedTime + this.sampleTime,\n\t\t\t(e) => {\n\t\t\t\tlet periodStartTime = lastState.time;\n\t\t\t\t// if there is an offset event in this period use that\n\t\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t\t}\n\t\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\t\telapsedTicks +=\n\t\t\t\t\t\tthis.frequency.getTicksAtTime(e.time) -\n\t\t\t\t\t\tthis.frequency.getTicksAtTime(periodStartTime);\n\t\t\t\t\t// do not memoize the temporary event\n\t\t\t\t\tif (e.time !== tmpEvent.time) {\n\t\t\t\t\t\teventToMemoize = {\n\t\t\t\t\t\t\tstate: e.state,\n\t\t\t\t\t\t\ttime: e.time,\n\t\t\t\t\t\t\tticks: elapsedTicks,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastState = e;\n\t\t\t}\n\t\t);\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// memoize the ticks at the most recent event with state other than \"started\"\n\t\tif (eventToMemoize) {\n\t\t\tthis._ticksAtTime.add(eventToMemoize);\n\t\t}\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\n\t\t\t\"stopped\",\n\t\t\ttime\n\t\t) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// get previously memoized seconds if available\n\t\tconst memoizedEvent = this._secondsAtTime.get(time);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = memoizedEvent ? memoizedEvent : stopEvent;\n\t\tlet elapsedSeconds = memoizedEvent ? memoizedEvent.seconds : 0;\n\t\tlet eventToMemoize: TickSourceSecondsAtTimeEvent | null = null;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(\n\t\t\tlastState.time,\n\t\t\ttime + this.sampleTime,\n\t\t\t(e) => {\n\t\t\t\tlet periodStartTime = lastState.time;\n\t\t\t\t// if there is an offset event in this period use that\n\t\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t\t}\n\t\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t\t\t// do not memoize the temporary event\n\t\t\t\t\tif (e.time !== tmpEvent.time) {\n\t\t\t\t\t\teventToMemoize = {\n\t\t\t\t\t\t\tstate: e.state,\n\t\t\t\t\t\t\ttime: e.time,\n\t\t\t\t\t\t\tseconds: elapsedSeconds,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastState = e;\n\t\t\t}\n\t\t);\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// memoize the seconds at the most recent event with state other than \"started\"\n\t\tif (eventToMemoize) {\n\t\t\tthis._secondsAtTime.add(eventToMemoize);\n\t\t}\n\n\t\t// return the seconds\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\tthis._ticksAtTime.cancel(time);\n\t\tthis._secondsAtTime.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks =\n\t\t\tthis.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(\n\t\tstartTime: number,\n\t\tendTime: number,\n\t\tcallback: (when: Seconds, ticks: Ticks) => void\n\t): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, (event) => {\n\t\t\tif (\n\t\t\t\tlastStateEvent &&\n\t\t\t\tlastStateEvent.state === \"started\" &&\n\t\t\t\tevent.state !== \"started\"\n\t\t\t) {\n\t\t\t\tthis.forEachTickBetween(\n\t\t\t\t\tMath.max(lastStateEvent.time, startTime),\n\t\t\t\t\tevent.time - this.sampleTime,\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(\n\t\t\t\tlastStateEvent.time\n\t\t\t);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(\n\t\t\t\tstartTicks + offset\n\t\t\t);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(\n\t\t\t\t\t\tnextTickTime,\n\t\t\t\t\t\tMath.round(this.getTicksAtTime(nextTickTime))\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(\n\t\t\t\t\t1,\n\t\t\t\t\tnextTickTime\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis._ticksAtTime.dispose();\n\t\tthis._secondsAtTime.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { noOp, readOnly } from \"../util/Interface.js\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline.js\";\nimport { TickSignal } from \"./TickSignal.js\";\nimport { TickSource } from \"./TickSource.js\";\nimport { assertContextRunning } from \"../util/Debug.js\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions>\n\timplements Emitter<ClockEvent>\n{\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\n\t\t\t\"callback\",\n\t\t\t\"frequency\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(\n\t\t\tcurrentTick + offset,\n\t\t\tcomputedTime\n\t\t);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, (e) => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(\n\t\t\t\tstartTime,\n\t\t\t\tendTime,\n\t\t\t\t(time, ticks) => {\n\t\t\t\t\tthis.callback(time, ticks);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (\n\t\tevent: ClockEvent,\n\t\tcallback?: ((...args: any[]) => void) | undefined\n\t) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { Param } from \"../context/Param.js\";\nimport { Seconds, Time } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { readOnly } from \"../util/Interface.js\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode.js\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst delay = new Tone.Delay(0.1).toDestination();\n * \t// connect the signal to both the delay and the destination\n * \tconst pulse = new Tone.PulseOscillator().connect(delay).toDestination();\n * \t// start and stop the pulse\n * \tpulse.start(0).stop(0.01);\n * }, 0.5, 1);\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\treadonly name: string = \"Delay\";\n\n\t/**\n\t * Private holder of the max delay time\n\t */\n\tprivate _maxDelay: Seconds;\n\n\t/**\n\t * The amount of time the incoming signal is delayed.\n\t * @example\n\t * const delay = new Tone.Delay().toDestination();\n\t * // modulate the delayTime between 0.1 and 1 seconds\n\t * const delayLFO = new Tone.LFO(0.5, 0.1, 1).start().connect(delay.delayTime);\n\t * const pulse = new Tone.PulseOscillator().connect(delay).start();\n\t * // the change in delayTime causes the pitch to go up and down\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * @param delayTime The delay applied to the incoming signal.\n\t * @param maxDelay The maximum delay time.\n\t */\n\tconstructor(delayTime?: Time, maxDelay?: Time);\n\tconstructor(options?: Partial<DelayOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\n\t\t\t\"delayTime\",\n\t\t\t\"maxDelay\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis._maxDelay = Math.max(\n\t\t\tmaxDelayInSeconds,\n\t\t\tthis.toSeconds(options.delayTime)\n\t\t);\n\n\t\tthis._delayNode =\n\t\t\tthis.input =\n\t\t\tthis.output =\n\t\t\t\tthis.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._delayNode.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t\tminValue: 0,\n\t\t\tmaxValue: this.maxDelay,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\tget maxDelay(): Seconds {\n\t\treturn this._maxDelay;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Decibels } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\treadonly name: string = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<\"decibels\">;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain<\"decibels\">;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t * The volume control in decibels.\n\t * @example\n\t * const vol = new Tone.Volume().toDestination();\n\t * const osc = new Tone.Oscillator().connect(vol).start();\n\t * vol.volume.value = -20;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume the initial volume in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<VolumeOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\n\t\t\t\"volume\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const vol = new Tone.Volume(-12).toDestination();\n\t * const osc = new Tone.Oscillator().connect(vol).start();\n\t * // mute the output\n\t * vol.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume.js\";\nimport { Decibels } from \"../type/Units.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization.js\";\nimport { Gain } from \"./Gain.js\";\nimport { Param } from \"./Param.js\";\nimport {\n\tconnectSeries,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"./ToneAudioNode.js\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.getDestination());\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\nexport class DestinationClass extends ToneAudioNode<DestinationOptions> {\n\treadonly name: string = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The volume of the master output in decibels. -Infinity is silent, and 0 is no change.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * osc.start();\n\t * // ramp the volume down to silent over 10 seconds\n\t * Tone.getDestination().volume.rampTo(-Infinity, 10);\n\t */\n\tvolume: Param<\"decibels\"> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tDestinationClass.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tconnectSeries(\n\t\t\tthis.input,\n\t\t\tthis.output,\n\t\t\tthis.context.rawContext.destination\n\t\t);\n\n\t\tthis.mute = options.mute;\n\t\tthis._internalChannels = [\n\t\t\tthis.input,\n\t\t\tthis.context.rawContext.destination,\n\t\t\tthis.output,\n\t\t];\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const oscillator = new Tone.Oscillator().start().toDestination();\n\t * setTimeout(() => {\n\t * \t// mute the output\n\t * \tTone.Destination.mute = true;\n\t * }, 1000);\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t * chained in the master effects chain.\n\t * @param args All arguments will be connected in a row and the Master will be routed through it.\n\t * @example\n\t * // route all audio through a filter and compressor\n\t * const lowpass = new Tone.Filter(800, \"lowpass\");\n\t * const compressor = new Tone.Compressor(-18);\n\t * Tone.Destination.chain(lowpass, compressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The maximum number of channels the system can output\n\t * @example\n\t * console.log(Tone.Destination.maxChannelCount);\n\t */\n\tget maxChannelCount(): number {\n\t\treturn this.context.rawContext.destination.maxChannelCount;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit((context) => {\n\tcontext.destination = new DestinationClass({ context });\n});\n\nonContextClose((context) => {\n\tcontext.destination.dispose();\n});\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode.js\";\nimport { Param } from \"./Param.js\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization.js\";\n\nexport interface ListenerOptions extends ToneAudioNodeOptions {\n\tpositionX: number;\n\tpositionY: number;\n\tpositionZ: number;\n\tforwardX: number;\n\tforwardY: number;\n\tforwardZ: number;\n\tupX: number;\n\tupY: number;\n\tupZ: number;\n}\n\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with {@link Panner3D} makes up the Web Audio API's 3D panning system. Panner3D allows you\n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context.\n */\nexport class ListenerClass extends ToneAudioNode<ListenerOptions> {\n\treadonly name: string = \"Listener\";\n\n\t/**\n\t * The listener has no inputs or outputs.\n\t */\n\toutput: undefined;\n\tinput: undefined;\n\n\treadonly positionX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionX,\n\t});\n\n\treadonly positionY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionY,\n\t});\n\n\treadonly positionZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionZ,\n\t});\n\n\treadonly forwardX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardX,\n\t});\n\n\treadonly forwardY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardY,\n\t});\n\n\treadonly forwardZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardZ,\n\t});\n\n\treadonly upX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upX,\n\t});\n\n\treadonly upY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upY,\n\t});\n\n\treadonly upZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upZ,\n\t});\n\n\tstatic getDefaults(): ListenerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpositionX: 0,\n\t\t\tpositionY: 0,\n\t\t\tpositionZ: 0,\n\t\t\tforwardX: 0,\n\t\t\tforwardY: 0,\n\t\t\tforwardZ: -1,\n\t\t\tupX: 0,\n\t\t\tupY: 1,\n\t\t\tupZ: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.positionX.dispose();\n\t\tthis.positionY.dispose();\n\t\tthis.positionZ.dispose();\n\t\tthis.forwardX.dispose();\n\t\tthis.forwardY.dispose();\n\t\tthis.forwardZ.dispose();\n\t\tthis.upX.dispose();\n\t\tthis.upY.dispose();\n\t\tthis.upZ.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit((context) => {\n\tcontext.listener = new ListenerClass({ context });\n});\n\nonContextClose((context) => {\n\tcontext.listener.dispose();\n});\n","import { getContext, setContext } from \"../Global.js\";\nimport { Seconds } from \"../type/Units.js\";\nimport { OfflineContext } from \"./OfflineContext.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\nimport \"./Destination.js\";\nimport \"./Listener.js\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of {@link Context} which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels = 2,\n\tsampleRate: number = getContext().sampleRate\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n","import { Tone } from \"../Tone.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { noOp } from \"../util/Interface.js\";\nimport { isString } from \"../util/TypeCheck.js\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer.js\";\nimport { assert } from \"../util/Debug.js\";\n\nexport interface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tA1: \"https://tonejs.github.io/audio/casio/A1.mp3\",\n * \tA2: \"https://tonejs.github.io/audio/casio/A2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"A2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t A1: \"A1.mp3\",\n * \t\t A2: \"A2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/audio/casio/\"\n * });\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n\treadonly name: string = \"ToneAudioBuffers\";\n\n\t/**\n\t * All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount = 0;\n\n\t/**\n\t * @param  urls  An object literal or array of urls to load.\n\t * @param onload  The callback to invoke when the buffers are loaded.\n\t * @param baseUrl A prefix url to add before all the urls\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"urls\", \"onload\", \"baseUrl\"],\n\t\t\t\"urls\"\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach((name) => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(\n\t\t\t\tname,\n\t\t\t\turl,\n\t\t\t\tthis._bufferLoaded.bind(this, options.onload),\n\t\t\t\toptions.onerror\n\t\t\t);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t * Get a buffer by name. If an array was loaded,\n\t * then use the array index.\n\t * @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tassert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t * A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t * Add a buffer by name and url to the Buffers\n\t * @param  name      A unique name to give the buffer\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t * @param  onerror  Invoked if the buffer can't be loaded\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t\tonerror: (e: Error) => void = noOp\n\t): this {\n\t\tif (isString(url)) {\n\t\t\t// don't include the baseUrl if the url is a base64 encoded sound\n\t\t\tif (\n\t\t\t\tthis.baseUrl &&\n\t\t\t\turl.trim().substring(0, 11).toLowerCase() === \"data:audio/\"\n\t\t\t) {\n\t\t\t\tthis.baseUrl = \"\";\n\t\t\t}\n\t\t\tthis._buffers.set(\n\t\t\t\tname.toString(),\n\t\t\t\tnew ToneAudioBuffer(this.baseUrl + url, callback, onerror)\n\t\t\t);\n\t\t} else {\n\t\t\tthis._buffers.set(\n\t\t\t\tname.toString(),\n\t\t\t\tnew ToneAudioBuffer(url, callback, onerror)\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach((buffer) => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global.js\";\nimport { ftom, mtof } from \"./Conversions.js\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency.js\";\nimport { TimeValue } from \"./TimeBase.js\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units.js\";\n\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @category Unit\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\treadonly name: string = \"MidiClass\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Midi(60).toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Midi(60).toFrequency(); // 261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return A new transposed MidiClass\n\t * @example\n\t * Tone.Midi(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global.js\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase.js\";\nimport { TransportTimeClass } from \"./TransportTime.js\";\nimport { Seconds, Ticks } from \"./Units.js\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\treadonly name: string = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor((seconds / (60 / this._getBpm())) * this._getPPQ());\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t * Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { Seconds, Time } from \"../type/Units.js\";\nimport { Timeline, TimelineEvent } from \"./Timeline.js\";\nimport {\n\tonContextClose,\n\tonContextInit,\n} from \"../context/ContextInitialization.js\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport class DrawClass extends ToneWithContext<ToneWithContextOptions> {\n\treadonly name: string = \"Draw\";\n\n\t/**\n\t * The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t * The amount of time before the scheduled time\n\t * that the callback can be invoked. Default is\n\t * half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t * All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame = -1;\n\n\t/**\n\t * Schedule a function at the given time to be invoked\n\t * on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t * @example\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tTone.Draw.schedule(() => console.log(time), time);\n\t * }, 1);\n\t * Tone.Transport.start();\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime: this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\tthis._events.forEachBefore(now + this.anticipation, (event) => {\n\t\t\tif (now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t\tthis._events.remove(event);\n\t\t});\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit((context) => {\n\tcontext.draw = new DrawClass({ context });\n});\n\nonContextClose((context) => {\n\tcontext.draw.dispose();\n});\n","import { Tone } from \"../Tone.js\";\nimport { isDefined } from \"./TypeCheck.js\";\nimport { assert } from \"./Debug.js\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n * @internal\n */\nexport class IntervalTimeline extends Tone {\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tassert(isDefined(event.time), \"Events must have a time property\");\n\t\tassert(\n\t\t\tisDefined(event.duration),\n\t\t\t\"Events must have a duration parameter\"\n\t\t);\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(\n\t\t\tevent.time,\n\t\t\tevent.time + event.duration,\n\t\t\tevent\n\t\t);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, (event) => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(\n\t\tnode: IntervalNode,\n\t\treplacement: IntervalNode | null\n\t): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse((node) => allNodes.push(node));\n\t\t\tallNodes.forEach((node) => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach((node) => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach((node) => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse((node) => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { Timeline, TimelineEvent } from \"./Timeline.js\";\nimport { Tone } from \"../Tone.js\";\nimport { Seconds } from \"../type/Units.js\";\n\ninterface TimelineValueEvent<T> extends TimelineEvent {\n\tvalue: T;\n}\n\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue<Type> extends Tone {\n\treadonly name: string = \"TimelineValue\";\n\n\t/**\n\t * The timeline which stores the values\n\t */\n\tprivate _timeline: Timeline<TimelineValueEvent<Type>> = new Timeline({\n\t\tmemory: 10,\n\t});\n\n\t/**\n\t * Hold the value to return if there is no scheduled values\n\t */\n\tprivate _initialValue: Type;\n\n\t/**\n\t * @param initialValue The value to return if there is no scheduled values\n\t */\n\tconstructor(initialValue: Type) {\n\t\tsuper();\n\t\tthis._initialValue = initialValue;\n\t}\n\n\t/**\n\t * Set the value at the given time\n\t */\n\tset(value: Type, time: Seconds): this {\n\t\tthis._timeline.add({\n\t\t\tvalue,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the value at the given time\n\t */\n\tget(time: Seconds): Type {\n\t\tconst event = this._timeline.get(time);\n\t\tif (event) {\n\t\t\treturn event.value;\n\t\t} else {\n\t\t\treturn this._initialValue;\n\t\t}\n\t}\n}\n","import { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport {\n\tInputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { connectSignal } from \"./Signal.js\";\n\nexport type SignalOperatorOptions = ToneAudioNodeOptions;\n\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<\n\tOptions extends SignalOperatorOptions,\n> extends ToneAudioNode<Options> {\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(\n\t\t\toptionsFromArguments(SignalOperator.getDefaults(), arguments, [\n\t\t\t\t\"context\",\n\t\t\t])\n\t\t);\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { Signal } from \"./Signal.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param length The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tWaveShaper.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"mapping\", \"length\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tif (\n\t\t\tisArray(options.mapping) ||\n\t\t\toptions.mapping instanceof Float32Array\n\t\t) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * const shaper = new Tone.WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some((str) =>\n\t\t\tstr.includes(oversampling)\n\t\t);\n\t\tassert(\n\t\t\tisOverSampleType,\n\t\t\t\"oversampling must be either 'none', '2x', or '4x'\"\n\t\t);\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { WaveShaper, WaveShaperMappingFn } from \"./WaveShaper.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\nimport { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\n\nexport interface PowOptions extends ToneAudioNodeOptions {\n\tvalue: number;\n}\n\n/**\n * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]\n *\n * @example\n * const pow = new Tone.Pow(2);\n * const sig = new Tone.Signal(0.5).connect(pow);\n * // output of pow is 0.25.\n * @category Signal\n */\nexport class Pow extends SignalOperator<PowOptions> {\n\treadonly name: string = \"Pow\";\n\n\tprivate _exponent: number;\n\n\tprivate _exponentScaler: WaveShaper;\n\n\tinput: WaveShaper;\n\n\toutput: WaveShaper;\n\n\t/**\n\t * @param value Constant exponent value to use\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<PowOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Pow.getDefaults(), arguments, [\n\t\t\t\"value\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._exponentScaler =\n\t\t\tthis.input =\n\t\t\tthis.output =\n\t\t\t\tnew WaveShaper({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tmapping: this._expFunc(options.value),\n\t\t\t\t\tlength: 8192,\n\t\t\t\t});\n\n\t\tthis._exponent = options.value;\n\t}\n\n\tstatic getDefaults(): PowOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\t/**\n\t * the function which maps the waveshaper\n\t * @param exponent exponent value\n\t */\n\tprivate _expFunc(exponent: number): WaveShaperMappingFn {\n\t\treturn (val: number) => {\n\t\t\treturn Math.pow(Math.abs(val), exponent);\n\t\t};\n\t}\n\n\t/**\n\t * The value of the exponent.\n\t */\n\tget value(): number {\n\t\treturn this._exponent;\n\t}\n\tset value(exponent: number) {\n\t\tthis._exponent = exponent;\n\t\tthis._exponentScaler.setMap(this._expFunc(this._exponent));\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponentScaler.dispose();\n\t\treturn this;\n\t}\n}\n","import { Seconds, Ticks } from \"../type/Units.js\";\nimport { noOp } from \"../util/Interface.js\";\nimport type { TransportClass as Transport } from \"./Transport.js\";\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by {@link TransportClass}\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\t/**\n\t * The remaining value between the passed in time, and Math.floor(time).\n\t * This value is later added back when scheduling to get sub-tick precision.\n\t */\n\tprotected _remainderTime = 0;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\t\tconst options: TransportEventOptions = Object.assign(\n\t\t\tTransportEvent.getDefaults(),\n\t\t\topts\n\t\t);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = Math.floor(options.time);\n\t\tthis._remainderTime = options.time - this.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId = 0;\n\n\t/**\n\t * Get the time and remainder time.\n\t */\n\tprotected get floatTime(): number {\n\t\treturn this.time + this._remainderTime;\n\t}\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tconst tickDuration = this.transport.bpm.getDurationOfTicks(1, time);\n\t\t\tthis.callback(time + this._remainderTime * tickDuration);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { BaseContext } from \"../context/BaseContext.js\";\nimport { TicksClass } from \"../type/Ticks.js\";\nimport { Seconds, Ticks, Time } from \"../type/Units.js\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent.js\";\nimport { GT, LT } from \"../util/Math.js\";\nimport type { TransportClass as Transport } from \"./Transport.js\";\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(\n\t\ttransport: Transport,\n\t\topts: Partial<TransportRepeatEventOptions>\n\t) {\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = options.duration;\n\t\tthis._interval = options.interval;\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.transport.on(\"ticks\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Create an event on the transport on the nextTick\n\t */\n\tprivate _createEvent(): number {\n\t\tif (LT(this._nextTick, this.floatTime + this.duration)) {\n\t\t\treturn this.transport.scheduleOnce(\n\t\t\t\tthis.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds()\n\t\t\t);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\t// const ticks = this.transport.getTicksAtTime(time);\n\t\t// if the next tick is within the bounds set by \"duration\"\n\t\tif (\n\t\t\tLT(this._nextTick + this._interval, this.floatTime + this.duration)\n\t\t) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(\n\t\t\t\tthis.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds()\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Re-compute the events when the transport time has changed from a start/ticks/loopStart event\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\t// start at the first event\n\t\tthis._nextTick = this.floatTime;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (GT(ticks, this.time)) {\n\t\t\t// the event is not being scheduled from the beginning and should be offset\n\t\t\tthis._nextTick =\n\t\t\t\tthis.floatTime +\n\t\t\t\tMath.ceil((ticks - this.floatTime) / this._interval) *\n\t\t\t\t\tthis._interval;\n\t\t}\n\t\tthis._currentId = this._createEvent();\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this._createEvent();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\tthis.transport.off(\"ticks\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { TimeClass } from \"../../core/type/Time.js\";\nimport { PlaybackState } from \"../../core/util/StateTimeline.js\";\nimport { TimelineValue } from \"../../core/util/TimelineValue.js\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { Pow } from \"../../signal/Pow.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport {\n\tonContextClose,\n\tonContextInit,\n} from \"../context/ContextInitialization.js\";\nimport { Gain } from \"../context/Gain.js\";\nimport {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../context/ToneWithContext.js\";\nimport { TicksClass } from \"../type/Ticks.js\";\nimport { TransportTimeClass } from \"../type/TransportTime.js\";\nimport {\n\tBarsBeatsSixteenths,\n\tBPM,\n\tNormalRange,\n\tSeconds,\n\tSubdivision,\n\tTicks,\n\tTime,\n\tTimeSignature,\n\tTransportTime,\n} from \"../type/Units.js\";\nimport { enterScheduledCallback } from \"../util/Debug.js\";\nimport { optionsFromArguments } from \"../util/Defaults.js\";\nimport { Emitter } from \"../util/Emitter.js\";\nimport { readOnly, writable } from \"../util/Interface.js\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline.js\";\nimport { Timeline } from \"../util/Timeline.js\";\nimport { isArray, isDefined } from \"../util/TypeCheck.js\";\nimport { Clock } from \"./Clock.js\";\nimport { TickParam } from \"./TickParam.js\";\nimport { TransportEvent } from \"./TransportEvent.js\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent.js\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames =\n\t| \"start\"\n\t| \"stop\"\n\t| \"pause\"\n\t| \"loop\"\n\t| \"loopEnd\"\n\t| \"loopStart\"\n\t| \"ticks\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tnodes: ToneAudioNode<any>[];\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.getTransport().scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.getTransport().start();\n * @category Core\n */\nexport class TransportClass\n\textends ToneWithContext<TransportOptions>\n\timplements Emitter<TransportEventNames>\n{\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * Tone.getTransport().bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Tone.getTransport().scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Tone.getTransport().start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Tone.getTransport().bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tTransportClass.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.setValueAtTime(options.bpm, 0);\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\n\t\t\t\t\t\"loopStart\",\n\t\t\t\t\ttickTime,\n\t\t\t\t\tthis._clock.getSecondsAtTime(tickTime)\n\t\t\t\t);\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// handle swing\n\t\tif (\n\t\t\tthis._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0\n\t\t) {\n\t\t\t// add some swing\n\t\t\tconst progress =\n\t\t\t\t(ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\t\t\ttickTime +=\n\t\t\t\tnew TicksClass(\n\t\t\t\t\tthis.context,\n\t\t\t\t\t(this._swingTicks * 2) / 3\n\t\t\t\t).toSeconds() * amount;\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tenterScheduledCallback(true);\n\t\tthis._timeline.forEachAtTime(ticks, (event) => event.invoke(tickTime));\n\t\tenterScheduledCallback(false);\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * // schedule an event on the 16th measure\n\t * Tone.getTransport().schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(\n\t\tcallback: TransportCallback,\n\t\ttime: TransportTime | TransportTimeClass\n\t): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Tone.getTransport().scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(\n\t\tcallback: TransportCallback,\n\t\ttime: TransportTime | TransportTimeClass\n\t): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(\n\t\tevent: TransportEvent,\n\t\ttimeline: Timeline<TransportEvent>\n\t): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, (event) =>\n\t\t\tthis.clear(event.id)\n\t\t);\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, (event) =>\n\t\t\tthis.clear(event.id)\n\t\t);\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Tone.getTransport().start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\t// start the context\n\t\tthis.context.resume();\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Tone.getTransport().stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * // common time\n\t * Tone.getTransport().timeSignature = 4;\n\t * // 7/8\n\t * Tone.getTransport().timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Tone.getTransport().timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * // loop over the first measure\n\t * Tone.getTransport().setLoopPoints(0, \"1m\");\n\t * Tone.getTransport().loop = true;\n\t */\n\tsetLoopPoints(\n\t\tstartPosition: TransportTime,\n\t\tendPosition: TransportTime\n\t): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the Transport.loop = false.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (\n\t\t\t\t(ticks - this._loopStart) / (this._loopEnd - this._loopStart)\n\t\t\t);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The Transport's current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\t\t// schedule to start on the next tick, #573\n\t\t\t\tconst remainingTick = this._clock.frequency.getDurationOfTicks(\n\t\t\t\t\tMath.ceil(ticks) - ticks,\n\t\t\t\t\tnow\n\t\t\t\t);\n\t\t\t\tconst time = now + remainingTick;\n\t\t\t\tthis.emit(\"stop\", time);\n\t\t\t\tthis._clock.setTicksAtTime(t, time);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n\t\t\t} else {\n\t\t\t\tthis.emit(\"ticks\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._clock.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * // the transport must be started, otherwise returns 0\n\t * Tone.getTransport().start();\n\t * Tone.getTransport().nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - (transportPos % subdivision);\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tconst now = this.now();\n\t\tlet source: TickParam<\"bpm\"> | ToneAudioNode<any> = this.bpm;\n\t\tlet sourceValue = 1 / (60 / source.getValueAtTime(now) / this.PPQ);\n\t\tlet nodes: ToneAudioNode<any>[] = [];\n\t\t// If the signal is in the time domain, sync it to the reciprocal of\n\t\t// the tempo instead of the tempo.\n\t\tif (signal.units === \"time\") {\n\t\t\t// The input to Pow should be in the range [1 / 4096, 1], where\n\t\t\t// where 4096 is half of the buffer size of Pow's waveshaper.\n\t\t\t// Pick a scaling factor based on the initial tempo that ensures\n\t\t\t// that the initial input is in this range, while leaving room for\n\t\t\t// tempo changes.\n\t\t\tconst scaleFactor = 1 / 64 / sourceValue;\n\t\t\tconst scaleBefore = new Gain(scaleFactor);\n\t\t\tconst reciprocal = new Pow(-1);\n\t\t\tconst scaleAfter = new Gain(scaleFactor);\n\t\t\t// @ts-ignore\n\t\t\tsource.chain(scaleBefore, reciprocal, scaleAfter);\n\t\t\tsource = scaleAfter;\n\t\t\tsourceValue = 1 / sourceValue;\n\t\t\tnodes = [scaleBefore, reciprocal, scaleAfter];\n\t\t}\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tratio = signal.getValueAtTime(now) / sourceValue;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tsource.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tnodes.push(ratioSignal);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tnodes: nodes,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * @see {@link syncSignal}.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.nodes.forEach((node) => node.dispose());\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (\n\t\tevent: TransportEventNames,\n\t\tcallback: (...args: any[]) => void\n\t) => this;\n\tonce!: (\n\t\tevent: TransportEventNames,\n\t\tcallback: (...args: any[]) => void\n\t) => this;\n\toff!: (\n\t\tevent: TransportEventNames,\n\t\tcallback?: ((...args: any[]) => void) | undefined\n\t) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(TransportClass);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit((context) => {\n\tcontext.transport = new TransportClass({ context });\n});\n\nonContextClose((context) => {\n\tcontext.transport.dispose();\n});\n","import { Volume } from \"../component/channel/Volume.js\";\nimport \"../core/context/Destination.js\";\nimport \"../core/clock/Transport.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport {\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units.js\";\nimport { defaultArg } from \"../core/util/Defaults.js\";\nimport { noOp, readOnly } from \"../core/util/Interface.js\";\nimport {\n\tBasicPlaybackState,\n\tStateTimeline,\n\tStateTimelineEvent,\n} from \"../core/util/StateTimeline.js\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck.js\";\nimport { assert, assertContextRunning } from \"../core/util/Debug.js\";\nimport { GT } from \"../core/util/Math.js\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<\n\tOptions extends SourceOptions,\n> extends ToneAudioNode<Options> {\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output node\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const source = new Tone.PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\t\tthis._state.increasing = true;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(\n\t\t\t\t\tthis.context.transport.seconds\n\t\t\t\t) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tprotected abstract _restart(\n\t\ttime: Seconds,\n\t\toffset?: Time,\n\t\tduration?: Time\n\t): void;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime =\n\t\t\tisUndef(time) && this._synced\n\t\t\t\t? this.context.transport.seconds\n\t\t\t\t: this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (\n\t\t\t!this._synced &&\n\t\t\tthis._state.getValueAtTime(computedTime) === \"started\"\n\t\t) {\n\t\t\t// time should be strictly greater than the previous start time\n\t\t\tassert(\n\t\t\t\tGT(\n\t\t\t\t\tcomputedTime,\n\t\t\t\t\t(this._state.get(computedTime) as StateTimelineEvent).time\n\t\t\t\t),\n\t\t\t\t\"Start time must be strictly greater than previous start time\"\n\t\t\t);\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration\n\t\t\t\t\t\t? this.toSeconds(duration)\n\t\t\t\t\t\t: undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule((t) => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if the transport is already started\n\t\t\t\t// and the time is greater than where the transport is\n\t\t\t\tif (\n\t\t\t\t\tthis.context.transport.state === \"started\" &&\n\t\t\t\t\tthis.context.transport.getSecondsAtTime(this.immediate()) >\n\t\t\t\t\t\tcomputedTime\n\t\t\t\t) {\n\t\t\t\t\tthis._syncedStart(\n\t\t\t\t\t\tthis.now(),\n\t\t\t\t\t\tthis.context.transport.seconds\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassertContextRunning(this.context);\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime =\n\t\t\tisUndef(time) && this._synced\n\t\t\t\t? this.context.transport.seconds\n\t\t\t\t: this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tif (\n\t\t\tthis._state.getValueAtTime(computedTime) === \"started\" ||\n\t\t\tisDefined(this._state.getNextState(\"started\", computedTime))\n\t\t) {\n\t\t\tthis.log(\"stop\", computedTime);\n\t\t\tif (!this._synced) {\n\t\t\t\tthis._stop(computedTime);\n\t\t\t} else {\n\t\t\t\tconst sched = this.context.transport.schedule(\n\t\t\t\t\tthis._stop.bind(this),\n\t\t\t\t\tcomputedTime\n\t\t\t\t);\n\t\t\t\tthis._scheduled.push(sched);\n\t\t\t}\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the source.\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._restart(time, offset, duration);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Tone.Transport.start();\n\t * // set it to loop once a second\n\t * Tone.Transport.loop = true;\n\t * Tone.Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (GT(offset, 0)) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (\n\t\t\t\t\t\tstateEvent &&\n\t\t\t\t\t\tstateEvent.state === \"started\" &&\n\t\t\t\t\t\tstateEvent.time !== offset\n\t\t\t\t\t) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset =\n\t\t\t\t\t\t\toffset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration: number | undefined;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration =\n\t\t\t\t\t\t\t\tthis.toSeconds(stateEvent.duration) -\n\t\t\t\t\t\t\t\tstartOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(\n\t\t\t\t\t\t\ttime,\n\t\t\t\t\t\t\tthis.toSeconds(stateEvent.offset) + startOffset,\n\t\t\t\t\t\t\tduration\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = (time) => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(\n\t\t\t\t\tMath.max(time - this.sampleTime, 0)\n\t\t\t\t);\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport.\n\t * @see {@link sync}\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach((id) => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\t// stop it also\n\t\tthis._stop(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/context/ToneAudioNode.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { isDefined } from \"../../core/util/TypeCheck.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport {\n\tOneShotSource,\n\tOneShotSourceCurve,\n\tOneShotSourceOptions,\n} from \"../OneShotSource.js\";\nimport { EQ, GTE, LT } from \"../../core/util/Math.js\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(\n\t\turl?: ToneAudioBuffer | AudioBuffer | string,\n\t\tonload?: () => void\n\t);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tToneBufferSource.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"url\", \"onload\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(\n\t\t\toptions.url,\n\t\t\toptions.onload,\n\t\t\toptions.onerror\n\t\t);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(\n\t\ttime?: Time,\n\t\toffset?: Time,\n\t\tduration?: Time,\n\t\tgain: GainFactor = 1\n\t): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd =\n\t\t\t\tthis.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset =\n\t\t\t\t\t((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd =\n\t\t\tthis.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer.js\";\nimport { Positive, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { Source, SourceOptions } from \"../source/Source.js\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource.js\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source<NoiseOptions> {\n\treadonly name: string = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\n\t\t\t\"type\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * const noise = new Tone.Noise().toDestination().start();\n\t * noise.type = \"brown\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tassert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t * internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\turl: buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(\n\t\t\tthis.toSeconds(time),\n\t\t\tMath.random() * (buffer.duration - 0.001)\n\t\t);\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\tprotected _restart(time?: Time): void {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + 0.02 * white) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.969 * b2 + white * 0.153852;\n\t\t\t\t\tb3 = 0.8665 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.016898;\n\t\t\t\t\tchannel[i] =\n\t\t\t\t\t\tb0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","import {\n\tconnect,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { Decibels } from \"../core/type/Units.js\";\nimport { Volume } from \"../component/channel/Volume.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { assert } from \"../core/util/Debug.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck.js\";\n\nexport interface UserMediaOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode<UserMediaOptions> {\n\treadonly name: string = \"UserMedia\";\n\n\treadonly input: undefined;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The MediaStreamNode\n\t */\n\tprivate _mediaStream?: MediaStreamAudioSourceNode;\n\n\t/**\n\t * The media stream created by getUserMedia.\n\t */\n\tprivate _stream?: MediaStream;\n\n\t/**\n\t * The open device\n\t */\n\tprivate _device?: MediaDeviceInfo;\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The level of the input in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<UserMediaOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tUserMedia.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"volume\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): UserMediaOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Open the media stream. If a string is passed in, it is assumed\n\t * to be the label or id of the stream, if a number is passed in,\n\t * it is the input number of the stream.\n\t * @param  labelOrId The label or id of the audio input media device.\n\t *                   With no argument, the default stream is opened.\n\t * @return The promise is resolved when the stream is open.\n\t */\n\tasync open(labelOrId?: string | number): Promise<this> {\n\t\tassert(UserMedia.supported, \"UserMedia is not supported\");\n\t\t// close the previous stream\n\t\tif (this.state === \"started\") {\n\t\t\tthis.close();\n\t\t}\n\t\tconst devices = await UserMedia.enumerateDevices();\n\t\tif (isNumber(labelOrId)) {\n\t\t\tthis._device = devices[labelOrId];\n\t\t} else {\n\t\t\tthis._device = devices.find((device) => {\n\t\t\t\treturn (\n\t\t\t\t\tdevice.label === labelOrId || device.deviceId === labelOrId\n\t\t\t\t);\n\t\t\t});\n\t\t\t// didn't find a matching device\n\t\t\tif (!this._device && devices.length > 0) {\n\t\t\t\tthis._device = devices[0];\n\t\t\t}\n\t\t\tassert(isDefined(this._device), `No matching device ${labelOrId}`);\n\t\t}\n\t\t// do getUserMedia\n\t\tconst constraints = {\n\t\t\taudio: {\n\t\t\t\techoCancellation: false,\n\t\t\t\tsampleRate: this.context.sampleRate,\n\t\t\t\tnoiseSuppression: false,\n\t\t\t\tmozNoiseSuppression: false,\n\t\t\t},\n\t\t};\n\t\tif (this._device) {\n\t\t\t// @ts-ignore\n\t\t\tconstraints.audio.deviceId = this._device.deviceId;\n\t\t}\n\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t// start a new source only if the previous one is closed\n\t\tif (!this._stream) {\n\t\t\tthis._stream = stream;\n\t\t\t// Wrap a MediaStreamSourceNode around the live input stream.\n\t\t\tconst mediaStreamNode =\n\t\t\t\tthis.context.createMediaStreamSource(stream);\n\t\t\t// Connect the MediaStreamSourceNode to a gate gain node\n\t\t\tconnect(mediaStreamNode, this.output);\n\t\t\tthis._mediaStream = mediaStreamNode;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Close the media stream\n\t */\n\tclose(): this {\n\t\tif (this._stream && this._mediaStream) {\n\t\t\tthis._stream.getAudioTracks().forEach((track) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tthis._stream = undefined;\n\t\t\t// remove the old media stream\n\t\t\tthis._mediaStream.disconnect();\n\t\t\tthis._mediaStream = undefined;\n\t\t}\n\t\tthis._device = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a promise which resolves with the list of audio input devices available.\n\t * @return The promise that is resolved with the devices\n\t * @example\n\t * Tone.UserMedia.enumerateDevices().then((devices) => {\n\t * \t// print the device labels\n\t * \tconsole.log(devices.map(device => device.label));\n\t * });\n\t */\n\tstatic async enumerateDevices(): Promise<MediaDeviceInfo[]> {\n\t\tconst allDevices = await navigator.mediaDevices.enumerateDevices();\n\t\treturn allDevices.filter((device) => {\n\t\t\treturn device.kind === \"audioinput\";\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, \"started\" when the microphone is open\n\t * and \"stopped\" when the mic is closed.\n\t */\n\tget state() {\n\t\treturn this._stream && this._stream.active ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * Returns an identifier for the represented device that is\n\t * persisted across sessions. It is un-guessable by other applications and\n\t * unique to the origin of the calling application. It is reset when the\n\t * user clears cookies (for Private Browsing, a different identifier is\n\t * used that is not persisted across sessions). Returns undefined when the\n\t * device is not open.\n\t */\n\tget deviceId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.deviceId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a group identifier. Two devices have the\n\t * same group identifier if they belong to the same physical device.\n\t * Returns null  when the device is not open.\n\t */\n\tget groupId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.groupId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a label describing this device (for example \"Built-in Microphone\").\n\t * Returns undefined when the device is not open or label is not available\n\t * because of permissions.\n\t */\n\tget label(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.label;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const mic = new Tone.UserMedia();\n\t * mic.open().then(() => {\n\t * \t// promise resolves when input is available\n\t * });\n\t * // mute the output\n\t * mic.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.close();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * If getUserMedia is supported by the browser.\n\t */\n\tstatic get supported(): boolean {\n\t\treturn (\n\t\t\tisDefined(navigator.mediaDevices) &&\n\t\t\tisDefined(navigator.mediaDevices.getUserMedia)\n\t\t);\n\t}\n}\n","import {\n\tAudioRange,\n\tCents,\n\tDegrees,\n\tFrequency,\n\tPositive,\n} from \"../../core/type/Units.js\";\nimport { Omit } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { SourceOptions } from \"../Source.js\";\nimport { OfflineContext } from \"../../core/context/OfflineContext.js\";\n\n/**\n * The common interface of all Oscillators\n */\nexport interface ToneOscillatorInterface {\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * osc.type = \"sine2\";\n\t * console.log(osc.baseType); // \"sine\"\n\t */\n\tbaseType: OscillatorType | \"pulse\" | \"pwm\";\n\n\t/**\n\t * The oscillator's type. Also capable of setting the first x number of partials of the oscillator.\n\t * For example: \"sine4\" would set be the first 4 partials of the sine wave and \"triangle8\" would\n\t * set the first 8 partials of the triangle wave.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.Oscillator().toDestination().start();\n\t * \tosc.type = \"sine2\";\n\t * }, 0.1, 1);\n\t */\n\ttype: ExtendedToneOscillatorType;\n\n\t/**\n\t * The frequency value of the oscillator\n\t * @example\n\t * const osc = new Tone.FMOscillator(\"Bb4\").toDestination().start();\n\t * osc.frequency.rampTo(\"D2\", 3);\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune value in cents (100th of a semitone).\n\t * @example\n\t * const osc = new Tone.PulseOscillator(\"F3\").toDestination().start();\n\t * // pitch it 1 octave = 12 semitones = 1200 cents\n\t * osc.detune.setValueAtTime(-1200, Tone.now());\n\t * osc.detune.setValueAtTime(1200, Tone.now() + 0.5);\n\t * osc.detune.linearRampToValueAtTime(0, Tone.now() + 1);\n\t * osc.stop(Tone.now() + 1.5);\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The phase is the starting position within the oscillator's cycle. For example\n\t * a phase of 180 would start halfway through the oscillator's cycle.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.Oscillator({\n\t * \t\tfrequency: 20,\n\t * \t\tphase: 90\n\t * \t}).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\tphase: Degrees;\n\n\t/**\n\t * The partials describes the relative amplitude of each of the harmonics of the oscillator.\n\t * The first value in the array is the first harmonic (i.e. the fundamental frequency), the\n\t * second harmonic is an octave up, the third harmonic is an octave and a fifth, etc. The resulting\n\t * oscillator output is composed of a sine tone at the relative amplitude at each of the harmonic intervals.\n\t *\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * const osc = new Tone.Oscillator(\"F3\").toDestination().start();\n\t * setInterval(() => {\n\t * \t// generate 8 random partials\n\t * \tosc.partials = new Array(8).fill(0).map(() => Math.random());\n\t * }, 1000);\n\t */\n\tpartials: number[];\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array. A square wave wave\n\t * is composed of only odd harmonics up through the harmonic series. Partial count\n\t * can limit the number of harmonics which are used to generate the waveform.\n\t * @example\n\t * const osc = new Tone.Oscillator(\"C3\", \"square\").toDestination().start();\n\t * osc.partialCount = 1;\n\t * setInterval(() => {\n\t * \tosc.partialCount++;\n\t * \tconsole.log(osc.partialCount);\n\t * }, 500);\n\t */\n\tpartialCount?: number;\n\n\t/**\n\t * Returns an array of values which represents the waveform.\n\t * @param length The length of the waveform to return\n\t */\n\tasArray(length: number): Promise<Float32Array>;\n}\n\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\nexport async function generateWaveform(\n\tinstance: any,\n\tlength: number\n): Promise<Float32Array> {\n\tconst duration = length / instance.context.sampleRate;\n\tconst context = new OfflineContext(\n\t\t1,\n\t\tduration,\n\t\tinstance.context.sampleRate\n\t);\n\tconst clone = new instance.constructor(\n\t\tObject.assign(instance.get(), {\n\t\t\t// should do 2 iterations\n\t\t\tfrequency: 2 / duration,\n\t\t\t// zero out the detune\n\t\t\tdetune: 0,\n\t\t\tcontext,\n\t\t})\n\t).toDestination();\n\tclone.start(0);\n\tconst buffer = await context.render();\n\treturn buffer.getChannelData(0);\n}\n\n/**\n * The supported number of partials\n */\ntype PartialsRange =\n\t| 1\n\t| 2\n\t| 3\n\t| 4\n\t| 5\n\t| 6\n\t| 7\n\t| 8\n\t| 9\n\t| 10\n\t| 11\n\t| 12\n\t| 13\n\t| 14\n\t| 15\n\t| 16\n\t| 17\n\t| 18\n\t| 19\n\t| 20\n\t| 21\n\t| 22\n\t| 23\n\t| 24\n\t| 25\n\t| 26\n\t| 27\n\t| 28\n\t| 29\n\t| 30\n\t| 31\n\t| 32;\n\n/**\n * Oscillators with partials\n */\ntype SineWithPartials = `sine${PartialsRange}`;\n\ntype SquareWithPartials = `square${PartialsRange}`;\n\ntype SawtoothWithPartials = `sawtooth${PartialsRange}`;\n\ntype TriangleWithPartials = `triangle${PartialsRange}`;\n\ntype TypeWithPartials =\n\t| SineWithPartials\n\t| SquareWithPartials\n\t| TriangleWithPartials\n\t| SawtoothWithPartials;\n\ninterface BaseOscillatorOptions extends SourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tphase: Degrees;\n}\n\nexport type NonCustomOscillatorType = Exclude<OscillatorType, \"custom\">;\n\ntype AllNonCustomOscillatorType = NonCustomOscillatorType | TypeWithPartials;\n\nexport type ToneOscillatorType = AllNonCustomOscillatorType | \"custom\";\n\nexport type ExtendedToneOscillatorType = ToneOscillatorType | \"pwm\" | \"pulse\";\n\n/**\n * Oscillator Interfaces\n */\ninterface ToneCustomOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface ToneTypeOscillatorOptions extends BaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface TonePartialOscillatorOptions extends BaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type ToneOscillatorConstructorOptions =\n\t| ToneCustomOscillatorOptions\n\t| ToneTypeOscillatorOptions\n\t| TonePartialOscillatorOptions;\n\nexport interface ToneOscillatorOptions extends BaseOscillatorOptions {\n\ttype: ToneOscillatorType;\n\tpartialCount: number;\n\tpartials: number[];\n}\n\n/**\n * FMOscillator Interface\n */\ninterface FMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface FMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface FMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FMConstructorOptions =\n\t| FMTypeOscillatorOptions\n\t| FMCustomOscillatorOptions\n\t| FMPartialsOscillatorOptions;\n\nexport interface FMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\n/**\n * AMOscillator Interface\n */\ninterface AMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface AMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface AMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface AMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type AMConstructorOptions =\n\t| AMCustomOscillatorOptions\n\t| AMTypeOscillatorOptions\n\t| AMPartialsOscillatorOptions;\n\nexport interface AMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n/**\n * FatOscillator\n */\ninterface FatBaseOscillatorOptions extends BaseOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\ninterface FatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface FatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FatConstructorOptions =\n\t| FatCustomOscillatorOptions\n\t| FatTypeOscillatorOptions\n\t| FatPartialsOscillatorOptions;\n\nexport interface FatOscillatorOptions extends ToneOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\n/**\n * Pulse Oscillator\n */\nexport interface PulseOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pulse\";\n\twidth: AudioRange;\n}\n\n/**\n * PWM Oscillator\n */\nexport interface PWMOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pwm\";\n\tmodulationFrequency: Frequency;\n}\n\n/**\n * OMNI OSCILLATOR\n */\n\n/**\n * FM Oscillators with partials\n */\ntype FMSineWithPartials = `fmsine${PartialsRange}`;\n\ntype FMSquareWithPartials = `fmsquare${PartialsRange}`;\n\ntype FMSawtoothWithPartials = `fmsawtooth${PartialsRange}`;\n\ntype FMTriangleWithPartials = `fmtriangle${PartialsRange}`;\n\ntype FMTypeWithPartials =\n\t| FMSineWithPartials\n\t| FMSquareWithPartials\n\t| FMSawtoothWithPartials\n\t| FMTriangleWithPartials;\n\n/**\n * AM Oscillators with partials\n */\ntype AMSineWithPartials = `amsine${PartialsRange}`;\n\ntype AMSquareWithPartials = `amsquare${PartialsRange}`;\n\ntype AMSawtoothWithPartials = `amsawtooth${PartialsRange}`;\n\ntype AMTriangleWithPartials = `amtriangle${PartialsRange}`;\n\ntype AMTypeWithPartials =\n\t| AMSineWithPartials\n\t| AMSquareWithPartials\n\t| AMSawtoothWithPartials\n\t| AMTriangleWithPartials;\n\n/**\n * Fat Oscillators with partials\n */\ntype FatSineWithPartials = `fatsine${PartialsRange}`;\n\ntype FatSquareWithPartials = `fatsquare${PartialsRange}`;\n\ntype FatSawtoothWithPartials = `fatsawtooth${PartialsRange}`;\n\ntype FatTriangleWithPartials = `fattriangle${PartialsRange}`;\n\ntype FatTypeWithPartials =\n\t| FatSineWithPartials\n\t| FatSquareWithPartials\n\t| FatSawtoothWithPartials\n\t| FatTriangleWithPartials;\n\n/**\n * Omni FM\n */\ninterface OmniFMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: FMTypeWithPartials;\n}\n\n/**\n * Omni AM\n */\ninterface OmniAMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amcustom\";\n\tpartials: number[];\n}\n\ninterface OmniAMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniAMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: AMTypeWithPartials;\n}\n\n/**\n * Omni Fat\n */\ninterface OmniFatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: FatTypeWithPartials;\n}\n\nexport type OmniOscillatorType =\n\t| \"fatsine\"\n\t| \"fatsquare\"\n\t| \"fatsawtooth\"\n\t| \"fattriangle\"\n\t| \"fatcustom\"\n\t| FatTypeWithPartials\n\t| \"fmsine\"\n\t| \"fmsquare\"\n\t| \"fmsawtooth\"\n\t| \"fmtriangle\"\n\t| \"fmcustom\"\n\t| FMTypeWithPartials\n\t| \"amsine\"\n\t| \"amsquare\"\n\t| \"amsawtooth\"\n\t| \"amtriangle\"\n\t| \"amcustom\"\n\t| AMTypeWithPartials\n\t| TypeWithPartials\n\t| OscillatorType\n\t| \"pulse\"\n\t| \"pwm\";\n\nexport type OmniOscillatorOptions =\n\t| PulseOscillatorOptions\n\t| PWMOscillatorOptions\n\t| OmniFatCustomOscillatorOptions\n\t| OmniFatTypeOscillatorOptions\n\t| OmniFatPartialsOscillatorOptions\n\t| OmniFMCustomOscillatorOptions\n\t| OmniFMTypeOscillatorOptions\n\t| OmniFMPartialsOscillatorOptions\n\t| OmniAMCustomOscillatorOptions\n\t| OmniAMTypeOscillatorOptions\n\t| OmniAMPartialsOscillatorOptions\n\t| ToneOscillatorConstructorOptions;\n\ntype OmitSourceOptions<T extends BaseOscillatorOptions> = Omit<\n\tT,\n\t\"frequency\" | \"detune\" | \"context\"\n>;\n\n/**\n * The settable options for the omni oscillator inside of the source which excludes certain attributes that are defined by the parent class\n */\nexport type OmniOscillatorSynthOptions =\n\t| OmitSourceOptions<PulseOscillatorOptions>\n\t| OmitSourceOptions<PWMOscillatorOptions>\n\t| OmitSourceOptions<OmniFatCustomOscillatorOptions>\n\t| OmitSourceOptions<OmniFatTypeOscillatorOptions>\n\t| OmitSourceOptions<OmniFatPartialsOscillatorOptions>\n\t| OmitSourceOptions<OmniFMCustomOscillatorOptions>\n\t| OmitSourceOptions<OmniFMTypeOscillatorOptions>\n\t| OmitSourceOptions<OmniFMPartialsOscillatorOptions>\n\t| OmitSourceOptions<OmniAMCustomOscillatorOptions>\n\t| OmitSourceOptions<OmniAMTypeOscillatorOptions>\n\t| OmitSourceOptions<OmniAMPartialsOscillatorOptions>\n\t| OmitSourceOptions<ToneCustomOscillatorOptions>\n\t| OmitSourceOptions<ToneTypeOscillatorOptions>\n\t| OmitSourceOptions<TonePartialOscillatorOptions>;\n","import { connect } from \"../../core/context/ToneAudioNode.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n\nexport interface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***{@link Oscillator} is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\treadonly name: string = \"ToneOscillatorNode\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(frequency: Frequency, type: OscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tToneOscillatorNode.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.frequency,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.detune,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tAudioRange,\n\tDegrees,\n\tFrequency,\n\tRadians,\n\tTime,\n} from \"../../core/type/Units.js\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { isDefined } from \"../../core/util/TypeCheck.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport {\n\tgenerateWaveform,\n\tToneOscillatorConstructorOptions,\n\tToneOscillatorInterface,\n\tToneOscillatorOptions,\n\tToneOscillatorType,\n} from \"./OscillatorInterface.js\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\nimport { clamp } from \"../../core/util/Math.js\";\nexport {\n\tToneOscillatorOptions,\n\tToneOscillatorType,\n} from \"./OscillatorInterface.js\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator\n\textends Source<ToneOscillatorOptions>\n\timplements ToneOscillatorInterface\n{\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = (this.baseType +\n\t\t\t\toptions.partialCount.toString()) as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\tprotected _restart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Tone.Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * @see {@link syncFrequency}\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t\twave: PeriodicWave;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave():\n\t\t| {\n\t\t\t\treal: Float32Array;\n\t\t\t\timag: Float32Array;\n\t\t\t\tpartials: number[];\n\t\t\t\twave: PeriodicWave;\n\t\t  }\n\t\t| undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(\n\t\t\t\t(description) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tdescription.phase === this._phase &&\n\t\t\t\t\t\tdeepEquals(description.partials, this._partials)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(\n\t\t\t\t(description) => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tdescription.type === this._type &&\n\t\t\t\t\t\tdescription.phase === this._phase\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t\tthis._partialCount = oscProps\n\t\t\t\t? oscProps.partialCount\n\t\t\t\t: this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType =\n\t\t\t[\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { partials, wave } = cache;\n\t\t\t\tthis._wave = wave;\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(\n\t\t\t\t\treal,\n\t\t\t\t\timag\n\t\t\t\t);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t\twave: this._wave,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(\n\t\t\tthis.partialCount.toString(),\n\t\t\t\"\"\n\t\t) as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (\n\t\t\tthis.partialCount &&\n\t\t\tthis._type !== \"custom\" &&\n\t\t\tbaseType !== \"custom\"\n\t\t) {\n\t\t\tthis.type = (baseType + this.partialCount) as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(\n\t\t\tthis._type\n\t\t);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = (type + p.toString()) as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => (fullPartials[i] = v));\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(\n\t\ttype: ToneOscillatorType,\n\t\tphase: Radians\n\t): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = n <= partialCount ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = n & 1 ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * (n & 1 ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb =\n\t\t\t\t\t\t\t2 *\n\t\t\t\t\t\t\t(piFactor * piFactor) *\n\t\t\t\t\t\t\t(((n - 1) >> 1) & 1 ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(\n\t\treal: Float32Array,\n\t\timag: Float32Array,\n\t\tphase: Radians\n\t): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum +=\n\t\t\t\treal[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(\n\t\t\t\tthis._inverseFFT(real, imag, (i / testPositions) * twoPi),\n\t\t\t\tmaxValue\n\t\t\t);\n\t\t}\n\t\treturn clamp(\n\t\t\t-this._inverseFFT(real, imag, this._phase) / maxValue,\n\t\t\t-1,\n\t\t\t1\n\t\t);\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = (phase * Math.PI) / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\nimport { WaveShaper } from \"./WaveShaper.js\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * @see {@link GainToAudio}.\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\treadonly name: string = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: (x) => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Signal, SignalOptions } from \"./Signal.js\";\nimport { InputNode, OutputNode } from \"../core/context/ToneAudioNode.js\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\nexport class Multiply<\n\tTypeName extends \"number\" | \"positive\" = \"number\",\n> extends Signal<TypeName> {\n\treadonly name: string = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain;\n\n\t/**\n\t * The multiplicand input.\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<TypeName>;\n\n\t/**\n\t * @param value Constant value to multiple\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMultiply.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"value\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._mult =\n\t\t\tthis.input =\n\t\t\tthis.output =\n\t\t\t\tnew Gain({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tminValue: options.minValue,\n\t\t\t\t\tmaxValue: options.maxValue,\n\t\t\t\t});\n\n\t\tthis.factor = this._param = this._mult\n\t\t\t.gain as unknown as Param<TypeName>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { Degrees, Frequency, Seconds } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { AudioToGain } from \"../../signal/AudioToGain.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport {\n\tAMConstructorOptions,\n\tAMOscillatorOptions,\n\tgenerateWaveform,\n\tNonCustomOscillatorType,\n\tToneOscillatorInterface,\n\tToneOscillatorType,\n} from \"./OscillatorInterface.js\";\n\nexport { AMOscillatorOptions } from \"./OscillatorInterface.js\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * }, 0.2, 1);\n * @category Source\n */\nexport class AMOscillator\n\textends Source<AMOscillatorOptions>\n\timplements ToneOscillatorInterface\n{\n\treadonly name: string = \"AMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const amOsc = new Tone.AMOscillator(\"D2\").toDestination().start();\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tamOsc.harmonicity.setValueAtTime(1, time);\n\t * \tamOsc.harmonicity.setValueAtTime(0.5, time + 0.5);\n\t * \tamOsc.harmonicity.setValueAtTime(1.5, time + 1);\n\t * \tamOsc.harmonicity.setValueAtTime(1, time + 2);\n\t * \tamOsc.harmonicity.linearRampToValueAtTime(2, time + 4);\n\t * }, 4);\n\t * Tone.Transport.start();\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\ttype?: ToneOscillatorType,\n\t\tmodulationType?: ToneOscillatorType\n\t);\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tAMOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\", \"modulationType\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\t(this.frequency = this._carrier.frequency),\n\t\t\t(this.detune = this._carrier.detune);\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport {\n\tFMConstructorOptions,\n\tFMOscillatorOptions,\n\tgenerateWaveform,\n\tNonCustomOscillatorType,\n\tToneOscillatorInterface,\n\tToneOscillatorType,\n} from \"./OscillatorInterface.js\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface.js\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator\n\textends Source<FMOscillatorOptions>\n\timplements ToneOscillatorInterface\n{\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const fmOsc = new Tone.FMOscillator(\"D2\").toDestination().start();\n\t * // pitch the modulator an octave below carrier\n\t * fmOsc.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\ttype?: ToneOscillatorType,\n\t\tmodulationType?: ToneOscillatorType\n\t);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFMOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\", \"modulationType\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\n\t\t\t\"modulationIndex\",\n\t\t\t\"frequency\",\n\t\t\t\"detune\",\n\t\t\t\"harmonicity\",\n\t\t]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tAudioRange,\n\tDegrees,\n\tFrequency,\n\tSeconds,\n\tTime,\n} from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { WaveShaper } from \"../../signal/WaveShaper.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport {\n\tgenerateWaveform,\n\tPulseOscillatorOptions,\n\tToneOscillatorInterface,\n} from \"./OscillatorInterface.js\";\n\nexport { PulseOscillatorOptions } from \"./OscillatorInterface.js\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PulseOscillator\n\textends Source<PulseOscillatorOptions>\n\timplements ToneOscillatorInterface\n{\n\treadonly name: string = \"PulseOscillator\";\n\n\t/**\n\t * The width of the pulse.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst pulse = new Tone.PulseOscillator(20, 0.8).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\treadonly width: Signal<\"audioRange\">;\n\n\t/**\n\t * gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * the sawtooth oscillator\n\t */\n\tprivate _triangle: Oscillator;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: (val) => (val <= 0 ? -1 : 1),\n\t});\n\n\t/**\n\t * @param frequency The frequency of the oscillator\n\t * @param width The width of the pulse\n\t */\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"width\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._triangle = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: \"triangle\",\n\t\t});\n\t\tthis.frequency = this._triangle.frequency;\n\t\tthis.detune = this._triangle.detune;\n\n\t\t// connections\n\t\tthis._triangle.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as const,\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._triangle.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._triangle.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._triangle.restart(time);\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._triangle.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._triangle.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * *Internal use* The carrier oscillator type is fed through the\n\t * waveshaper node to create the pulse. Using different carrier oscillators\n\t * changes oscillator's behavior.\n\t */\n\tset carrierType(type: \"triangle\" | \"sine\") {\n\t\tthis._triangle.type = type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._triangle.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tCents,\n\tDegrees,\n\tFrequency,\n\tSeconds,\n\tTime,\n} from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp, readOnly } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport {\n\tFatConstructorOptions,\n\tFatOscillatorOptions,\n\tgenerateWaveform,\n\tNonCustomOscillatorType,\n\tToneOscillatorInterface,\n\tToneOscillatorType,\n} from \"./OscillatorInterface.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface.js\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator\n\textends Source<FatOscillatorOptions>\n\timplements ToneOscillatorInterface\n{\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\ttype?: ToneOscillatorType,\n\t\tspread?: Cents\n\t);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFatOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\", \"spread\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach((osc) => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach((osc) => osc.stop(time));\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._forEach((osc) => osc.restart(time));\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach((osc) => (osc.type = type));\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => (osc.detune.value = start + step * i));\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach((osc) => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tvolume: -6 - count * 1.1,\n\t\t\t\t\ttype: this._type as NonCustomOscillatorType,\n\t\t\t\t\tphase: this._phase + (i / count) * 360,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t}\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.detune.overridden = false;\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach((osc) => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(\n\t\t\t(osc, i) => (osc.phase = this._phase + (i / this.count) * 360)\n\t\t);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach((osc) => (osc.baseType = baseType));\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach((osc) => (osc.partials = partials));\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach((osc) => (osc.partialCount = partialCount));\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach((osc) => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport {\n\tgenerateWaveform,\n\tPWMOscillatorOptions,\n\tToneOscillatorInterface,\n} from \"./OscillatorInterface.js\";\nimport { PulseOscillator } from \"./PulseOscillator.js\";\n\nexport { PWMOscillatorOptions } from \"./OscillatorInterface.js\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * return Tone.Offline(() => {\n * \tconst pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PWMOscillator\n\textends Source<PWMOscillatorOptions>\n\timplements ToneOscillatorInterface\n{\n\treadonly name: string = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t * the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t * the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Scale the oscillator so it doesn't go silent\n\t * at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The width modulation rate of the oscillator.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.PWMOscillator(20, 2).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\treadonly modulationFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param {Frequency} frequency The starting frequency of the oscillator.\n\t * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n\t */\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPWMOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"modulationFrequency\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\tthis._pulse.carrierType = \"sine\";\n\n\t\tthis.modulationFrequency = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as const,\n\t\t});\n\t}\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\tprotected _restart(time: Seconds): void {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tCents,\n\tDegrees,\n\tFrequency,\n\tSeconds,\n\tTime,\n} from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Source } from \"../Source.js\";\nimport { AMOscillator } from \"./AMOscillator.js\";\nimport { FatOscillator } from \"./FatOscillator.js\";\nimport { FMOscillator } from \"./FMOscillator.js\";\nimport { Oscillator } from \"./Oscillator.js\";\nimport {\n\tgenerateWaveform,\n\tOmniOscillatorOptions,\n\tOmniOscillatorType,\n\tToneOscillatorInterface,\n\tToneOscillatorType,\n} from \"./OscillatorInterface.js\";\nimport { PulseOscillator } from \"./PulseOscillator.js\";\nimport { PWMOscillator } from \"./PWMOscillator.js\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface.js\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator =\n\t| Oscillator\n\t| PWMOscillator\n\t| PulseOscillator\n\t| FatOscillator\n\t| AMOscillator\n\t| FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\tfm: FMOscillator;\n\tam: AMOscillator;\n\tpwm: PWMOscillator;\n\tpulse: PulseOscillator;\n\toscillator: Oscillator;\n\tfat: FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator\n\t? Ret\n\t: Osc extends FMOscillator\n\t\t? Ret\n\t\t: undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator\n\t? Ret\n\t: undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor;\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\">\n{\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tOmniOscillator.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults()\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some((p) => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn (prefix + this._oscillator.type) as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = type as ToneOscillatorType;\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @see {@link Oscillator.partials}\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (\n\t\t\t!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\")\n\t\t) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (\n\t\t\t!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\")\n\t\t) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (\n\t\t\tthis._oscillator.type !== \"pwm\" &&\n\t\t\tthis._oscillator.type !== \"pulse\"\n\t\t) {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = (\"fm\" + baseType) as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = (\"am\" + baseType) as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = (\"fat\" + baseType) as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator.\n\t * @see {@link Oscillator.baseType}\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n\t * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (\n\t\t\t!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" &&\n\t\t\tbaseType !== \"pwm\"\n\t\t) {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * @see {@link PWMOscillator}\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<\n\t\t\t\tOscType,\n\t\t\t\tSignal<\"audioRange\">\n\t\t\t>;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<\n\t\t\t\tOscType,\n\t\t\t\tSignal<\"audioRange\">\n\t\t\t>;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * @see {@link FatOscillator.count}\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * @see {@link FatOscillator.count}\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n\t * @see {@link AMOscillator} or {@link FMOscillator}\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (\n\t\t\tthis._getOscType(this._oscillator, \"fm\") ||\n\t\t\tthis._getOscType(this._oscillator, \"am\")\n\t\t) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<\n\t\t\t\tOscType,\n\t\t\t\tToneOscillatorType\n\t\t\t>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif (\n\t\t\t(this._getOscType(this._oscillator, \"fm\") ||\n\t\t\t\tthis._getOscType(this._oscillator, \"am\")) &&\n\t\t\tisString(mType)\n\t\t) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * @see {@link FMOscillator}.\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<\n\t\t\t\tOscType,\n\t\t\t\tSignal<\"positive\">\n\t\t\t>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * @see {@link AMOscillator} or {@link FMOscillator}\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (\n\t\t\tthis._getOscType(this._oscillator, \"fm\") ||\n\t\t\tthis._getOscType(this._oscillator, \"am\")\n\t\t) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<\n\t\t\t\tOscType,\n\t\t\t\tSignal<\"positive\">\n\t\t\t>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see {@link PWMOscillator}\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<\n\t\t\t\tOscType,\n\t\t\t\tSignal<\"frequency\">\n\t\t\t>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/context/ToneAudioNode.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Signal, SignalOptions } from \"./Signal.js\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst add = new Tone.Add(2).toDestination();\n * \tadd.addend.setValueAtTime(1, 0.2);\n * \tconst signal = new Tone.Signal(2);\n * \t// add a signal and a scalar\n * \tsignal.connect(add);\n * \tsignal.setValueAtTime(1, 0.1);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Add extends Signal {\n\toverride = false;\n\n\treadonly name: string = \"Add\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value If no value is provided, will sum the input and {@link addend}.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"]));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Add } from \"./Add.js\";\nimport { Multiply } from \"./Multiply.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n\nexport interface ScaleOptions extends ToneAudioNodeOptions {\n\tmin: number;\n\tmax: number;\n}\n\n/**\n * Performs a linear scaling on an input signal.\n * Scales a NormalRange input to between\n * outputMin and outputMax.\n *\n * @example\n * const scale = new Tone.Scale(50, 100);\n * const signal = new Tone.Signal(0.5).connect(scale);\n * // the output of scale equals 75\n * @category Signal\n */\nexport class Scale<\n\tOptions extends ScaleOptions = ScaleOptions,\n> extends SignalOperator<Options> {\n\treadonly name: string = \"Scale\";\n\n\tinput: InputNode;\n\toutput: OutputNode;\n\n\t/**\n\t * Hold the multiple\n\t */\n\tprotected _mult: Multiply;\n\n\t/**\n\t * Hold the adder\n\t */\n\tprotected _add: Add;\n\n\t/**\n\t * Private reference to the min value\n\t */\n\tprivate _min: number;\n\n\t/**\n\t * Private reference to the max value\n\t */\n\tprivate _max: number;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t */\n\tconstructor(min?: number, max?: number);\n\tconstructor(options?: Partial<ScaleOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Scale.getDefaults(), arguments, [\n\t\t\t\"min\",\n\t\t\t\"max\",\n\t\t]);\n\t\tsuper(options as Options);\n\n\t\tthis._mult = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.max - options.min,\n\t\t});\n\n\t\tthis._add = this.output = new Add({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.min,\n\t\t});\n\n\t\tthis._min = options.min;\n\t\tthis._max = options.max;\n\n\t\tthis.input.connect(this.output);\n\t}\n\n\tstatic getDefaults(): ScaleOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The minimum output value. This number is output when the value input value is 0.\n\t */\n\tget min(): number {\n\t\treturn this._min;\n\t}\n\tset min(min) {\n\t\tthis._min = min;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * The maximum output value. This number is output when the value input value is 1.\n\t */\n\tget max(): number {\n\t\treturn this._max;\n\t}\n\tset max(max) {\n\t\tthis._max = max;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * set the values\n\t */\n\tprivate _setRange(): void {\n\t\tthis._add.value = this._min;\n\t\tthis._mult.value = this._max - this._min;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._add.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain.js\";\nimport {\n\tconnect,\n\tdisconnect,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\treadonly name: string = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context: this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Zero.getDefaults(), arguments));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n} from \"../../core/context/ToneAudioNode.js\";\nimport {\n\tDegrees,\n\tFrequency,\n\tNormalRange,\n\tTime,\n\tUnitName,\n} from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline.js\";\nimport { AudioToGain } from \"../../signal/AudioToGain.js\";\nimport { Scale } from \"../../signal/Scale.js\";\nimport { connectSignal, Signal } from \"../../signal/Signal.js\";\nimport { Zero } from \"../../signal/Zero.js\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator.js\";\nimport {\n\tToneOscillatorConstructorOptions,\n\tToneOscillatorOptions,\n} from \"./OscillatorInterface.js\";\n\nexport type LFOOptions = {\n\tmin: number;\n\tmax: number;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n} & ToneOscillatorOptions;\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the {@link units}\n\t */\n\tconvert = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\n\t\t\t\"frequency\",\n\t\t\t\"min\",\n\t\t\t\"max\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._oscillator = new Oscillator(\n\t\t\toptions as ToneOscillatorConstructorOptions\n\t\t);\n\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.units = options.units;\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\ttype: \"sine\",\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * const lfo = new Tone.LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n\t */\n\tprivate _setStoppedValue() {\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator.\n\t * @see {@link Oscillator.type}\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The oscillator's partials array.\n\t * @see {@link Oscillator.partials}\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tthis._oscillator.partials = partials;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\t// @ts-ignore\n\tprivate _clampValue = Param.prototype._clampValue;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n","import { assertRange } from \"./Debug.js\";\nimport { Time } from \"../type/Units.js\";\n\n/**\n * Assert that the number is in the given range.\n */\nexport function range(min: number, max = Infinity) {\n\tconst valueMap: WeakMap<any, number> = new WeakMap();\n\treturn function (target: any, propertyKey: string | symbol) {\n\t\tReflect.defineProperty(target, propertyKey, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn valueMap.get(this);\n\t\t\t},\n\t\t\tset: function (newValue: number) {\n\t\t\t\tassertRange(newValue, min, max);\n\t\t\t\tvalueMap.set(this, newValue);\n\t\t\t},\n\t\t});\n\t};\n}\n\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\nexport function timeRange(min: number, max = Infinity) {\n\tconst valueMap: WeakMap<any, Time> = new WeakMap();\n\treturn function (target: any, propertyKey: string) {\n\t\tReflect.defineProperty(target, propertyKey, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn valueMap.get(this);\n\t\t\t},\n\t\t\tset: function (newValue: Time) {\n\t\t\t\tassertRange(this.toSeconds(newValue), min, max);\n\t\t\t\tvalueMap.set(this, newValue);\n\t\t\t},\n\t\t});\n\t};\n}\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { Positive, Seconds, Time } from \"../../core/type/Units.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { isUndef } from \"../../core/util/TypeCheck.js\";\nimport { Source, SourceOptions } from \"../Source.js\";\nimport { ToneBufferSource } from \"./ToneBufferSource.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\nimport { timeRange } from \"../../core/util/Decorator.js\";\n\nexport interface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source<PlayerOptions> {\n\treadonly name: string = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t */\n\tautostart: boolean;\n\n\t/**\n\t * The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t * if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t * if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t * the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(\n\t\turl?: string | AudioBuffer | ToneAudioBuffer,\n\t\tonload?: () => void\n\t);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\n\t\t\t\"url\",\n\t\t\t\"onload\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart: false,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (\n\t\t\tthis._activeSources.size === 0 &&\n\t\t\t!this._synced &&\n\t\t\tthis._state.getValueAtTime(this.now()) === \"started\"\n\t\t) {\n\t\t\t// remove the 'implicitEnd' event and replace with an explicit end\n\t\t\tthis._state.cancel(this.now());\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Play the buffer at the given startTime. Optionally add an offset\n\t * and/or duration which will play the buffer from a position\n\t * within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopStart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tconst computedOffset = this.toSeconds(offset);\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(\n\t\t\tduration,\n\t\t\tMath.max(this._buffer.duration - computedOffset, 0)\n\t\t);\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\turl: this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this.fadeIn,\n\t\t\tfadeOut: this.fadeOut,\n\t\t\tloop: this._loop,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\tloopStart: this._loopStart,\n\t\t\tonended: this._onSourceEnd.bind(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// cancel the previous stop\n\t\t\tthis._state.cancel(startTime + computedDuration);\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\n\t\t\t\t\"stopped\",\n\t\t\t\tstartTime + computedDuration,\n\t\t\t\t{\n\t\t\t\t\timplicitEnd: true,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, computedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(\n\t\t\t\tstartTime,\n\t\t\t\tcomputedOffset,\n\t\t\t\tcomputedDuration - this.toSeconds(this.fadeOut)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach((source) => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given,\n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\t[...this._activeSources].pop()?.stop(time); // explicitly stop only the most recently created source, to avoid edge case when > 1 source exists and _stop() erroneously sets all stop times past original end offset\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Seek to a specific time in the player's buffer. If the\n\t * source is no longer playing at that time, it will stop.\n\t * @param offset The time to seek to.\n\t * @param when The time for the seek event to occur.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n\t * \tplayer.start();\n\t * \t// seek to the offset in 1 second from now\n\t * \tplayer.seek(0.4, \"+1\");\n\t * }).toDestination();\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst computedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, computedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop start time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n\t * // loop between the given points\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Normal speed is 1. The pitch will change with the playback rate.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n\t * // play at 1/4 speed\n\t * player.playbackRate = 0.25;\n\t * // play as soon as the buffer is loaded\n\t * player.autostart = true;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach((source) => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * If the buffer should be reversed. Note that this sets the underlying {@link ToneAudioBuffer.reverse}, so\n\t * if multiple players are pointing at the same ToneAudioBuffer, they will all be reversed.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n\t * player.autostart = true;\n\t * player.reverse = true;\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach((source) => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport {\n\tToneAudioBuffers,\n\tToneAudioBuffersUrlMap,\n} from \"../../core/context/ToneAudioBuffers.js\";\nimport { OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { Decibels, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { noOp, readOnly } from \"../../core/util/Interface.js\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline.js\";\nimport { Source, SourceOptions } from \"../Source.js\";\nimport { Player } from \"./Player.js\";\n\nexport interface PlayersOptions extends SourceOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tvolume: Decibels;\n\tmute: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Players combines multiple {@link Player} objects.\n * @category Source\n */\nexport class Players extends ToneAudioNode<PlayersOptions> {\n\treadonly name: string = \"Players\";\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * The combined output of all of the players\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * Players has no input.\n\t */\n\treadonly input = undefined;\n\n\t/**\n\t * The container of all of the players\n\t */\n\tprivate _players: Map<string, Player> = new Map();\n\n\t/**\n\t * The container of all the buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * private holder of the fadeIn time\n\t */\n\tprivate _fadeIn: Time;\n\n\t/**\n\t * private holder of the fadeOut time\n\t */\n\tprivate _fadeOut: Time;\n\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param onload The function to invoke when all buffers are loaded.\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void);\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param options The remaining options associated with the players\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\toptions?: Partial<Omit<PlayersOptions, \"urls\">>\n\t);\n\tconstructor(options?: Partial<PlayersOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPlayers.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"urls\", \"onload\"],\n\t\t\t\"urls\"\n\t\t);\n\t\tsuper(options);\n\n\t\t/**\n\t\t * The output volume node\n\t\t */\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: options.urls,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\t// mute initially\n\t\tthis.mute = options.mute;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayersOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tbaseUrl: \"\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tmute: false,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\turls: {},\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t/**\n\t * The fadeIn time of the envelope applied to the source.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(fadeIn) {\n\t\tthis._fadeIn = fadeIn;\n\t\tthis._players.forEach((player) => {\n\t\t\tplayer.fadeIn = fadeIn;\n\t\t});\n\t}\n\n\t/**\n\t * The fadeOut time of the each of the sources.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(fadeOut) {\n\t\tthis._fadeOut = fadeOut;\n\t\tthis._players.forEach((player) => {\n\t\t\tplayer.fadeOut = fadeOut;\n\t\t});\n\t}\n\n\t/**\n\t * The state of the players object. Returns \"started\" if any of the players are playing.\n\t */\n\tget state(): BasicPlaybackState {\n\t\tconst playing = Array.from(this._players).some(\n\t\t\t([_, player]) => player.state === \"started\"\n\t\t);\n\t\treturn playing ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param name  The key or index of the buffer.\n\t */\n\thas(name: string): boolean {\n\t\treturn this._buffers.has(name);\n\t}\n\n\t/**\n\t * Get a player by name.\n\t * @param  name  The players name as defined in the constructor object or `add` method.\n\t */\n\tplayer(name: string): Player {\n\t\tassert(\n\t\t\tthis.has(name),\n\t\t\t`No Player with the name ${name} exists on this object`\n\t\t);\n\t\tif (!this._players.has(name)) {\n\t\t\tconst player = new Player({\n\t\t\t\tcontext: this.context,\n\t\t\t\tfadeIn: this._fadeIn,\n\t\t\t\tfadeOut: this._fadeOut,\n\t\t\t\turl: this._buffers.get(name),\n\t\t\t}).connect(this.output);\n\t\t\tthis._players.set(name, player);\n\t\t}\n\t\treturn this._players.get(name) as Player;\n\t}\n\n\t/**\n\t * If all the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Add a player by name and url to the Players\n\t * @param  name A unique name to give the player\n\t * @param  url  Either the url of the bufer or a buffer which will be added with the given name.\n\t * @param callback  The callback to invoke when the url is loaded.\n\t * @example\n\t * const players = new Tone.Players();\n\t * players.add(\"gong\", \"https://tonejs.github.io/audio/berklee/gong_1.mp3\", () => {\n\t * \tconsole.log(\"gong loaded\");\n\t * \tplayers.player(\"gong\").start();\n\t * });\n\t */\n\tadd(\n\t\tname: string,\n\t\turl: string | ToneAudioBuffer | AudioBuffer,\n\t\tcallback?: () => void\n\t): this {\n\t\tassert(\n\t\t\t!this._buffers.has(name),\n\t\t\t\"A buffer with that name already exists on this object\"\n\t\t);\n\t\tthis._buffers.add(name, url, callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop all of the players at the given time\n\t * @param time The time to stop all of the players.\n\t */\n\tstopAll(time?: Time): this {\n\t\tthis._players.forEach((player) => player.stop(time));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._players.forEach((player) => player.dispose());\n\t\tthis._buffers.dispose();\n\t\treturn this;\n\t}\n}\n","import { Source, SourceOptions } from \"../Source.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Clock } from \"../../core/clock/Clock.js\";\nimport { Cents, Positive, Seconds, Time } from \"../../core/type/Units.js\";\nimport { ToneBufferSource } from \"./ToneBufferSource.js\";\nimport { intervalToFrequencyRatio } from \"../../core/type/Conversions.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\n\ninterface GrainPlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\treverse: boolean;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n\toverlap: Seconds;\n\tgrainSize: Seconds;\n\tplaybackRate: Positive;\n\tdetune: Cents;\n\tloop: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n}\n\n/**\n * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the\n * amount of time each small chunk of audio is played for and the overlap is the\n * amount of crossfading transition time between successive grains.\n * @category Source\n */\nexport class GrainPlayer extends Source<GrainPlayerOptions> {\n\treadonly name: string = \"GrainPlayer\";\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tbuffer: ToneAudioBuffer;\n\n\t/**\n\t * Create a repeating tick to schedule the grains.\n\t */\n\tprivate _clock: Clock;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopStart = 0;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopEnd = 0;\n\n\t/**\n\t * All of the currently playing BufferSources\n\t */\n\tprivate _activeSources: ToneBufferSource[] = [];\n\n\t/**\n\t * Internal reference to the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * Internal grain size reference;\n\t */\n\tprivate _grainSize: Seconds;\n\n\t/**\n\t * Internal overlap reference;\n\t */\n\tprivate _overlap: Seconds;\n\n\t/**\n\t * Adjust the pitch independently of the playbackRate.\n\t */\n\tdetune: Cents;\n\n\t/**\n\t * If the buffer should loop back to the loopStart when completed\n\t */\n\tloop: boolean;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(\n\t\turl?: string | AudioBuffer | ToneAudioBuffer,\n\t\tonload?: () => void\n\t);\n\tconstructor(options?: Partial<GrainPlayerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tGrainPlayer.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"url\", \"onload\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.buffer = new ToneAudioBuffer({\n\t\t\tonload: options.onload,\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis._clock = new Clock({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tfrequency: 1 / options.grainSize,\n\t\t});\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._grainSize = options.grainSize;\n\t\tthis._overlap = options.overlap;\n\t\tthis.detune = options.detune;\n\n\t\t// setup\n\t\tthis.overlap = options.overlap;\n\t\tthis.loop = options.loop;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.grainSize = options.grainSize;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.reverse = options.reverse;\n\t\tthis._clock.on(\"stop\", this._onstop.bind(this));\n\t}\n\n\tstatic getDefaults(): GrainPlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\toverlap: 0.1,\n\t\t\tgrainSize: 0.2,\n\t\t\tplaybackRate: 1,\n\t\t\tdetune: 0,\n\t\t\tloop: false,\n\t\t\tloopStart: 0,\n\t\t\tloopEnd: 0,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(time?: Time, offset?: Time, duration?: Time): void {\n\t\toffset = defaultArg(offset, 0);\n\t\toffset = this.toSeconds(offset);\n\t\ttime = this.toSeconds(time);\n\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tthis._clock.start(time, offset / grainSize);\n\n\t\tif (duration) {\n\t\t\tthis.stop(time + this.toSeconds(duration));\n\t\t}\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given,\n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tthis._clock.stop(time);\n\t}\n\n\t/**\n\t * Invoked when the clock is stopped\n\t */\n\tprivate _onstop(time: Seconds): void {\n\t\t// stop the players\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.fadeOut = 0;\n\t\t\tsource.stop(time);\n\t\t});\n\t\tthis.onstop(this);\n\t}\n\n\t/**\n\t * Invoked on each clock tick. scheduled a new grain at this time.\n\t */\n\tprivate _tick(time: Seconds): void {\n\t\t// check if it should stop looping\n\t\tconst ticks = this._clock.getTicksAtTime(time);\n\t\tconst offset = ticks * this._grainSize;\n\t\tthis.log(\"offset\", offset);\n\n\t\tif (!this.loop && offset > this.buffer.duration) {\n\t\t\tthis.stop(time);\n\t\t\treturn;\n\t\t}\n\n\t\t// at the beginning of the file, the fade in should be 0\n\t\tconst fadeIn = offset < this._overlap ? 0 : this._overlap;\n\n\t\t// create a buffer source\n\t\tconst source = new ToneBufferSource({\n\t\t\tcontext: this.context,\n\t\t\turl: this.buffer,\n\t\t\tfadeIn: fadeIn,\n\t\t\tfadeOut: this._overlap,\n\t\t\tloop: this.loop,\n\t\t\tloopStart: this._loopStart,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\t// compute the playbackRate based on the detune\n\t\t\tplaybackRate: intervalToFrequencyRatio(this.detune / 100),\n\t\t}).connect(this.output);\n\n\t\tsource.start(time, this._grainSize * ticks);\n\t\tsource.stop(time + this._grainSize / this.playbackRate);\n\n\t\t// add it to the active sources\n\t\tthis._activeSources.push(source);\n\t\t// remove it when it's done\n\t\tsource.onended = () => {\n\t\t\tconst index = this._activeSources.indexOf(source);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis._activeSources.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * The playback rate of the sample\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tassertRange(rate, 0.001);\n\t\tthis._playbackRate = rate;\n\t\tthis.grainSize = this._grainSize;\n\t}\n\n\t/**\n\t * The loop start time.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(time) {\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(time), 0, this.buffer.duration);\n\t\t}\n\t\tthis._loopStart = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The loop end time.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(time) {\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(time), 0, this.buffer.duration);\n\t\t}\n\t\tthis._loopEnd = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse() {\n\t\treturn this.buffer.reverse;\n\t}\n\n\tset reverse(rev) {\n\t\tthis.buffer.reverse = rev;\n\t}\n\n\t/**\n\t * The size of each chunk of audio that the\n\t * buffer is chopped into and played back at.\n\t */\n\tget grainSize(): Time {\n\t\treturn this._grainSize;\n\t}\n\tset grainSize(size) {\n\t\tthis._grainSize = this.toSeconds(size);\n\t\tthis._clock.frequency.setValueAtTime(\n\t\t\tthis._playbackRate / this._grainSize,\n\t\t\tthis.now()\n\t\t);\n\t}\n\n\t/**\n\t * The duration of the cross-fade between successive grains.\n\t */\n\tget overlap(): Time {\n\t\treturn this._overlap;\n\t}\n\tset overlap(time) {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassertRange(computedTime, 0);\n\t\tthis._overlap = computedTime;\n\t}\n\n\t/**\n\t * If all the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this.buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.buffer.dispose();\n\t\tthis._clock.dispose();\n\t\tthis._activeSources.forEach((source) => source.dispose());\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\nimport { WaveShaper } from \"./WaveShaper.js\";\n\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst abs = new Tone.Abs().toDestination();\n * \tconst signal = new Tone.Signal(1);\n * \tsignal.rampTo(-1, 0.5);\n * \tsignal.connect(abs);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\treadonly name: string = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: (val) => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\nimport { WaveShaper } from \"./WaveShaper.js\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * @see {@link AudioToGain}.\n * @category Signal\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\treadonly name: string = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: (x) => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode.js\";\nimport { Multiply } from \"./Multiply.js\";\nimport { SignalOperator } from \"./SignalOperator.js\";\n\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * const neg = new Tone.Negate();\n * const sig = new Tone.Signal(-2).connect(neg);\n * // output of neg is positive 2.\n * @category Signal\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\treadonly name: string = \"Negate\";\n\n\t/**\n\t * negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t * clean up\n\t * @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/context/ToneAudioNode.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Negate } from \"../signal/Negate.js\";\nimport { Signal, SignalOptions } from \"../signal/Signal.js\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * // subtract a scalar from a signal\n * const sub = new Tone.Subtract(1);\n * const sig = new Tone.Signal(4).connect(sub);\n * // the output of sub is 3.\n * @example\n * // subtract two signals\n * const sub = new Tone.Subtract();\n * const sigA = new Tone.Signal(10);\n * const sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * // output of sub is 7.5\n * @category Signal\n */\nexport class Subtract extends Signal {\n\toverride = false;\n\n\treadonly name: string = \"Subtract\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input: Gain = this._sum;\n\treadonly output: Gain = this._sum;\n\n\t/**\n\t * Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context: this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value The value to subtract from the incoming signal. If the value\n\t *             is omitted, it will subtract the second signal from the first.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(\n\t\t\toptionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])\n\t\t);\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { SignalOperator, SignalOperatorOptions } from \"./SignalOperator.js\";\nimport { Multiply } from \"./Multiply.js\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode.js\";\nimport { WaveShaper } from \"./WaveShaper.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\n\nexport type GreaterThanZeroOptions = SignalOperatorOptions;\n\n/**\n * GreaterThanZero outputs 1 when the input is strictly greater than zero\n * @example\n * return Tone.Offline(() => {\n * \tconst gt0 = new Tone.GreaterThanZero().toDestination();\n * \tconst sig = new Tone.Signal(0.5).connect(gt0);\n * \tsig.setValueAtTime(-1, 0.05);\n * }, 0.1, 1);\n * @category Signal\n */\nexport class GreaterThanZero extends SignalOperator<GreaterThanZeroOptions> {\n\treadonly name: string = \"GreaterThanZero\";\n\n\t/**\n\t * The waveshaper\n\t */\n\tprivate _thresh: WaveShaper;\n\n\t/**\n\t * Scale the first thresholded signal by a large value.\n\t * this will help with values which are very close to 0\n\t */\n\tprivate _scale: Multiply;\n\n\treadonly output: ToneAudioNode;\n\treadonly input: ToneAudioNode;\n\n\tconstructor(options?: Partial<GreaterThanZeroOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(GreaterThanZero.getDefaults(), arguments));\n\n\t\tthis._thresh = this.output = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 127,\n\t\t\tmapping: (val) => {\n\t\t\t\tif (val <= 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t\tthis._scale = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 10000,\n\t\t});\n\n\t\t// connections\n\t\tthis._scale.connect(this._thresh);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode } from \"../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Subtract } from \"./Subtract.js\";\nimport { Signal, SignalOptions } from \"./Signal.js\";\nimport { GreaterThanZero } from \"./GreaterThanZero.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Param } from \"../core/context/Param.js\";\n\nexport type GreaterThanOptions = SignalOptions<\"number\">;\n\n/**\n * Output 1 if the signal is greater than the value, otherwise outputs 0.\n * can compare two signals or a signal and a number.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst gt = new Tone.GreaterThan(2).toDestination();\n * \tconst sig = new Tone.Signal(4).connect(gt);\n * }, 0.1, 1);\n * @category Signal\n */\nexport class GreaterThan extends Signal<\"number\"> {\n\treadonly name: string = \"GreaterThan\";\n\n\treadonly override: boolean = false;\n\n\treadonly input: ToneAudioNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * compare that amount to zero after subtracting\n\t */\n\tprivate _gtz: GreaterThanZero;\n\n\t/**\n\t * Subtract the value from the input node\n\t */\n\tprivate _subtract: Subtract;\n\n\t/**\n\t * The signal to compare to the incoming signal against.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \t// change the comparison value\n\t * \tconst gt = new Tone.GreaterThan(1.5).toDestination();\n\t * \tconst signal = new Tone.Signal(1).connect(gt);\n\t * \tgt.comparator.setValueAtTime(0.5, 0.1);\n\t * }, 0.5, 1);\n\t */\n\treadonly comparator: Param<\"number\">;\n\n\t/**\n\t * @param value The value to compare to\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<GreaterThanOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tGreaterThan.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"value\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._subtract = this.input = new Subtract({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.value,\n\t\t});\n\t\tthis._gtz = this.output = new GreaterThanZero({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tthis.comparator = this._param = this._subtract.subtrahend;\n\t\treadOnly(this, \"comparator\");\n\n\t\t// connect\n\t\tthis._subtract.connect(this._gtz);\n\t}\n\n\tstatic getDefaults(): GreaterThanOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gtz.dispose();\n\t\tthis._subtract.dispose();\n\t\tthis.comparator.dispose();\n\t\treturn this;\n\t}\n}\n","import { Scale, ScaleOptions } from \"./Scale.js\";\nimport { Positive } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Pow } from \"./Pow.js\";\n\nexport interface ScaleExpOptions extends ScaleOptions {\n\texponent: Positive;\n}\n\n/**\n * Performs an exponential scaling on an input signal.\n * Scales a NormalRange value [0,1] exponentially\n * to the output range of outputMin to outputMax.\n * @example\n * const scaleExp = new Tone.ScaleExp(0, 100, 2);\n * const signal = new Tone.Signal(0.5).connect(scaleExp);\n * @category Signal\n */\nexport class ScaleExp extends Scale<ScaleExpOptions> {\n\treadonly name: string = \"ScaleExp\";\n\n\t/**\n\t * The exponent scaler\n\t */\n\tprivate _exp: Pow;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t * @param exponent The exponent which scales the incoming signal.\n\t */\n\tconstructor(min?: number, max?: number, exponent?: number);\n\tconstructor(options?: Partial<ScaleExpOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tScaleExp.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"min\", \"max\", \"exponent\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.input = this._exp = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent,\n\t\t});\n\t\tthis._exp.connect(this._mult);\n\t}\n\n\tstatic getDefaults(): ScaleExpOptions {\n\t\treturn Object.assign(Scale.getDefaults(), {\n\t\t\texponent: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Instead of interpolating linearly between the {@link min} and\n\t * {@link max} values, setting the exponent will interpolate between\n\t * the two values with an exponential curve.\n\t */\n\tget exponent(): Positive {\n\t\treturn this._exp.value;\n\t}\n\tset exponent(exp) {\n\t\tthis._exp.value = exp;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exp.dispose();\n\t\treturn this;\n\t}\n}\n","import { Signal, SignalOptions } from \"./Signal.js\";\nimport {\n\tNormalRange,\n\tSeconds,\n\tTime,\n\tTransportTime,\n\tUnitMap,\n\tUnitName,\n} from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { TransportTimeClass } from \"../core/type/TransportTime.js\";\nimport { ToneConstantSource } from \"./ToneConstantSource.js\";\nimport { OutputNode } from \"../core/context/ToneAudioNode.js\";\nimport type { TransportClass } from \"../core/clock/Transport.js\";\n\n/**\n * Adds the ability to synchronize the signal to the {@link TransportClass}\n * @category Signal\n */\nexport class SyncedSignal<\n\tTypeName extends UnitName = \"number\",\n> extends Signal<TypeName> {\n\treadonly name: string = \"SyncedSignal\";\n\n\t/**\n\t * Don't override when something is connected to the input\n\t */\n\treadonly override = false;\n\n\treadonly output: OutputNode;\n\n\t/**\n\t * Keep track of the last value as an optimization.\n\t */\n\tprivate _lastVal: UnitMap[TypeName];\n\n\t/**\n\t * The ID returned from scheduleRepeat\n\t */\n\tprivate _synced: number;\n\n\t/**\n\t * Remember the callback value\n\t */\n\tprivate _syncedCallback: () => void;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\n\t\t\t\"value\",\n\t\t\t\"units\",\n\t\t]) as SignalOptions<TypeName>;\n\t\tsuper(options);\n\n\t\tthis._lastVal = options.value;\n\t\tthis._synced = this.context.transport.scheduleRepeat(\n\t\t\tthis._onTick.bind(this),\n\t\t\t\"1i\"\n\t\t);\n\n\t\tthis._syncedCallback = this._anchorValue.bind(this);\n\t\tthis.context.transport.on(\"start\", this._syncedCallback);\n\t\tthis.context.transport.on(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.on(\"stop\", this._syncedCallback);\n\n\t\t// disconnect the constant source from the output and replace it with another one\n\t\tthis._constantSource.disconnect();\n\t\tthis._constantSource.stop(0);\n\n\t\t// create a new one\n\t\tthis._constantSource = this.output = new ToneConstantSource<TypeName>({\n\t\t\tcontext: this.context,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t}).start(0);\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\t/**\n\t * Callback which is invoked every tick.\n\t */\n\tprivate _onTick(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\t// approximate ramp curves with linear ramps\n\t\tif (this._lastVal !== val) {\n\t\t\tthis._lastVal = val;\n\t\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t\t}\n\t}\n\n\t/**\n\t * Anchor the value at the start and stop of the Transport\n\t */\n\tprivate _anchorValue(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\tthis._lastVal = val;\n\t\tthis._constantSource.offset.cancelAndHoldAtTime(time);\n\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t}\n\n\tgetValueAtTime(time: TransportTime): UnitMap[TypeName] {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toSeconds();\n\t\treturn super.getValueAtTime(computedTime);\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toSeconds();\n\t\tsuper.setValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toSeconds();\n\t\tsuper.linearRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(\n\t\tvalue: UnitMap[TypeName],\n\t\ttime: TransportTime\n\t) {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toSeconds();\n\t\tsuper.exponentialRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(\n\t\tvalue,\n\t\tstartTime: TransportTime,\n\t\ttimeConstant: number\n\t): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\tstartTime\n\t\t).toSeconds();\n\t\tsuper.setTargetAtTime(value, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(startTime: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\tstartTime\n\t\t).toSeconds();\n\t\tsuper.cancelScheduledValues(computedTime);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(\n\t\tvalues: UnitMap[TypeName][],\n\t\tstartTime: TransportTime,\n\t\tduration: Time,\n\t\tscaling: NormalRange\n\t): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\tstartTime\n\t\t).toSeconds();\n\t\tduration = this.toSeconds(duration);\n\t\tsuper.setValueCurveAtTime(values, computedTime, duration, scaling);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toSeconds();\n\t\tsuper.cancelAndHoldAtTime(computedTime);\n\t\treturn this;\n\t}\n\n\tsetRampPoint(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toSeconds();\n\t\tsuper.setRampPoint(computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: TransportTime\n\t): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\tstartTime\n\t\t).toSeconds();\n\t\tsuper.exponentialRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\tlinearRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: TransportTime\n\t): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\tstartTime\n\t\t).toSeconds();\n\t\tsuper.linearRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(\n\t\tvalue: UnitMap[TypeName],\n\t\trampTime: Time,\n\t\tstartTime?: TransportTime\n\t): this {\n\t\tconst computedTime = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\tstartTime\n\t\t).toSeconds();\n\t\tsuper.targetRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.transport.clear(this._synced);\n\t\tthis.context.transport.off(\"start\", this._syncedCallback);\n\t\tthis.context.transport.off(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.off(\"stop\", this._syncedCallback);\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { NormalRange, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck.js\";\nimport { connectSignal, Signal } from \"../../signal/Signal.js\";\nimport { OfflineContext } from \"../../core/context/OfflineContext.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { range, timeRange } from \"../../core/util/Decorator.js\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tdecay: Time;\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\t@range(0, 1)\n\tsustain: NormalRange;\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<\"normalRange\"> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(\n\t\tattack?: Time,\n\t\tdecay?: Time,\n\t\tsustain?: NormalRange,\n\t\trelease?: Time\n\t);\n\tconstructor(options?: Partial<EnvelopeOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tEnvelope.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"attack\", \"decay\", \"sustain\", \"release\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * synchronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(\n\t\tcurve: InternalEnvelopeCurve,\n\t\tdirection: EnvelopeDirection\n\t): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope(0.4).toDestination();\n\t * \tenv.attackCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\trelease: 0.8\n\t * \t}).toDestination();\n\t * \tenv.triggerAttack();\n\t * \t// release curve could also be defined by an array\n\t * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n\t * \tenv.triggerRelease(0.2);\n\t * }, 1, 1);\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\tsustain: 0.1,\n\t * \t\tdecay: 0.5\n\t * \t}).toDestination();\n\t * \tenv.decayCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget decayCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._decayCurve, \"Out\");\n\t}\n\tset decayCurve(curve) {\n\t\tthis._setCurve(\"_decayCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack < this.sampleTime) {\n\t\t\tthis._sig.cancelScheduledValues(time);\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay && this.sustain < 1) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampToValueAtTime(\n\t\t\t\t\tdecayValue,\n\t\t\t\t\tdecay + decayStart\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(\n\t\t\t\t\tdecayValue,\n\t\t\t\t\tdecayStart,\n\t\t\t\t\tdecay\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator({\n\t * \ttype: \"sawtooth\"\n\t * }).connect(env).start();\n\t * env.triggerAttack();\n\t * // trigger the release half a second after the attack\n\t * env.triggerRelease(\"+0.5\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (release < this.sampleTime) {\n\t\t\t\tthis._sig.setValueAtTime(0, time);\n\t\t\t} else if (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tassert(\n\t\t\t\t\tisArray(this._releaseCurve),\n\t\t\t\t\t\"releaseCurve must be either 'linear', 'exponential' or an array\"\n\t\t\t\t);\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(\n\t\t\t\t\tthis._releaseCurve,\n\t\t\t\t\ttime,\n\t\t\t\t\trelease,\n\t\t\t\t\tcurrentValue\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t * @example\n\t * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n\t * env.triggerAttackRelease(2);\n\t * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the release 0.5 seconds after the attack\n\t * env.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(\n\t\tduration: Time,\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Render the envelope curve to an array of the given length.\n\t * Good for visualizing the envelope curve. Rescales the duration of the\n\t * envelope to fit the length.\n\t */\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\tconst duration = length / this.context.sampleRate;\n\t\tconst context = new OfflineContext(\n\t\t\t1,\n\t\t\tduration,\n\t\t\tthis.context.sampleRate\n\t\t);\n\t\t// normalize the ADSR for the given duration with 20% sustain time\n\t\tconst attackPortion =\n\t\t\tthis.toSeconds(this.attack) + this.toSeconds(this.decay);\n\t\tconst envelopeDuration = attackPortion + this.toSeconds(this.release);\n\t\tconst sustainTime = envelopeDuration * 0.1;\n\t\tconst totalDuration = envelopeDuration + sustainTime;\n\t\t// @ts-ignore\n\t\tconst clone = new this.constructor(\n\t\t\tObject.assign(this.get(), {\n\t\t\t\tattack:\n\t\t\t\t\t(duration * this.toSeconds(this.attack)) / totalDuration,\n\t\t\t\tdecay: (duration * this.toSeconds(this.decay)) / totalDuration,\n\t\t\t\trelease:\n\t\t\t\t\t(duration * this.toSeconds(this.release)) / totalDuration,\n\t\t\t\tcontext,\n\t\t\t})\n\t\t) as Envelope;\n\t\tclone._sig.toDestination();\n\t\tclone.triggerAttackRelease(\n\t\t\t(duration * (attackPortion + sustainTime)) / totalDuration,\n\t\t\t0\n\t\t);\n\t\tconst buffer = await context.render();\n\t\treturn buffer.getChannelData(0);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst sineWave =\n\t\t\tMath.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as const,\n\t\tlinear: \"linear\" as const,\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { Volume } from \"../component/channel/Volume.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport {\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n * Base-class for all instruments\n */\nexport abstract class Instrument<\n\tOptions extends InstrumentOptions,\n> extends ToneAudioNode<Options> {\n\t/**\n\t * The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const amSynth = new Tone.AMSynth().toDestination();\n\t * amSynth.volume.value = -6;\n\t * amSynth.triggerAttackRelease(\"G#3\", 0.2);\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tInstrument.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.\n\t * @example\n\t * const fmSynth = new Tone.FMSynth().toDestination();\n\t * fmSynth.volume.value = -6;\n\t * fmSynth.sync();\n\t * // schedule 3 notes when the transport first starts\n\t * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n\t * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n\t * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n\t * // start the transport to hear the notes\n\t * Tone.Transport.start();\n\t */\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\n\t\t\tthis.context.transport.on(\"stop\", this._syncedRelease);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedRelease);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedRelease);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * set _sync\n\t */\n\tprotected _syncState(): boolean {\n\t\tlet changed = false;\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tchanged = true;\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = (this[\"_original_\" + method] = this[method]);\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach((id) => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\n\t\t\tthis.context.transport.off(\"stop\", this._syncedRelease);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedRelease);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedRelease);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and then the release after the duration.\n\t * @param  note     The note to trigger.\n\t * @param  duration How long the note should be held for before\n\t *                         triggering the release. This value must be greater than 0.\n\t * @param time  When the note should be triggered.\n\t * @param  velocity The velocity the note should be triggered at.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(\n\t\tnote: Frequency,\n\t\tduration: Time,\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the note\n\t * @param velocity the velocity to trigger the note (between 0-1)\n\t */\n\tabstract triggerAttack(\n\t\tnote: Frequency,\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange\n\t): this;\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t * @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t * The release which is scheduled to the timeline.\n\t */\n\tprotected _syncedRelease = (time: number) =>\n\t\tthis._original_triggerRelease(time);\n\n\t/**\n\t * clean up\n\t * @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency.js\";\nimport {\n\tCents,\n\tFrequency,\n\tNormalRange,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<\n\tOptions extends MonophonicOptions,\n> extends Instrument<Options> {\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMonophonic.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity determines how \"loud\" the note will be.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(\n\t\tnote: Frequency | FrequencyClass,\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope.\n\t * @param  time If no time is given, the release happens immediately.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(\n\t\ttime: Seconds,\n\t\tvelocity: NormalRange\n\t): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency =\n\t\t\tnote instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(\n\t\t\t\tcomputedFrequency,\n\t\t\t\tportTime,\n\t\t\t\tcomputedTime\n\t\t\t);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { NormalRange, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope.js\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst ampEnv = new Tone.AmplitudeEnvelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 1.0,\n * \t\trelease: 0.8\n * \t}).toDestination();\n * \t// create an oscillator and connect it\n * \tconst osc = new Tone.Oscillator().connect(ampEnv).start();\n * \t// trigger the envelopes attack and release \"8t\" apart\n * \tampEnv.triggerAttackRelease(\"8t\");\n * }, 1.5, 1);\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n\treadonly name: string = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(\n\t\tattack?: Time,\n\t\tdecay?: Time,\n\t\tsustain?: NormalRange,\n\t\trelease?: Time\n\t);\n\tconstructor(options?: Partial<EnvelopeOptions>);\n\tconstructor() {\n\t\tsuper(\n\t\t\toptionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\n\t\t\t\t\"attack\",\n\t\t\t\t\"decay\",\n\t\t\t\t\"sustain\",\n\t\t\t\t\"release\",\n\t\t\t])\n\t\t);\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope.js\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator.js\";\nimport {\n\tOmniOscillatorOptions,\n\tOmniOscillatorSynthOptions,\n} from \"../source/oscillator/OscillatorInterface.js\";\nimport { Source } from \"../source/Source.js\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic.js\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<\n\tOptions extends SynthOptions = SynthOptions,\n> extends Monophonic<Options> {\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\t\tsuper(options);\n\n\t\tthis.oscillator = new OmniOscillator(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tdetune: options.detune,\n\t\t\t\t\tonstop: () => this.onsilence(this),\n\t\t\t\t},\n\t\t\t\toptions.oscillator\n\t\t\t)\n\t\t);\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t},\n\t\t\t\toptions.envelope\n\t\t\t)\n\t\t);\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t}\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\",\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t}\n\t\t\t) as OmniOscillatorOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { Signal } from \"../signal/Signal.js\";\nimport { Multiply } from \"../signal/Multiply.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { NormalRange, Positive, Seconds, Time } from \"../core/type/Units.js\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { Monophonic } from \"./Monophonic.js\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator.js\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface.js\";\nimport { Source } from \"../source/Source.js\";\nimport { Synth, SynthOptions } from \"./Synth.js\";\nimport { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope.js\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\n\nexport interface ModulationSynthOptions extends SynthOptions {\n\tharmonicity: Positive;\n\tmodulationEnvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tmodulation: OmniOscillatorSynthOptions;\n}\n/**\n * Base class for both AM and FM synths\n */\nexport abstract class ModulationSynth<\n\tOptions extends ModulationSynthOptions,\n> extends Monophonic<Options> {\n\treadonly name: string = \"ModulationSynth\";\n\n\t/**\n\t * The carrier voice.\n\t */\n\tprotected _carrier: Synth;\n\n\t/**\n\t * The modulator voice.\n\t */\n\n\tprotected _modulator: Synth;\n\n\t/**\n\t * The carrier's oscillator\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The carrier's envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * The modulator's oscillator which is applied to the amplitude of the oscillator\n\t */\n\treadonly modulation: OmniOscillator<any>;\n\n\t/**\n\t * The modulator's envelope\n\t */\n\treadonly modulationEnvelope: AmplitudeEnvelope;\n\n\t/**\n\t * The frequency control\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const amSynth = new Tone.AMSynth().toDestination();\n\t * // pitch the modulator an octave below oscillator\n\t * amSynth.harmonicity.value = 0.5;\n\t * amSynth.triggerAttackRelease(\"C5\", \"4n\");\n\t */\n\treadonly harmonicity: Multiply;\n\n\t/**\n\t * The node where the modulation happens\n\t */\n\tprotected _modulationNode: Gain;\n\n\tconstructor(options?: RecursivePartial<ModulationSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tModulationSynth.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._carrier = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.oscillator,\n\t\t\tenvelope: options.envelope,\n\t\t\tonsilence: () => this.onsilence(this),\n\t\t\tvolume: -10,\n\t\t});\n\t\tthis._modulator = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.modulation,\n\t\t\tenvelope: options.modulationEnvelope,\n\t\t\tvolume: -10,\n\t\t});\n\n\t\tthis.oscillator = this._carrier.oscillator;\n\t\tthis.envelope = this._carrier.envelope;\n\t\tthis.modulation = this._modulator.oscillator;\n\t\tthis.modulationEnvelope = this._modulator.envelope;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.detune,\n\t\t\tunits: \"cents\",\n\t\t});\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.harmonicity,\n\t\t\tminValue: 0,\n\t\t});\n\t\tthis._modulationNode = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t});\n\n\t\treadOnly(this, [\n\t\t\t\"frequency\",\n\t\t\t\"harmonicity\",\n\t\t\t\"oscillator\",\n\t\t\t\"envelope\",\n\t\t\t\"modulation\",\n\t\t\t\"modulationEnvelope\",\n\t\t\t\"detune\",\n\t\t]);\n\t}\n\n\tstatic getDefaults(): ModulationSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tharmonicity: 3,\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\",\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sine\",\n\t\t\t\t}\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.01,\n\t\t\t\t\tdecay: 0.01,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulation: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\",\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"square\",\n\t\t\t\t}\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t\tmodulationEnvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.5,\n\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeAttack(time, velocity);\n\t}\n\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._modulationNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioToGain } from \"../signal/AudioToGain.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth.js\";\n\nexport type AMSynthOptions = ModulationSynthOptions;\n\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * const synth = new Tone.AMSynth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n *\n * @category Instrument\n */\nexport class AMSynth extends ModulationSynth<AMSynthOptions> {\n\treadonly name: string = \"AMSynth\";\n\n\t/**\n\t * Scale the oscillator from -1,1 to 0-1\n\t */\n\tprivate _modulationScale: AudioToGain;\n\n\tconstructor(options?: RecursivePartial<AMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AMSynth.getDefaults(), arguments));\n\n\t\tthis._modulationScale = new AudioToGain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Cents, Frequency, GainFactor } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { assert } from \"../../core/util/Debug.js\";\n\nexport interface BiquadFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tQ: number;\n\ttype: BiquadFilterType;\n\tgain: GainFactor;\n}\n\n/**\n * Thin wrapper around the native Web Audio [BiquadFilterNode](https://webaudio.github.io/web-audio-api/#biquadfilternode).\n * BiquadFilter is similar to {@link Filter} but doesn't have the option to set the \"rolloff\" value.\n * @category Component\n */\nexport class BiquadFilter extends ToneAudioNode<BiquadFilterOptions> {\n\treadonly name: string = \"BiquadFilter\";\n\n\treadonly input: BiquadFilterNode;\n\treadonly output: BiquadFilterNode;\n\n\t/**\n\t * The frequency of the filter\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * A detune value, in cents, for the frequency.\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\t/**\n\t * The Q factor of the filter.\n\t * For lowpass and highpass filters the Q value is interpreted to be in dB.\n\t * For these filters the nominal range is [,] where  is the largest value for which 10/20 does not overflow. This is approximately 770.63678.\n\t * For the bandpass, notch, allpass, and peaking filters, this value is a linear value.\n\t * The value is related to the bandwidth of the filter and hence should be a positive value. The nominal range is\n\t * [0,3.402823538], the upper limit being the most-positive-single-float.\n\t * This is not used for the lowshelf and highshelf filters.\n\t */\n\treadonly Q: Param<\"number\">;\n\n\t/**\n\t * The gain of the filter. Its value is in dB units. The gain is only used for lowshelf, highshelf, and peaking filters.\n\t */\n\treadonly gain: Param<\"decibels\">;\n\n\tprivate readonly _filter: BiquadFilterNode;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType);\n\tconstructor(options?: Partial<BiquadFilterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tBiquadFilter.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._filter = this.context.createBiquadFilter();\n\t\tthis.input = this.output = this._filter;\n\n\t\tthis.Q = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"number\",\n\t\t\tvalue: options.Q,\n\t\t\tparam: this._filter.Q,\n\t\t});\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tparam: this._filter.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t\tparam: this._filter.detune,\n\t\t});\n\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tconvert: false,\n\t\t\tvalue: options.gain,\n\t\t\tparam: this._filter.gain,\n\t\t});\n\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): BiquadFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\ttype: \"lowpass\" as const,\n\t\t\tfrequency: 350,\n\t\t\tdetune: 0,\n\t\t\tgain: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The type of this BiquadFilterNode. For a complete list of types and their attributes, see the\n\t * [Web Audio API](https://webaudio.github.io/web-audio-api/#dom-biquadfiltertype-lowpass)\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._filter.type;\n\t}\n\tset type(type) {\n\t\tconst types: BiquadFilterType[] = [\n\t\t\t\"lowpass\",\n\t\t\t\"highpass\",\n\t\t\t\"bandpass\",\n\t\t\t\"lowshelf\",\n\t\t\t\"highshelf\",\n\t\t\t\"notch\",\n\t\t\t\"allpass\",\n\t\t\t\"peaking\",\n\t\t];\n\t\tassert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._filter.type = type;\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\t// clone the filter to remove any connections which may be changing the value\n\t\tconst filterClone = this.context.createBiquadFilter();\n\t\tfilterClone.type = this.type;\n\t\tfilterClone.Q.value = this.Q.value;\n\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\tfilterClone.gain.value = this.gain.value as number;\n\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filter.disconnect();\n\t\tthis.Q.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.gain.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tconnectSeries,\n\tToneAudioNode,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Frequency } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly, writable } from \"../../core/util/Interface.js\";\nimport { isNumber } from \"../../core/util/TypeCheck.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { BiquadFilter, BiquadFilterOptions } from \"./BiquadFilter.js\";\n\nexport type FilterRollOff = -12 | -24 | -48 | -96;\n\nexport type FilterOptions = BiquadFilterOptions & {\n\trolloff: FilterRollOff;\n};\n\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * const filter = new Tone.Filter(1500, \"highpass\").toDestination();\n * filter.frequency.rampTo(20000, 10);\n * const noise = new Tone.Noise().connect(filter).start();\n * @category Component\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\treadonly name: string = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilter[] = [];\n\n\t/**\n\t * the rolloff value of the filter\n\t */\n\tprivate _rolloff!: FilterRollOff;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune parameter\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t * @param rolloff The drop in decibels per octave after the cutoff frequency\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\ttype?: BiquadFilterType,\n\t\trolloff?: FilterRollOff\n\t);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\n\t\t\t\"frequency\",\n\t\t\t\"type\",\n\t\t\t\"rolloff\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tconvert: false,\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12 as FilterRollOff,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\n\t\t\t\"lowpass\",\n\t\t\t\"highpass\",\n\t\t\t\"bandpass\",\n\t\t\t\"lowshelf\",\n\t\t\t\"highshelf\",\n\t\t\t\"notch\",\n\t\t\t\"allpass\",\n\t\t\t\"peaking\",\n\t\t];\n\t\tassert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach((filter) => (filter.type = type));\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): FilterRollOff {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff) {\n\t\tconst rolloffNum = isNumber(rolloff)\n\t\t\t? rolloff\n\t\t\t: (parseInt(rolloff, 10) as FilterRollOff);\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tassert(\n\t\t\tcascadingCount !== -1,\n\t\t\t`rolloff can only be ${possibilities.join(\", \")}`\n\t\t);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach((filter) => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = new BiquadFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\tconst filterClone = new BiquadFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: this.frequency.value,\n\t\t\tgain: this.gain.value,\n\t\t\tQ: this.Q.value,\n\t\t\ttype: this._type,\n\t\t\tdetune: this.detune.value,\n\t\t});\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst response = filterClone.getFrequencyResponse(len);\n\t\t\tresponse.forEach((val, i) => (totalResponse[i] *= val));\n\t\t});\n\t\tfilterClone.dispose();\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach((filter) => {\n\t\t\tfilter.dispose();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Frequency, Hertz, NormalRange, Time } from \"../../core/type/Units.js\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope.js\";\nimport { Scale } from \"../../signal/Scale.js\";\nimport { Pow } from \"../../signal/Pow.js\";\nimport { assertRange } from \"../../core/util/Debug.js\";\n\nexport interface FrequencyEnvelopeOptions extends EnvelopeOptions {\n\tbaseFrequency: Frequency;\n\toctaves: number;\n\texponent: number;\n}\n/**\n * FrequencyEnvelope is an {@link Envelope} which ramps between {@link baseFrequency}\n * and {@link octaves}. It can also have an optional {@link exponent} to adjust the curve\n * which it ramps.\n * @example\n * const oscillator = new Tone.Oscillator().toDestination().start();\n * const freqEnv = new Tone.FrequencyEnvelope({\n * \tattack: 0.2,\n * \tbaseFrequency: \"C2\",\n * \toctaves: 4\n * });\n * freqEnv.connect(oscillator.frequency);\n * freqEnv.triggerAttack();\n * @category Component\n */\nexport class FrequencyEnvelope extends Envelope {\n\treadonly name: string = \"FrequencyEnvelope\";\n\n\t/**\n\t * Private reference to the base frequency as a number\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * The number of octaves\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Internal scaler from 0-1 to the final output range\n\t */\n\tprivate _scale: Scale;\n\n\t/**\n\t * Apply a power curve to the output\n\t */\n\tprivate _exponent: Pow;\n\n\t/**\n\t * @param attack\tthe attack time in seconds\n\t * @param decay\t\tthe decay time in seconds\n\t * @param sustain \ta percentage (0-1) of the full amplitude\n\t * @param release\tthe release time in seconds\n\t */\n\tconstructor(\n\t\tattack?: Time,\n\t\tdecay?: Time,\n\t\tsustain?: NormalRange,\n\t\trelease?: Time\n\t);\n\tconstructor(options?: Partial<FrequencyEnvelopeOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFrequencyEnvelope.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"attack\", \"decay\", \"sustain\", \"release\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._octaves = options.octaves;\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\n\t\tthis._exponent = this.input = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent,\n\t\t});\n\t\tthis._scale = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: this._baseFrequency,\n\t\t\tmax: this._baseFrequency * Math.pow(2, this._octaves),\n\t\t});\n\t\tthis._sig.chain(this._exponent, this._scale);\n\t}\n\n\tstatic getDefaults(): FrequencyEnvelopeOptions {\n\t\treturn Object.assign(Envelope.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\texponent: 1,\n\t\t\toctaves: 4,\n\t\t});\n\t}\n\n\t/**\n\t * The envelope's minimum output value. This is the value which it\n\t * starts at.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(min) {\n\t\tconst freq = this.toFrequency(min);\n\t\tassertRange(freq, 0);\n\t\tthis._baseFrequency = freq;\n\t\tthis._scale.min = this._baseFrequency;\n\t\t// update the max value when the min changes\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the baseFrequency that the\n\t * envelope will scale to.\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves: number) {\n\t\tthis._octaves = octaves;\n\t\tthis._scale.max = this._baseFrequency * Math.pow(2, octaves);\n\t}\n\n\t/**\n\t * The envelope's exponent value.\n\t */\n\tget exponent(): number {\n\t\treturn this._exponent.value;\n\t}\n\tset exponent(exponent) {\n\t\tthis._exponent.value = exponent;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponent.dispose();\n\t\tthis._scale.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope.js\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope.js\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface.js\";\nimport { Monophonic, MonophonicOptions } from \"../instrument/Monophonic.js\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator.js\";\nimport { Source } from \"../source/Source.js\";\nimport {\n\tFrequencyEnvelope,\n\tFrequencyEnvelopeOptions,\n} from \"../component/envelope/FrequencyEnvelope.js\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface.js\";\n\nexport interface MonoSynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilterEnvelope: Omit<FrequencyEnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilter: Omit<FilterOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class MonoSynth extends Monophonic<MonoSynthOptions> {\n\treadonly name = \"MonoSynth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The filter.\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The filter envelope.\n\t */\n\treadonly filterEnvelope: FrequencyEnvelope;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<MonoSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMonoSynth.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.oscillator = new OmniOscillator(\n\t\t\tObject.assign(options.oscillator, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tdetune: options.detune,\n\t\t\t\tonstop: () => this.onsilence(this),\n\t\t\t})\n\t\t);\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\t\tthis.filter = new Filter(\n\t\t\tObject.assign(options.filter, { context: this.context })\n\t\t);\n\t\tthis.filterEnvelope = new FrequencyEnvelope(\n\t\t\tObject.assign(options.filterEnvelope, { context: this.context })\n\t\t);\n\t\tthis.envelope = new AmplitudeEnvelope(\n\t\t\tObject.assign(options.envelope, { context: this.context })\n\t\t);\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.filter, this.envelope, this.output);\n\n\t\t// connect the filter envelope\n\t\tthis.filterEnvelope.connect(this.filter.frequency);\n\n\t\treadOnly(this, [\n\t\t\t\"oscillator\",\n\t\t\t\"frequency\",\n\t\t\t\"detune\",\n\t\t\t\"filter\",\n\t\t\t\"filterEnvelope\",\n\t\t\t\"envelope\",\n\t\t]);\n\t}\n\n\tstatic getDefaults(): MonoSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.9,\n\t\t\t\t}\n\t\t\t),\n\t\t\tfilter: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tFilter.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tQ: 1,\n\t\t\t\t\trolloff: -12,\n\t\t\t\t\ttype: \"lowpass\",\n\t\t\t\t}\n\t\t\t),\n\t\t\tfilterEnvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tFrequencyEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.6,\n\t\t\t\t\tbaseFrequency: 200,\n\t\t\t\t\tdecay: 0.2,\n\t\t\t\t\texponent: 2,\n\t\t\t\t\toctaves: 3,\n\t\t\t\t\trelease: 2,\n\t\t\t\t\tsustain: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tOmniOscillator.getDefaults(),\n\t\t\t\t\tObject.keys(Source.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sawtooth\",\n\t\t\t\t}\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity = 1): void {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.filterEnvelope.triggerAttack(time);\n\t\tthis.oscillator.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.filterEnvelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis.filterEnvelope.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n","import { Monophonic, MonophonicOptions } from \"./Monophonic.js\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Multiply } from \"../signal/Multiply.js\";\nimport {\n\tFrequency,\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport {\n\tdeepMerge,\n\tomitFromObject,\n\toptionsFromArguments,\n} from \"../core/util/Defaults.js\";\nimport { Param } from \"../core/context/Param.js\";\n\nexport interface DuoSynthOptions extends MonophonicOptions {\n\tvoice0: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tvoice1: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tharmonicity: Positive;\n\tvibratoRate: Frequency;\n\tvibratoAmount: Positive;\n}\n\n/**\n * DuoSynth is a monophonic synth composed of two {@link MonoSynth}s run in parallel with control over the\n * frequency ratio between the two voices and vibrato effect.\n * @example\n * const duoSynth = new Tone.DuoSynth().toDestination();\n * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n * @category Instrument\n */\nexport class DuoSynth extends Monophonic<DuoSynthOptions> {\n\treadonly name: string = \"DuoSynth\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * the first voice\n\t */\n\treadonly voice0: MonoSynth;\n\n\t/**\n\t * the second voice\n\t */\n\treadonly voice1: MonoSynth;\n\n\t/**\n\t * The amount of vibrato\n\t */\n\tpublic vibratoAmount: Param<\"normalRange\">;\n\n\t/**\n\t * the vibrato frequency\n\t */\n\tpublic vibratoRate: Signal<\"frequency\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const duoSynth = new Tone.DuoSynth().toDestination();\n\t * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n\t * // pitch voice1 an octave below voice0\n\t * duoSynth.harmonicity.value = 0.5;\n\t */\n\tpublic harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The vibrato LFO.\n\t */\n\tprivate _vibrato: LFO;\n\n\t/**\n\t * the vibrato gain\n\t */\n\tprivate _vibratoGain: Gain<\"normalRange\">;\n\n\tconstructor(options?: RecursivePartial<DuoSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(DuoSynth.getDefaults(), arguments);\n\t\tsuper(options);\n\n\t\tthis.voice0 = new MonoSynth(\n\t\t\tObject.assign(options.voice0, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: () => this.onsilence(this),\n\t\t\t})\n\t\t);\n\t\tthis.voice1 = new MonoSynth(\n\t\t\tObject.assign(options.voice1, {\n\t\t\t\tcontext: this.context,\n\t\t\t})\n\t\t);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis._vibrato = new LFO({\n\t\t\tfrequency: options.vibratoRate,\n\t\t\tcontext: this.context,\n\t\t\tmin: -50,\n\t\t\tmax: 50,\n\t\t});\n\t\t// start the vibrato immediately\n\t\tthis._vibrato.start();\n\t\tthis.vibratoRate = this._vibrato.frequency;\n\t\tthis._vibratoGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tgain: options.vibratoAmount,\n\t\t});\n\t\tthis.vibratoAmount = this._vibratoGain.gain;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: 440,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this.voice0.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this.voice1.frequency);\n\n\t\tthis._vibrato.connect(this._vibratoGain);\n\t\tthis._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.detune.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.voice0.connect(this.output);\n\t\tthis.voice1.connect(this.output);\n\n\t\treadOnly(this, [\n\t\t\t\"voice0\",\n\t\t\t\"voice1\",\n\t\t\t\"frequency\",\n\t\t\t\"vibratoAmount\",\n\t\t\t\"vibratoRate\",\n\t\t]);\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn (\n\t\t\tthis.voice0.envelope.getValueAtTime(time) +\n\t\t\tthis.voice1.envelope.getValueAtTime(time)\n\t\t);\n\t}\n\n\tstatic getDefaults(): DuoSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tvibratoAmount: 0.5,\n\t\t\tvibratoRate: 5,\n\t\t\tharmonicity: 1.5,\n\t\t\tvoice0: deepMerge(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tMonoSynth.getDefaults(),\n\t\t\t\t\tObject.keys(Monophonic.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5,\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t),\n\t\t\tvoice1: deepMerge(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tMonoSynth.getDefaults(),\n\t\t\t\t\tObject.keys(Monophonic.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5,\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t),\n\t\t}) as unknown as DuoSynthOptions;\n\t}\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeAttack(time, velocity);\n\t}\n\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.voice0.dispose();\n\t\tthis.voice1.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._vibrato.dispose();\n\t\tthis.vibratoRate.dispose();\n\t\tthis._vibratoGain.dispose();\n\t\tthis.harmonicity.dispose();\n\t\treturn this;\n\t}\n}\n","import { Positive } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { Multiply } from \"../signal/Multiply.js\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth.js\";\n\nexport interface FMSynthOptions extends ModulationSynthOptions {\n\tmodulationIndex: Positive;\n}\n\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n * @example\n * const fmSynth = new Tone.FMSynth().toDestination();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n *\n * @category Instrument\n */\n\nexport class FMSynth extends ModulationSynth<FMSynthOptions> {\n\treadonly name: string = \"FMSynth\";\n\n\t/**\n\t * The modulation index which essentially the depth or amount of the modulation. It is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Multiply;\n\n\tconstructor(options?: RecursivePartial<FMSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n\t\tsuper(options);\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t}\n\n\tstatic getDefaults(): FMSynthOptions {\n\t\treturn Object.assign(ModulationSynth.getDefaults(), {\n\t\t\tmodulationIndex: 10,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope.js\";\nimport { Filter } from \"../component/filter/Filter.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport {\n\tFrequency,\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport {\n\tdeepMerge,\n\tomitFromObject,\n\toptionsFromArguments,\n} from \"../core/util/Defaults.js\";\nimport { noOp, RecursivePartial } from \"../core/util/Interface.js\";\nimport { Multiply } from \"../signal/Multiply.js\";\nimport { Scale } from \"../signal/Scale.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { FMOscillator } from \"../source/oscillator/FMOscillator.js\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic.js\";\n\nexport interface MetalSynthOptions extends MonophonicOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\toctaves: number;\n\tresonance: Frequency;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Inharmonic ratio of frequencies based on the Roland TR-808\n * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n */\nconst inharmRatios: number[] = [1.0, 1.483, 1.932, 2.546, 2.63, 3.897];\n\n/**\n * A highly inharmonic and spectrally complex source with a highpass filter\n * and amplitude envelope which is good for making metallophone sounds.\n * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n * @category Instrument\n */\nexport class MetalSynth extends Monophonic<MetalSynthOptions> {\n\treadonly name: string = \"MetalSynth\";\n\n\t/**\n\t * The frequency of the cymbal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune applied to the oscillators\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of FMOscillators\n\t */\n\tprivate _oscillators: FMOscillator[] = [];\n\n\t/**\n\t * The frequency multipliers\n\t */\n\tprivate _freqMultipliers: Multiply[] = [];\n\n\t/**\n\t * The gain node for the envelope.\n\t */\n\tprivate _amplitude: Gain;\n\n\t/**\n\t * Highpass the output\n\t */\n\tprivate _highpass: Filter;\n\n\t/**\n\t * The number of octaves the highpass\n\t * filter frequency ramps\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Scale the body envelope for the highpass filter\n\t */\n\tprivate _filterFreqScaler: Scale;\n\n\t/**\n\t * The envelope which is connected both to the\n\t * amplitude and a highpass filter's cutoff frequency.\n\t * The lower-limit of the filter is controlled by the {@link resonance}\n\t */\n\treadonly envelope: Envelope;\n\n\tconstructor(options?: RecursivePartial<MetalSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMetalSynth.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\n\t\tthis._amplitude = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t}).connect(this.output);\n\n\t\tthis._highpass = new Filter({\n\t\t\t// Q: -3.0102999566398125,\n\t\t\tQ: 0,\n\t\t\tcontext: this.context,\n\t\t\ttype: \"highpass\",\n\t\t}).connect(this._amplitude);\n\n\t\tfor (let i = 0; i < inharmRatios.length; i++) {\n\t\t\tconst osc = new FMOscillator({\n\t\t\t\tcontext: this.context,\n\t\t\t\tharmonicity: options.harmonicity,\n\t\t\t\tmodulationIndex: options.modulationIndex,\n\t\t\t\tmodulationType: \"square\",\n\t\t\t\tonstop: i === 0 ? () => this.onsilence(this) : noOp,\n\t\t\t\ttype: \"square\",\n\t\t\t});\n\t\t\tosc.connect(this._highpass);\n\t\t\tthis._oscillators[i] = osc;\n\n\t\t\tconst mult = new Multiply({\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue: inharmRatios[i],\n\t\t\t});\n\t\t\tthis._freqMultipliers[i] = mult;\n\t\t\tthis.frequency.chain(mult, osc.frequency);\n\t\t\tthis.detune.connect(osc.detune);\n\t\t}\n\n\t\tthis._filterFreqScaler = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: 7000,\n\t\t\tmin: this.toFrequency(options.resonance),\n\t\t});\n\n\t\tthis.envelope = new Envelope({\n\t\t\tattack: options.envelope.attack,\n\t\t\tattackCurve: \"linear\",\n\t\t\tcontext: this.context,\n\t\t\tdecay: options.envelope.decay,\n\t\t\trelease: options.envelope.release,\n\t\t\tsustain: 0,\n\t\t});\n\n\t\tthis.envelope.chain(this._filterFreqScaler, this._highpass.frequency);\n\t\tthis.envelope.connect(this._amplitude.gain);\n\t\t// set the octaves\n\t\tthis._octaves = options.octaves;\n\t\tthis.octaves = options.octaves;\n\t}\n\n\tstatic getDefaults(): MetalSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.001,\n\t\t\t\t\tdecay: 1.4,\n\t\t\t\t\trelease: 0.2,\n\t\t\t\t}\n\t\t\t),\n\t\t\tharmonicity: 5.1,\n\t\t\tmodulationIndex: 32,\n\t\t\toctaves: 1.5,\n\t\t\tresonance: 4000,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity that the envelope should be triggered at.\n\t */\n\tprotected _triggerEnvelopeAttack(\n\t\ttime: Seconds,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis._oscillators.forEach((osc) => osc.start(time));\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis._oscillators.forEach((osc) => {\n\t\t\t\tosc.stop(\n\t\t\t\t\ttime +\n\t\t\t\t\t\tthis.toSeconds(this.envelope.attack) +\n\t\t\t\t\t\tthis.toSeconds(this.envelope.decay)\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the envelope.\n\t * @param time When the release should be triggered.\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): this {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis._oscillators.forEach((osc) =>\n\t\t\tosc.stop(time + this.toSeconds(this.envelope.release))\n\t\t);\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * The modulationIndex of the oscillators which make up the source.\n\t * see {@link FMOscillator.modulationIndex}\n\t * @min 1\n\t * @max 100\n\t */\n\tget modulationIndex(): number {\n\t\treturn this._oscillators[0].modulationIndex.value;\n\t}\n\tset modulationIndex(val) {\n\t\tthis._oscillators.forEach((osc) => (osc.modulationIndex.value = val));\n\t}\n\n\t/**\n\t * The harmonicity of the oscillators which make up the source.\n\t * see Tone.FMOscillator.harmonicity\n\t * @min 0.1\n\t * @max 10\n\t */\n\tget harmonicity(): number {\n\t\treturn this._oscillators[0].harmonicity.value;\n\t}\n\tset harmonicity(val) {\n\t\tthis._oscillators.forEach((osc) => (osc.harmonicity.value = val));\n\t}\n\n\t/**\n\t * The lower level of the highpass filter which is attached to the envelope.\n\t * This value should be between [0, 7000]\n\t * @min 0\n\t * @max 7000\n\t */\n\tget resonance(): Frequency {\n\t\treturn this._filterFreqScaler.min;\n\t}\n\tset resonance(val) {\n\t\tthis._filterFreqScaler.min = this.toFrequency(val);\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the \"resonance\" frequency\n\t * that the filter ramps during the attack/decay envelope\n\t * @min 0\n\t * @max 8\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(val) {\n\t\tthis._octaves = val;\n\t\tthis._filterFreqScaler.max =\n\t\t\tthis._filterFreqScaler.min * Math.pow(2, val);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillators.forEach((osc) => osc.dispose());\n\t\tthis._freqMultipliers.forEach((freqMult) => freqMult.dispose());\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._filterFreqScaler.dispose();\n\t\tthis._amplitude.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis._highpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency.js\";\nimport { Frequency, Positive, Time } from \"../core/type/Units.js\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface.js\";\nimport { Monophonic } from \"./Monophonic.js\";\nimport { Synth, SynthOptions } from \"./Synth.js\";\nimport { range, timeRange } from \"../core/util/Decorator.js\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\treadonly name: string = \"MembraneSynth\";\n\n\t/**\n\t * The number of octaves the pitch envelope ramps.\n\t * @min 0.5\n\t * @max 8\n\t */\n\t@range(0)\n\toctaves: Positive;\n\n\t/**\n\t * The amount of time the frequency envelope takes.\n\t * @min 0\n\t * @max 0.5\n\t */\n\t@timeRange(0)\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\t/**\n\t * @param options the options available for the synth see defaults\n\t */\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMembraneSynth.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope: {\n\t\t\t\tattack: 0.001,\n\t\t\t\tattackCurve: \"exponential\",\n\t\t\t\tdecay: 0.4,\n\t\t\t\trelease: 1.4,\n\t\t\t\tsustain: 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(\n\t\t\tnote instanceof FrequencyClass ? note.toFrequency() : note\n\t\t);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(\n\t\t\thertz,\n\t\t\tseconds + this.toSeconds(this.pitchDecay)\n\t\t);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope.js\";\nimport { NormalRange, Time } from \"../core/type/Units.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { Noise, NoiseOptions } from \"../source/Noise.js\";\nimport { Instrument, InstrumentOptions } from \"./Instrument.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope.js\";\nimport { Source } from \"../source/Source.js\";\n\nexport interface NoiseSynthOptions extends InstrumentOptions {\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tnoise: Omit<NoiseOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Tone.NoiseSynth is composed of {@link Noise} through an {@link AmplitudeEnvelope}.\n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * const noiseSynth = new Tone.NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\nexport class NoiseSynth extends Instrument<NoiseSynthOptions> {\n\treadonly name = \"NoiseSynth\";\n\n\t/**\n\t * The noise source.\n\t */\n\treadonly noise: Noise;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<NoiseSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tNoiseSynth.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.noise = new Noise(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t},\n\t\t\t\toptions.noise\n\t\t\t)\n\t\t);\n\n\t\tthis.envelope = new AmplitudeEnvelope(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t},\n\t\t\t\toptions.envelope\n\t\t\t)\n\t\t);\n\n\t\t// connect the noise to the output\n\t\tthis.noise.chain(this.envelope, this.output);\n\t}\n\n\tstatic getDefaults(): NoiseSynthOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\tsustain: 0.0,\n\t\t\t\t}\n\t\t\t),\n\t\t\tnoise: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tNoise.getDefaults(),\n\t\t\t\t\tObject.keys(Source.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\ttype: \"white\",\n\t\t\t\t}\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * Start the attack portion of the envelopes. Unlike other\n\t * instruments, Tone.NoiseSynth doesn't have a note.\n\t * @example\n\t * const noiseSynth = new Tone.NoiseSynth().toDestination();\n\t * noiseSynth.triggerAttack();\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\t// start the noise\n\t\tthis.noise.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis.noise.stop(\n\t\t\t\ttime +\n\t\t\t\t\tthis.toSeconds(this.envelope.attack) +\n\t\t\t\t\tthis.toSeconds(this.envelope.decay)\n\t\t\t);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the release portion of the envelopes.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.noise.stop(time + this.toSeconds(this.envelope.release));\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 0);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and then the release after the duration.\n\t * @param duration The amount of time to hold the note for\n\t * @param time The time the note should start\n\t * @param velocity The volume of the note (0-1)\n\t * @example\n\t * const noiseSynth = new Tone.NoiseSynth().toDestination();\n\t * // hold the note for 0.5 seconds\n\t * noiseSynth.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(\n\t\tduration: Time,\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\ttime = this.toSeconds(time);\n\t\tduration = this.toSeconds(duration);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + duration);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.noise.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","/**\n * All of the classes or functions which are loaded into the AudioWorkletGlobalScope\n */\nconst workletContext: Set<string> = new Set();\n\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\nexport function addToWorklet(classOrFunction: string) {\n\tworkletContext.add(classOrFunction);\n}\n\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\nexport function registerProcessor(name: string, classDesc: string) {\n\tconst processor = /* javascript */ `registerProcessor(\"${name}\", ${classDesc})`;\n\tworkletContext.add(processor);\n}\n\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\nexport function getWorkletGlobalScope(): string {\n\treturn Array.from(workletContext).join(\"\\n\");\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../context/ToneAudioNode.js\";\nimport { noOp } from \"../util/Interface.js\";\nimport { getWorkletGlobalScope } from \"./WorkletGlobalScope.js\";\n\nexport type ToneAudioWorkletOptions = ToneAudioNodeOptions;\n\nexport abstract class ToneAudioWorklet<\n\tOptions extends ToneAudioWorkletOptions,\n> extends ToneAudioNode<Options> {\n\treadonly name: string = \"ToneAudioWorklet\";\n\n\t/**\n\t * The processing node\n\t */\n\tprotected _worklet!: AudioWorkletNode;\n\n\t/**\n\t * A dummy gain node to create a dummy audio param from\n\t */\n\tprivate _dummyGain: GainNode;\n\n\t/**\n\t * A dummy audio param to use when creating Params\n\t */\n\tprotected _dummyParam: AudioParam;\n\n\t/**\n\t * The constructor options for the node\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {};\n\n\t/**\n\t * Get the name of the audio worklet\n\t */\n\tprotected abstract _audioWorkletName(): string;\n\n\t/**\n\t * Invoked when the module is loaded and the node is created\n\t */\n\tprotected abstract onReady(node: AudioWorkletNode): void;\n\n\t/**\n\t * Callback which is invoked when there is an error in the processing\n\t */\n\tonprocessorerror: (e: string) => void = noOp;\n\n\tconstructor(options: Options) {\n\t\tsuper(options);\n\n\t\tconst blobUrl = URL.createObjectURL(\n\t\t\tnew Blob([getWorkletGlobalScope()], { type: \"text/javascript\" })\n\t\t);\n\t\tconst name = this._audioWorkletName();\n\n\t\tthis._dummyGain = this.context.createGain();\n\t\tthis._dummyParam = this._dummyGain.gain;\n\n\t\t// Register the processor\n\t\tthis.context.addAudioWorkletModule(blobUrl).then(() => {\n\t\t\t// create the worklet when it's read\n\t\t\tif (!this.disposed) {\n\t\t\t\tthis._worklet = this.context.createAudioWorkletNode(\n\t\t\t\t\tname,\n\t\t\t\t\tthis.workletOptions\n\t\t\t\t);\n\t\t\t\tthis._worklet.onprocessorerror =\n\t\t\t\t\tthis.onprocessorerror.bind(this);\n\t\t\t\tthis.onReady(this._worklet);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyGain.disconnect();\n\t\tif (this._worklet) {\n\t\t\tthis._worklet.port.postMessage(\"dispose\");\n\t\t\tthis._worklet.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { addToWorklet } from \"./WorkletGlobalScope.js\";\n\nconst toneAudioWorkletProcessor = /* javascript */ `\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the {@link ToneAudioWorklet}. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it's disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === \"dispose\") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n`;\n\naddToWorklet(toneAudioWorkletProcessor);\n","import \"./ToneAudioWorkletProcessor.worklet.js\";\nimport { addToWorklet } from \"./WorkletGlobalScope.js\";\n\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n\naddToWorklet(singleIOProcess);\n","import { addToWorklet } from \"./WorkletGlobalScope.js\";\n\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n\naddToWorklet(delayLine);\n","import \"../../core/worklet/SingleIOProcessor.worklet.js\";\nimport \"../../core/worklet/DelayLine.worklet.js\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope.js\";\n\nexport const workletName = \"feedback-comb-filter\";\n\nconst feedbackCombFilter = /* javascript */ `\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"delayTime\",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}, {\n\t\t\t\tname: \"feedback\",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n`;\n\nregisterProcessor(workletName, feedbackCombFilter);\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport {\n\tconnectSeries,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { NormalRange, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface.js\";\nimport { ToneAudioWorklet } from \"../../core/worklet/ToneAudioWorklet.js\";\nimport { workletName } from \"./FeedbackCombFilter.worklet.js\";\n\nexport interface FeedbackCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n}\n\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n *\n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the\n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the\n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode.\n * @category Component\n */\nexport class FeedbackCombFilter extends ToneAudioWorklet<FeedbackCombFilterOptions> {\n\treadonly name = \"FeedbackCombFilter\";\n\n\t/**\n\t * The amount of delay of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param delayTime The delay time of the filter.\n\t * @param resonance The amount of feedback the filter has.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange);\n\tconstructor(options?: RecursivePartial<FeedbackCombFilterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFeedbackCombFilter.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"delayTime\", \"resonance\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.delayTime = new Param<\"time\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tminValue: 0,\n\t\t\tmaxValue: 1,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\n\t\tthis.resonance = new Param<\"normalRange\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.resonance,\n\t\t\tunits: \"normalRange\",\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\n\t\treadOnly(this, [\"resonance\", \"delayTime\"]);\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\t/**\n\t * The default parameters\n\t */\n\tstatic getDefaults(): FeedbackCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst delayTime = node.parameters.get(\"delayTime\") as AudioParam;\n\t\tthis.delayTime.setParam(delayTime);\n\t\tconst feedback = node.parameters.get(\"feedback\") as AudioParam;\n\t\tthis.resonance.setParam(feedback);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.delayTime.dispose();\n\t\tthis.resonance.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Frequency } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\n\nexport type OnePoleFilterType = \"highpass\" | \"lowpass\";\n\nexport interface OnePoleFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\ttype: OnePoleFilterType;\n}\n\n/**\n * A one pole filter with 6db-per-octave rolloff. Either \"highpass\" or \"lowpass\".\n * Note that changing the type or frequency may result in a discontinuity which\n * can sound like a click or pop.\n * References:\n * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/\n * * http://www.dspguide.com/ch19/2.htm\n * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts\n * @category Component\n */\nexport class OnePoleFilter extends ToneAudioNode<OnePoleFilterOptions> {\n\treadonly name: string = \"OnePoleFilter\";\n\n\t/**\n\t * Hold the current frequency\n\t */\n\tprivate _frequency: Frequency;\n\n\t/**\n\t * the current one pole type\n\t */\n\tprivate _type: OnePoleFilterType;\n\n\t/**\n\t * the current one pole filter\n\t */\n\tprivate _filter!: IIRFilterNode;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param frequency The frequency\n\t * @param type The  filter type, either \"lowpass\" or \"highpass\"\n\t */\n\tconstructor(frequency?: Frequency, type?: OnePoleFilterType);\n\tconstructor(options?: Partial<OnePoleFilterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tOnePoleFilter.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"type\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._frequency = options.frequency;\n\t\tthis._type = options.type;\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis._createFilter();\n\t}\n\n\tstatic getDefaults(): OnePoleFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfrequency: 880,\n\t\t\ttype: \"lowpass\" as OnePoleFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * Create a filter and dispose the old one\n\t */\n\tprivate _createFilter() {\n\t\tconst oldFilter = this._filter;\n\t\tconst freq = this.toFrequency(this._frequency);\n\t\tconst t = 1 / (2 * Math.PI * freq);\n\t\tif (this._type === \"lowpass\") {\n\t\t\tconst a0 = 1 / (t * this.context.sampleRate);\n\t\t\tconst b1 = a0 - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([a0, 0], [1, b1]);\n\t\t} else {\n\t\t\tconst b1 = 1 / (t * this.context.sampleRate) - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([1, -1], [1, b1]);\n\t\t}\n\n\t\tthis.input.chain(this._filter, this.output);\n\t\tif (oldFilter) {\n\t\t\t// dispose it on the next block\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis.input.disconnect(oldFilter);\n\t\t\t\t\toldFilter.disconnect();\n\t\t\t\t}\n\t\t\t}, this.blockTime);\n\t\t}\n\t}\n\n\t/**\n\t * The frequency value.\n\t */\n\tget frequency(): Frequency {\n\t\treturn this._frequency;\n\t}\n\tset frequency(fq) {\n\t\tthis._frequency = fq;\n\t\tthis._createFilter();\n\t}\n\n\t/**\n\t * The OnePole Filter type, either \"highpass\" or \"lowpass\"\n\t */\n\tget type(): OnePoleFilterType {\n\t\treturn this._type;\n\t}\n\tset type(t) {\n\t\tthis._type = t;\n\t\tthis._createFilter();\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filter.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis._filter.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param.js\";\nimport {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Frequency, NormalRange, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { RecursivePartial } from \"../../core/util/Interface.js\";\nimport { FeedbackCombFilter } from \"./FeedbackCombFilter.js\";\nimport { OnePoleFilter } from \"./OnePoleFilter.js\";\n\ninterface LowpassCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n\tdampening: Frequency;\n}\n\n/**\n * A lowpass feedback comb filter. It is similar to\n * {@link FeedbackCombFilter}, but includes a lowpass filter.\n * @category Component\n */\nexport class LowpassCombFilter extends ToneAudioNode<LowpassCombFilterOptions> {\n\treadonly name = \"LowpassCombFilter\";\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _combFilter: FeedbackCombFilter;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The delayTime of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * @param delayTime The delay time of the comb filter\n\t * @param resonance The resonance (feedback) of the comb filter\n\t * @param dampening The cutoff of the lowpass filter dampens the signal as it is fedback.\n\t */\n\tconstructor(\n\t\tdelayTime?: Time,\n\t\tresonance?: NormalRange,\n\t\tdampening?: Frequency\n\t);\n\tconstructor(options?: RecursivePartial<LowpassCombFilterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tLowpassCombFilter.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"delayTime\", \"resonance\", \"dampening\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._combFilter = this.output = new FeedbackCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tresonance: options.resonance,\n\t\t});\n\t\tthis.delayTime = this._combFilter.delayTime;\n\t\tthis.resonance = this._combFilter.resonance;\n\n\t\tthis._lowpass = this.input = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.dampening,\n\t\t\ttype: \"lowpass\",\n\t\t});\n\n\t\t// connections\n\t\tthis._lowpass.connect(this._combFilter);\n\t}\n\n\tstatic getDefaults(): LowpassCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdampening: 3000,\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * The dampening control of the feedback\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lowpass.frequency;\n\t}\n\tset dampening(fq) {\n\t\tthis._lowpass.frequency = fq;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._combFilter.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, NormalRange, Time } from \"../core/type/Units.js\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter.js\";\nimport { deepMerge } from \"../core/util/Defaults.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { Noise } from \"../source/Noise.js\";\nimport { Instrument, InstrumentOptions } from \"./Instrument.js\";\n\nexport interface PluckSynthOptions extends InstrumentOptions {\n\tattackNoise: number;\n\tdampening: Frequency;\n\tresonance: NormalRange;\n\trelease: Time;\n}\n\n/**\n * Karplus-Strong string synthesis.\n * @example\n * const plucky = new Tone.PluckSynth().toDestination();\n * plucky.triggerAttack(\"C4\", \"+0.5\");\n * plucky.triggerAttack(\"C3\", \"+1\");\n * plucky.triggerAttack(\"C2\", \"+1.5\");\n * plucky.triggerAttack(\"C1\", \"+2\");\n * @category Instrument\n */\nexport class PluckSynth extends Instrument<PluckSynthOptions> {\n\treadonly name = \"PluckSynth\";\n\n\t/**\n\t * Noise burst at the beginning\n\t */\n\tprivate _noise: Noise;\n\tprivate _lfcf: LowpassCombFilter;\n\n\t/**\n\t * The amount of noise at the attack.\n\t * Nominal range of [0.1, 20]\n\t * @min 0.1\n\t * @max 20\n\t */\n\tattackNoise: number;\n\n\t/**\n\t * The amount of resonance of the pluck. Also correlates to the sustain duration.\n\t */\n\tresonance: NormalRange;\n\n\t/**\n\t * The release time which corresponds to a resonance ramp down to 0\n\t */\n\trelease: Time;\n\n\tconstructor(options?: RecursivePartial<PluckSynthOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPluckSynth.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._noise = new Noise({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"pink\",\n\t\t});\n\n\t\tthis.attackNoise = options.attackNoise;\n\n\t\tthis._lfcf = new LowpassCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdampening: options.dampening,\n\t\t\tresonance: options.resonance,\n\t\t});\n\n\t\tthis.resonance = options.resonance;\n\t\tthis.release = options.release;\n\n\t\tthis._noise.connect(this._lfcf);\n\t\tthis._lfcf.connect(this.output);\n\t}\n\n\tstatic getDefaults(): PluckSynthOptions {\n\t\treturn deepMerge(Instrument.getDefaults(), {\n\t\t\tattackNoise: 1,\n\t\t\tdampening: 4000,\n\t\t\tresonance: 0.7,\n\t\t\trelease: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t * @min 0\n\t * @max 7000\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lfcf.dampening;\n\t}\n\tset dampening(fq) {\n\t\tthis._lfcf.dampening = fq;\n\t}\n\n\ttriggerAttack(note: Frequency, time?: Time): this {\n\t\tconst freq = this.toFrequency(note);\n\t\ttime = this.toSeconds(time);\n\t\tconst delayAmount = 1 / freq;\n\t\tthis._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t\tthis._noise.start(time);\n\t\tthis._noise.stop(time + delayAmount * this.attackNoise);\n\t\tthis._lfcf.resonance.cancelScheduledValues(time);\n\t\tthis._lfcf.resonance.setValueAtTime(this.resonance, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ramp down the {@link resonance} to 0 over the duration of the release time.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis._lfcf.resonance.linearRampTo(0, this.release, time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._noise.dispose();\n\t\tthis._lfcf.dispose();\n\t\treturn this;\n\t}\n}\n","import { MidiClass } from \"../core/type/Midi.js\";\nimport {\n\tFrequency,\n\tMidiNote,\n\tNormalRange,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport {\n\tdeepMerge,\n\tomitFromObject,\n\toptionsFromArguments,\n} from \"../core/util/Defaults.js\";\nimport { RecursivePartial } from \"../core/util/Interface.js\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument, InstrumentOptions } from \"./Instrument.js\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth.js\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth.js\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth.js\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth.js\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth.js\";\nimport { Monophonic } from \"./Monophonic.js\";\nimport { Synth, SynthOptions } from \"./Synth.js\";\nimport { assert, warn } from \"../core/util/Debug.js\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> = T extends MembraneSynth\n\t? MembraneSynthOptions\n\t: T extends MetalSynth\n\t\t? MetalSynthOptions\n\t\t: T extends FMSynth\n\t\t\t? FMSynthOptions\n\t\t\t: T extends MonoSynth\n\t\t\t\t? MonoSynthOptions\n\t\t\t\t: T extends AMSynth\n\t\t\t\t\t? AMSynthOptions\n\t\t\t\t\t: T extends Synth\n\t\t\t\t\t\t? SynthOptions\n\t\t\t\t\t\t: T extends Monophonic<infer U>\n\t\t\t\t\t\t\t? U\n\t\t\t\t\t\t\t: never;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<\n\tOmitMonophonicOptions<VoiceOptions<T>>\n>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second parameter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<\n\tVoice extends Monophonic<any> = Synth,\n> extends Instrument<VoiceOptions<Voice>> {\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{\n\t\tmidi: MidiNote;\n\t\tvoice: Voice;\n\t\treleased: boolean;\n\t}> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPolySynth.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"voice\", \"options\"]\n\t\t);\n\t\tsuper(options);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(\n\t\t\t!isNumber(options.voice),\n\t\t\t\"DEPRECATED: The polyphony count is no longer the first argument.\"\n\t\t);\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(\n\t\t\tdefaults,\n\t\t\toptions.options\n\t\t) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(\n\t\t\tthis._collectGarbage.bind(this),\n\t\t\t1\n\t\t);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex(\n\t\t\t(e) => e.voice === voice\n\t\t);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(\n\t\t\t\tObject.assign(this.options, {\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t\t})\n\t\t\t);\n\t\t\tassert(\n\t\t\t\tvoice instanceof Monophonic,\n\t\t\t\t\"Voice must extend Monophonic class\"\n\t\t\t);\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(\n\t\t\tthis._averageActiveVoices * 0.95,\n\t\t\tthis.activeVoices\n\t\t);\n\t\tif (\n\t\t\tthis._availableVoices.length &&\n\t\t\tthis._voices.length > Math.ceil(this._averageActiveVoices + 1)\n\t\t) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(\n\t\tnotes: Frequency[],\n\t\ttime: Seconds,\n\t\tvelocity?: NormalRange\n\t): void {\n\t\tnotes.forEach((note) => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote,\n\t\t\t\t\tvoice,\n\t\t\t\t\treleased: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach((note) => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(\n\t\t\t\t({ midi, released }) => midi === midiNote && !released\n\t\t\t);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(\n\t\ttype: \"attack\" | \"release\",\n\t\tnotes: Frequency[],\n\t\ttime: Seconds,\n\t\tvelocity?: NormalRange\n\t): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t\t}\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(\n\t\tnotes: Frequency | Frequency[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange\n\t): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes.\n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(\n\t\t\t\tisArray(notes),\n\t\t\t\t\"If the duration is an array, the notes must also be an array\"\n\t\t\t);\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(\n\t\t\t\t\tdurationSeconds > 0,\n\t\t\t\t\t\"The duration must be greater than 0\"\n\t\t\t\t);\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\n\t\t\t// make sure that the sound doesn't play after its been stopped\n\t\t\tthis.context.transport.on(\"stop\", this._syncedRelease);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedRelease);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedRelease);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The release which is scheduled to the timeline.\n\t */\n\tprotected _syncedRelease = (time: number) => this.releaseAll(time);\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\n\t\t\t\"onsilence\",\n\t\t\t\"context\",\n\t\t]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach((voice) => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach((v) => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer.js\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers.js\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions.js\";\nimport { FrequencyClass } from \"../core/type/Frequency.js\";\nimport {\n\tFrequency,\n\tInterval,\n\tMidiNote,\n\tNormalRange,\n\tNote,\n\tTime,\n} from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck.js\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument.js\";\nimport {\n\tToneBufferSource,\n\tToneBufferSourceCurve,\n} from \"../source/buffer/ToneBufferSource.js\";\nimport { timeRange } from \"../core/util/Decorator.js\";\nimport { assert } from \"../core/util/Debug.js\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use {@link Player}.\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(\n\t\tsamples?: SamplesMap,\n\t\toptions?: Partial<Omit<SamplerOptions, \"urls\">>\n\t);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tSampler.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"urls\", \"onload\", \"baseUrl\"],\n\t\t\t\"urls\"\n\t\t);\n\t\tsuper(options);\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tassert(\n\t\t\t\tisNote(note) || (isNumber(noteNumber) && isFinite(noteNumber)),\n\t\t\t\t`url key is neither a note or midi pitch: ${note}`\n\t\t\t);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: urlMap,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as const,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(\n\t\tnotes: Frequency | Frequency[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach((note) => {\n\t\t\tconst midiFloat = ftomf(\n\t\t\t\tnew FrequencyClass(this.context, note).toFrequency()\n\t\t\t);\n\t\t\tconst midi = Math.round(midiFloat) as MidiNote;\n\t\t\tconst remainder = midiFloat - midi;\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(\n\t\t\t\tdifference + remainder\n\t\t\t);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\turl: buffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(\n\t\t\t\t\t\tmidi\n\t\t\t\t\t) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach((note) => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (\n\t\t\t\tthis._activeSources.has(midi) &&\n\t\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).length\n\t\t\t) {\n\t\t\t\tconst sources = this._activeSources.get(\n\t\t\t\t\tmidi\n\t\t\t\t) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach((source) => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach((sources) => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(\n\t\t\t\tisArray(notes),\n\t\t\t\t\"notes must be an array when duration is array\"\n\t\t\t);\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(\n\t\tnote: Note | MidiNote,\n\t\turl: string | ToneAudioBuffer | AudioBuffer,\n\t\tcallback?: () => void\n\t): this {\n\t\tassert(\n\t\t\tisNote(note) || isFinite(note),\n\t\t\t`note must be a pitch or midi: ${note}`\n\t\t);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach((sources) => {\n\t\t\tsources.forEach((source) => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n","import \"../core/clock/Transport.js\";\nimport {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../core/context/ToneWithContext.js\";\nimport { TicksClass } from \"../core/type/Ticks.js\";\nimport { TransportTimeClass } from \"../core/type/TransportTime.js\";\nimport {\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTicks,\n\tTime,\n\tTransportTime,\n} from \"../core/type/Units.js\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport {\n\tBasicPlaybackState,\n\tStateTimeline,\n} from \"../core/util/StateTimeline.js\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck.js\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * const chordEvent = new Tone.ToneEvent(((time, chord) => {\n * \t// the chord as well as the exact time of the event\n * \t// are passed in as arguments to the callback function\n * \tsynth.triggerAttackRelease(chord, 0.5, time);\n * }), [\"D4\", \"E4\", \"F4\"]);\n * // start the chord at the beginning of the transport timeline\n * chordEvent.start();\n * // loop it every measure for 8 measures\n * chordEvent.loop = 8;\n * chordEvent.loopEnd = \"1m\";\n * @category Event\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<\n\tToneEventOptions<ValueType>\n> {\n\treadonly name: string = \"ToneEvent\";\n\n\t/**\n\t * Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t * The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t * The value which is passed to the\n\t * callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The playback speed of the note. A speed of 1\n\t * is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t * A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t * private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t * the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t * If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param value The value or values which should be passed to the callback function on invocation.\n\t */\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tToneEvent.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"callback\", \"value\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._state.increasing = true;\n\t\t// schedule the events for the first time\n\t\tthis._rescheduleEvents();\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp,\n\t\t\thumanize: false,\n\t\t\tloop: false,\n\t\t\tloopEnd: \"1m\",\n\t\t\tloopStart: 0,\n\t\t\tmute: false,\n\t\t\tplaybackRate: 1,\n\t\t\tprobability: 1,\n\t\t\tvalue: null,\n\t\t});\n\t}\n\n\t/**\n\t * Reschedule all of the events along the timeline\n\t * with the updated values.\n\t * @param after Only reschedules events after the given time.\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, (event) => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick =\n\t\t\t\t\tevent.time +\n\t\t\t\t\tMath.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (\n\t\t\t\t\tthis._loop === true ||\n\t\t\t\t\t(isNumber(this._loop) && this._loop > 1)\n\t\t\t\t) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = this._loop * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(\n\t\t\t\t\t\t\tduration,\n\t\t\t\t\t\t\tnextEvent.time - startTick\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(\n\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\tthis._getLoopDuration()\n\t\t\t\t\t);\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this),\n\t\t\t\t\t\tinterval,\n\t\t\t\t\t\tnew TicksClass(this.context, startTick),\n\t\t\t\t\t\tduration\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(\n\t\t\t\t\t\tthis._tick.bind(this),\n\t\t\t\t\t\tnew TicksClass(this.context, startTick)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(\n\t\t\tthis.context.transport.ticks\n\t\t) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t * The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * const event = new Tone.ToneEvent();\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t * Start the note at the given time.\n\t * @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the Event at the given time.\n\t * @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet rescheduleTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\trescheduleTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(rescheduleTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, (event) => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The callback function invoker. Also\n\t * checks if the Event is done playing\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t * Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn (this._loopEnd - this._loopStart) / this._playbackRate;\n\t}\n\n\t/**\n\t * If the note should loop or not\n\t * between ToneEvent.loopStart and\n\t * ToneEvent.loopEnd. If set to true,\n\t * the event will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The playback rate of the event. Defaults to 1.\n\t * @example\n\t * const note = new Tone.ToneEvent();\n\t * note.loop = true;\n\t * // repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The loopEnd point is the time the event will loop\n\t * if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The current progress of the loop interval.\n\t * Returns 0 if the event is not started yet or\n\t * it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneEvent } from \"./ToneEvent.js\";\nimport {\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTime,\n\tTransportTime,\n} from \"../core/type/Units.js\";\nimport {\n\tToneWithContext,\n\tToneWithContextOptions,\n} from \"../core/context/ToneWithContext.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline.js\";\n\nexport interface LoopOptions extends ToneWithContextOptions {\n\tcallback: (time: Seconds) => void;\n\tinterval: Time;\n\tplaybackRate: Positive;\n\titerations: number;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop<\n\tOptions extends LoopOptions = LoopOptions,\n> extends ToneWithContext<Options> {\n\treadonly name: string = \"Loop\";\n\n\t/**\n\t * The event which produces the callbacks\n\t */\n\tprivate _event: ToneEvent;\n\n\t/**\n\t * The callback to invoke with the next event in the pattern\n\t */\n\tcallback: (time: Seconds) => void;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param interval The time between successive callback calls.\n\t */\n\tconstructor(callback?: (time: Seconds) => void, interval?: Time);\n\tconstructor(options?: Partial<LoopOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Loop.getDefaults(), arguments, [\n\t\t\t\"callback\",\n\t\t\t\"interval\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._event = new ToneEvent({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tloop: true,\n\t\t\tloopEnd: options.interval,\n\t\t\tplaybackRate: options.playbackRate,\n\t\t\tprobability: options.probability,\n\t\t\thumanize: options.humanize,\n\t\t});\n\n\t\tthis.callback = options.callback;\n\t\t// set the iterations\n\t\tthis.iterations = options.iterations;\n\t}\n\n\tstatic getDefaults(): LoopOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tinterval: \"4n\",\n\t\t\tcallback: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\titerations: Infinity,\n\t\t\tprobability: 1,\n\t\t\tmute: false,\n\t\t\thumanize: false,\n\t\t});\n\t}\n\n\t/**\n\t * Start the loop at the specified time along the Transport's timeline.\n\t * @param  time  When to start the Loop.\n\t */\n\tstart(time?: TransportTime): this {\n\t\tthis._event.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the loop at the given time.\n\t * @param  time  When to stop the Loop.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._event.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime): this {\n\t\tthis._event.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t * @param time  The time the event occurs\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tthis.callback(time);\n\t}\n\n\t/**\n\t * The state of the Loop, either started or stopped.\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._event.state;\n\t}\n\n\t/**\n\t * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n\t */\n\tget progress(): NormalRange {\n\t\treturn this._event.progress;\n\t}\n\n\t/**\n\t * The time between successive callbacks.\n\t * @example\n\t * const loop = new Tone.Loop();\n\t * loop.interval = \"8n\"; // loop every 8n\n\t */\n\tget interval(): Time {\n\t\treturn this._event.loopEnd;\n\t}\n\tset interval(interval) {\n\t\tthis._event.loopEnd = interval;\n\t}\n\n\t/**\n\t * The playback rate of the loop. The normal playback rate is 1 (no change).\n\t * A `playbackRate` of 2 would be twice as fast.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._event.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._event.playbackRate = rate;\n\t}\n\n\t/**\n\t * Random variation +/-0.01s to the scheduled time.\n\t * Or give it a time value which it will randomize by.\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._event.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._event.humanize = variation;\n\t}\n\n\t/**\n\t * The probably of the callback being invoked.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._event.probability;\n\t}\n\n\tset probability(prob) {\n\t\tthis._event.probability = prob;\n\t}\n\n\t/**\n\t * Muting the Loop means that no callbacks are invoked.\n\t */\n\tget mute(): boolean {\n\t\treturn this._event.mute;\n\t}\n\n\tset mute(mute) {\n\t\tthis._event.mute = mute;\n\t}\n\n\t/**\n\t * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n\t */\n\tget iterations(): number {\n\t\tif (this._event.loop === true) {\n\t\t\treturn Infinity;\n\t\t} else {\n\t\t\treturn this._event.loop as number;\n\t\t}\n\t}\n\tset iterations(iters) {\n\t\tif (iters === Infinity) {\n\t\t\tthis._event.loop = true;\n\t\t} else {\n\t\t\tthis._event.loop = iters;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._event.dispose();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks.js\";\nimport { TransportTimeClass } from \"../core/type/TransportTime.js\";\nimport {\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTicks,\n\tTime,\n\tTransportTime,\n} from \"../core/type/Units.js\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { StateTimeline } from \"../core/util/StateTimeline.js\";\nimport {\n\tisArray,\n\tisDefined,\n\tisObject,\n\tisUndef,\n} from \"../core/util/TypeCheck.js\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent.js\";\n\ntype CallbackType<T> = T extends {\n\ttime: Time;\n\t[key: string]: any;\n}\n\t? T\n\t: T extends ArrayLike<any>\n\t\t? T[1]\n\t\t: T extends Time\n\t\t\t? null\n\t\t\t: never;\n\ninterface PartOptions<T>\n\textends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]).start(0);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param value the array of events\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<CallbackType<ValueType>>,\n\t\tvalue?: ValueType[]\n\t);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\n\t\t\t\"callback\",\n\t\t\t\"events\",\n\t\t]);\n\t\tsuper(options);\n\n\t\t// make sure things are assigned in the right order\n\t\tthis._state.increasing = true;\n\n\t\t// add the events\n\t\toptions.events.forEach((event) => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach((event) => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (\n\t\t\t\tevent.startOffset >= this._loopStart &&\n\t\t\t\tevent.startOffset < this._loopEnd\n\t\t\t) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (\n\t\t\t\tevent.startOffset < this._loopStart &&\n\t\t\t\tevent.startOffset >= offset\n\t\t\t) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach((event) => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach((event) => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.at(\"1m\"); // returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n\t * // if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(\n\t\t\tthis.context,\n\t\t\ttime\n\t\t).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value Any value to add to the timeline\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.add(\"1m\", \"C#+11\");\n\t */\n\tadd(obj: { time: Time; [key: string]: any }): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: { time: Time; [key: string]: any }): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach((event) => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (\n\t\t\t\t\tisUndef(value) ||\n\t\t\t\t\t(isDefined(value) && event.value === value)\n\t\t\t\t) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach((event) => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach((event) => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach((event) => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach((event) => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (\n\t\t\tthis._loop &&\n\t\t\t(event.startOffset < this._loopStart ||\n\t\t\t\tevent.startOffset >= this._loopEnd)\n\t\t) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * const part = new Tone.Part();\n\t * // loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach((event) => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach((event) => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach((event) => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { assert } from \"../core/util/Debug.js\";\nimport { clamp } from \"../core/util/Math.js\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName =\n\t| \"up\"\n\t| \"down\"\n\t| \"upDown\"\n\t| \"downUp\"\n\t| \"alternateUp\"\n\t| \"alternateDown\"\n\t| \"random\"\n\t| \"randomOnce\"\n\t| \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(numValues: number): IterableIterator<number> {\n\tlet index = 0;\n\twhile (index < numValues) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(numValues: number): IterableIterator<number> {\n\tlet index = numValues - 1;\n\twhile (index >= 0) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(\n\tnumValues: number,\n\tgen: typeof upPatternGen\n): IterableIterator<number> {\n\twhile (true) {\n\t\tyield* gen(numValues);\n\t}\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(\n\tnumValues: number,\n\tdirectionUp: boolean\n): IterableIterator<number> {\n\tlet index = directionUp ? 0 : numValues - 1;\n\twhile (true) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= numValues - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(numValues: number): IterableIterator<number> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < numValues) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tstepIndex++;\n\t\tindex += stepIndex % 2 ? 2 : -1;\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(numValues: number): IterableIterator<number> {\n\tlet index = numValues - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clamp(index, 0, numValues - 1);\n\t\tyield index;\n\t\tstepIndex++;\n\t\tindex += stepIndex % 2 ? -2 : 1;\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(numValues: number): IterableIterator<number> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * numValues);\n\t\tyield randomIndex;\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(numValues: number): IterableIterator<number> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < numValues; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clamp(randVal[0], 0, numValues - 1);\n\t\tyield index;\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index\n */\nfunction* randomWalk<T>(numValues: number): IterableIterator<number> {\n\t// randomly choose a starting index\n\tlet index = Math.floor(Math.random() * numValues);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom, so force upward step\n\t\t} else if (index === numValues - 1) {\n\t\t\tindex--; // at top, so force downward step\n\t\t} else if (Math.random() < 0.5) {\n\t\t\t// else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield index;\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will yield numbers between 0 and numValues\n * according to the passed in pattern that can be used as indexes into an array of size numValues.\n * @param numValues The size of the array to emit indexes for\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator(\n\tnumValues: number,\n\tpattern: PatternName = \"up\",\n\tindex = 0\n): Iterator<number> {\n\t// safeguards\n\tassert(numValues >= 1, \"The number of values must be at least one\");\n\tswitch (pattern) {\n\t\tcase \"up\":\n\t\t\tyield* infiniteGen(numValues, upPatternGen);\n\t\tcase \"down\":\n\t\t\tyield* infiniteGen(numValues, downPatternGen);\n\t\tcase \"upDown\":\n\t\t\tyield* alternatingGenerator(numValues, true);\n\t\tcase \"downUp\":\n\t\t\tyield* alternatingGenerator(numValues, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(numValues, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(numValues, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(numValues);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(numValues, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(numValues);\n\t}\n}\n","import { Loop, LoopOptions } from \"./Loop.js\";\nimport { PatternGenerator, PatternName } from \"./PatternGenerator.js\";\nimport { ToneEventCallback } from \"./ToneEvent.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Seconds } from \"../core/type/Units.js\";\nimport { noOp } from \"../core/util/Interface.js\";\n\nexport interface PatternOptions<ValueType> extends LoopOptions {\n\tpattern: PatternName;\n\tvalues: ValueType[];\n\tcallback: (time: Seconds, value?: ValueType) => void;\n}\n\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport class Pattern<ValueType> extends Loop<PatternOptions<ValueType>> {\n\treadonly name: string = \"Pattern\";\n\n\t/**\n\t * The pattern generator function\n\t */\n\tprivate _pattern: Iterator<number>;\n\n\t/**\n\t * The current index\n\t */\n\tprivate _index?: number;\n\n\t/**\n\t * The current value\n\t */\n\tprivate _value?: ValueType;\n\n\t/**\n\t * Hold the pattern type\n\t */\n\tprivate _type: PatternName;\n\n\t/**\n\t * Hold the values\n\t */\n\tprivate _values: ValueType[];\n\n\t/**\n\t * The callback to be invoked at a regular interval\n\t */\n\tcallback: (time: Seconds, value?: ValueType) => void;\n\n\t/**\n\t * @param  callback The callback to invoke with the event.\n\t * @param  values The values to arpeggiate over.\n\t * @param  pattern  The name of the pattern\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tvalues?: ValueType[],\n\t\tpattern?: PatternName\n\t);\n\tconstructor(options?: Partial<PatternOptions<ValueType>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Pattern.getDefaults(), arguments, [\n\t\t\t\"callback\",\n\t\t\t\"values\",\n\t\t\t\"pattern\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.callback = options.callback;\n\t\tthis._values = options.values;\n\t\tthis._pattern = PatternGenerator(\n\t\t\toptions.values.length,\n\t\t\toptions.pattern\n\t\t);\n\t\tthis._type = options.pattern;\n\t}\n\n\tstatic getDefaults(): PatternOptions<any> {\n\t\treturn Object.assign(Loop.getDefaults(), {\n\t\t\tpattern: \"up\" as const,\n\t\t\tvalues: [],\n\t\t\tcallback: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst index = this._pattern.next() as IteratorResult<ValueType>;\n\t\tthis._index = index.value;\n\t\tthis._value = this._values[index.value];\n\t\tthis.callback(time, this._value);\n\t}\n\n\t/**\n\t * The array of events.\n\t */\n\tget values(): ValueType[] {\n\t\treturn this._values;\n\t}\n\tset values(val) {\n\t\tthis._values = val;\n\t\t// reset the pattern\n\t\tthis.pattern = this._type;\n\t}\n\n\t/**\n\t * The current value of the pattern.\n\t */\n\tget value(): ValueType | undefined {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * The current index of the pattern.\n\t */\n\tget index(): number | undefined {\n\t\treturn this._index;\n\t}\n\n\t/**\n\t * The pattern type.\n\t */\n\tget pattern(): PatternName {\n\t\treturn this._type;\n\t}\n\tset pattern(pattern) {\n\t\tthis._type = pattern;\n\t\tthis._pattern = PatternGenerator(this._values.length, this._type);\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks.js\";\nimport {\n\tNormalRange,\n\tPositive,\n\tSeconds,\n\tTicks,\n\tTime,\n\tTransportTime,\n} from \"../core/type/Units.js\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { isArray, isString } from \"../core/util/TypeCheck.js\";\nimport { Part } from \"./Part.js\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent.js\";\n\ntype SequenceEventDescription<T> = Array<T | SequenceEventDescription<T>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal Cycles](http://tidalcycles.org/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  events  The sequence of events\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tSequence.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"callback\", \"events\", \"subdivision\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(\n\t\t\tomitFromObject(ToneEvent.getDefaults(), [\"value\"]),\n\t\t\t{\n\t\t\t\tevents: [],\n\t\t\t\tloop: true,\n\t\t\t\tloopEnd: 0,\n\t\t\t\tloopStart: 0,\n\t\t\t\tsubdivision: \"8n\",\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null && !this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (\n\t\t\t\ttarget: any[],\n\t\t\t\tproperty: PropertyKey,\n\t\t\t\tvalue: any\n\t\t\t): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(\n\t\t\tthis._eventsArray,\n\t\t\tthis._subdivision,\n\t\t\tthis.startOffset\n\t\t);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(\n\t\tsequence: any[],\n\t\tsubdivision: Ticks,\n\t\tstartOffset: Ticks\n\t): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * subdivision + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(\n\t\t\t\t\tvalue,\n\t\t\t\t\tsubdivision / value.length,\n\t\t\t\t\teventOffset\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(\n\t\t\t\t\tthis.context,\n\t\t\t\t\teventOffset,\n\t\t\t\t\t\"i\"\n\t\t\t\t).toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(\n\t\t\tthis.context,\n\t\t\tindex * this._subdivision + this.startOffset\n\t\t).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tconnect,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { NormalRange } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { GainToAudio } from \"../../signal/GainToAudio.js\";\nimport { Signal } from \"../../signal/Signal.js\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * const crossFade = new Tone.CrossFade().toDestination();\n * // connect two inputs Tone.to a/b\n * const inputA = new Tone.Oscillator(440, \"square\").connect(crossFade.a).start();\n * const inputB = new Tone.Oscillator(440, \"sine\").connect(crossFade.b).start();\n * // use the fade to control the mix between the two\n * crossFade.fade.value = 0.5;\n * @category Component\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\treadonly name: string = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context: this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\treadonly a: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\treadonly b: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\treadonly output: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The mix between the two inputs. A fade value of 0\n\t * will output 100% crossFade.a and\n\t * a value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<\"normalRange\">;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\t/**\n\t * @param fade The initial fade value [0, 1].\n\t */\n\tconstructor(fade?: NormalRange);\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tCrossFade.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"fade\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n","import { CrossFade } from \"../component/channel/CrossFade.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode.js\";\nimport { NormalRange } from \"../core/type/Units.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Signal } from \"../signal/Signal.js\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nexport abstract class Effect<\n\tOptions extends EffectOptions,\n> extends ToneAudioNode<Options> {\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context: this.context });\n\n\t/**\n\t * The wet control is how much of the effected\n\t * will pass through to the output. 1 = 100% effected\n\t * signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<\"normalRange\"> = this._dryWet.fade;\n\n\t/**\n\t * connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\t/**\n\t * chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"../effect/Effect.js\";\nimport { Frequency, NormalRange, Time } from \"../core/type/Units.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Param } from \"../core/context/Param.js\";\n\nexport interface LFOEffectOptions extends EffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n}\n\n/**\n * Base class for LFO-based effects.\n */\nexport abstract class LFOEffect<\n\tOptions extends LFOEffectOptions,\n> extends Effect<Options> {\n\treadonly name: string = \"LFOEffect\";\n\n\t/**\n\t * the lfo which drives the filter cutoff\n\t */\n\tprotected _lfo: LFO;\n\n\t/**\n\t * The range of the filter modulating between the min and max frequency.\n\t * 0 = no modulation. 1 = full modulation.\n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * How fast the filter modulates between min and max.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\tconstructor(options: LFOEffectOptions) {\n\t\tsuper(options);\n\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tamplitude: options.depth,\n\t\t});\n\t\tthis.depth = this._lfo.amplitude;\n\t\tthis.frequency = this._lfo.frequency;\n\n\t\tthis.type = options.type;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t}\n\n\tstatic getDefaults(): LFOEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 1,\n\t\t\ttype: \"sine\" as ToneOscillatorType,\n\t\t\tdepth: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfo.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfo.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport.\n\t * @see {@link LFO.sync}\n\t */\n\tsync(): this {\n\t\tthis._lfo.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfo.unsync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the LFO's oscillator.\n\t * @see {@link Oscillator.type}\n\t * @example\n\t * const autoFilter = new Tone.AutoFilter().start().toDestination();\n\t * const noise = new Tone.Noise().start().connect(autoFilter);\n\t * autoFilter.type = \"square\";\n\t */\n\tget type() {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, Positive } from \"../core/type/Units.js\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter.js\";\nimport { SourceOptions } from \"../source/Source.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect.js\";\n\nexport interface AutoFilterOptions extends LFOEffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tfilter: Omit<\n\t\tFilterOptions,\n\t\tkeyof SourceOptions | \"frequency\" | \"detune\" | \"gain\"\n\t>;\n}\n\n/**\n * AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n * Setting the LFO rate and depth allows for control over the filter modulation rate\n * and depth.\n *\n * @example\n * // create an autofilter and start it's LFO\n * const autoFilter = new Tone.AutoFilter(\"4n\").toDestination().start();\n * // route an oscillator through the filter and start it\n * const oscillator = new Tone.Oscillator().connect(autoFilter).start();\n * @category Effect\n */\nexport class AutoFilter extends LFOEffect<AutoFilterOptions> {\n\treadonly name: string = \"AutoFilter\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The octaves placeholder\n\t */\n\tprivate _octaves!: Positive;\n\n\t/**\n\t * @param frequency The rate of the LFO.\n\t * @param baseFrequency The lower value of the LFOs oscillation\n\t * @param octaves The number of octaves above the baseFrequency\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\tbaseFrequency?: Frequency,\n\t\toctaves?: Positive\n\t);\n\tconstructor(options?: Partial<AutoFilterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tAutoFilter.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\", \"baseFrequency\", \"octaves\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.filter = new Filter(\n\t\t\tObject.assign(options.filter, {\n\t\t\t\tcontext: this.context,\n\t\t\t})\n\t\t);\n\n\t\t// connections\n\t\tthis.connectEffect(this.filter);\n\t\tthis._lfo.connect(this.filter.frequency);\n\t\tthis.octaves = options.octaves;\n\t\tthis.baseFrequency = options.baseFrequency;\n\t}\n\n\tstatic getDefaults(): AutoFilterOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\toctaves: 2.6,\n\t\t\tfilter: {\n\t\t\t\ttype: \"lowpass\" as const,\n\t\t\t\trolloff: -12 as -12,\n\t\t\t\tQ: 1,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * The minimum value of the filter's cutoff frequency.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._lfo.min;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._lfo.min = this.toFrequency(freq);\n\t\t// and set the max\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The maximum value of the filter's cutoff frequency.\n\t */\n\tget octaves(): Positive {\n\t\treturn this._octaves;\n\t}\n\tset octaves(oct) {\n\t\tthis._octaves = oct;\n\t\tthis._lfo.max = this._lfo.min * Math.pow(2, oct);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { AudioRange } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n\ninterface TonePannerOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tchannelCount: number;\n}\n\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @example\n * return Tone.Offline(() => {\n * // move the input signal from right to left\n * \tconst panner = new Tone.Panner(1).toDestination();\n * \tpanner.pan.rampTo(-1, 0.5);\n * \tconst osc = new Tone.Oscillator(100).connect(panner).start();\n * }, 0.5, 2);\n * @category Component\n */\nexport class Panner extends ToneAudioNode<TonePannerOptions> {\n\treadonly name: string = \"Panner\";\n\n\t/**\n\t * the panner node\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\treadonly input: StereoPannerNode = this._panner;\n\treadonly output: StereoPannerNode = this._panner;\n\n\t/**\n\t * The pan control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \t// pan hard right\n\t * \tconst panner = new Tone.Panner(1).toDestination();\n\t * \t// pan hard left\n\t * \tpanner.pan.setValueAtTime(-1, 0.25);\n\t * \tconst osc = new Tone.Oscillator(50, \"triangle\").connect(panner).start();\n\t * }, 0.5, 2);\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\tconstructor(options?: Partial<TonePannerOptions>);\n\t/**\n\t * @param pan The initial panner value (Defaults to 0 = \"center\").\n\t */\n\tconstructor(pan?: AudioRange);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Panner.getDefaults(), arguments, [\n\t\t\t\"pan\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.pan = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.pan,\n\t\t\tvalue: options.pan,\n\t\t\tminValue: -1,\n\t\t\tmaxValue: 1,\n\t\t});\n\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = options.channelCount;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\n\t\t// initial value\n\t\treadOnly(this, \"pan\");\n\t}\n\n\tstatic getDefaults(): TonePannerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.pan.dispose();\n\t\treturn this;\n\t}\n}\n","import { Panner } from \"../component/channel/Panner.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect.js\";\nimport { Frequency } from \"../core/type/Units.js\";\n\nexport interface AutoPannerOptions extends LFOEffectOptions {\n\tchannelCount: number;\n}\n\n/**\n * AutoPanner is a {@link Panner} with an {@link LFO} connected to the pan amount.\n * [Related Reading](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n *\n * @example\n * // create an autopanner and start it\n * const autoPanner = new Tone.AutoPanner(\"4n\").toDestination().start();\n * // route an oscillator through the panner and start it\n * const oscillator = new Tone.Oscillator().connect(autoPanner).start();\n * @category Effect\n */\nexport class AutoPanner extends LFOEffect<AutoPannerOptions> {\n\treadonly name: string = \"AutoPanner\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly _panner: Panner;\n\n\t/**\n\t * @param frequency Rate of left-right oscillation.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<AutoPannerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tAutoPanner.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._panner = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tchannelCount: options.channelCount,\n\t\t});\n\t\t// connections\n\t\tthis.connectEffect(this._panner);\n\t\tthis._lfo.connect(this._panner.pan);\n\t\tthis._lfo.min = -1;\n\t\tthis._lfo.max = 1;\n\t}\n\n\tstatic getDefaults(): AutoPannerOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\treturn this;\n\t}\n}\n","import { Time } from \"../../core/type/Units.js\";\nimport {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { OnePoleFilter } from \"../filter/OnePoleFilter.js\";\nimport { Abs } from \"../../signal/Abs.js\";\n\nexport interface FollowerOptions extends ToneAudioNodeOptions {\n\tsmoothing: Time;\n}\n\n/**\n * Follower is a simple envelope follower.\n * It's implemented by applying a lowpass filter to the absolute value of the incoming signal.\n * ```\n *          +-----+    +---------------+\n * Input +--> Abs +----> OnePoleFilter +--> Output\n *          +-----+    +---------------+\n * ```\n * @category Component\n */\nexport class Follower extends ToneAudioNode<FollowerOptions> {\n\treadonly name: string = \"Follower\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Private reference to the smoothing parameter\n\t */\n\tprivate _smoothing: Time;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The absolute value\n\t */\n\tprivate _abs: Abs;\n\n\t/**\n\t * @param smoothing The rate of change of the follower.\n\t */\n\tconstructor(smoothing?: Time);\n\tconstructor(options?: Partial<FollowerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFollower.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"smoothing\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._abs = this.input = new Abs({ context: this.context });\n\t\tthis._lowpass = this.output = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 1 / this.toSeconds(options.smoothing),\n\t\t\ttype: \"lowpass\",\n\t\t});\n\t\tthis._abs.connect(this._lowpass);\n\t\tthis._smoothing = options.smoothing;\n\t}\n\n\tstatic getDefaults(): FollowerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.05,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of time it takes a value change to arrive at the updated value.\n\t */\n\tget smoothing(): Time {\n\t\treturn this._smoothing;\n\t}\n\tset smoothing(smoothing) {\n\t\tthis._smoothing = smoothing;\n\t\tthis._lowpass.frequency = 1 / this.toSeconds(this.smoothing);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect.js\";\nimport { Filter } from \"../component/filter/Filter.js\";\nimport { Follower } from \"../component/analysis/Follower.js\";\nimport {\n\tDecibels,\n\tFrequency,\n\tGainFactor,\n\tHertz,\n\tPositive,\n\tTime,\n} from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { dbToGain, gainToDb } from \"../core/type/Conversions.js\";\nimport { ScaleExp } from \"../signal/ScaleExp.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface AutoWahOptions extends EffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tsensitivity: Decibels;\n\tQ: Positive;\n\tgain: GainFactor;\n\tfollower: Time;\n}\n\n/**\n * AutoWah connects a {@link Follower} to a {@link Filter}.\n * The frequency of the filter, follows the input amplitude curve.\n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n *\n * @example\n * const autoWah = new Tone.AutoWah(50, 6, -30).toDestination();\n * // initialize the synth and connect to autowah\n * const synth = new Tone.Synth().connect(autoWah);\n * // Q value influences the effect of the wah - default is 2\n * autoWah.Q.value = 6;\n * // more audible on higher notes\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Effect\n */\nexport class AutoWah extends Effect<AutoWahOptions> {\n\treadonly name: string = \"AutoWah\";\n\n\t/**\n\t * The envelope follower. Set the attack/release\n\t * timing to adjust how the envelope is followed.\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * scales the follower value to the frequency domain\n\t */\n\tprivate _sweepRange: ScaleExp;\n\n\t/**\n\t * Hold the base frequency value\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * Private holder for the octave count\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * the input gain to adjust the sensitivity\n\t */\n\tprivate _inputBoost: Gain;\n\n\t/**\n\t * Private holder for the filter\n\t */\n\tprivate _bandpass: Filter;\n\n\t/**\n\t * The peaking fitler\n\t */\n\tprivate _peaking: Filter;\n\n\t/**\n\t * The gain of the filter.\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * The quality of the filter.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param baseFrequency The frequency the filter is set to at the low point of the wah\n\t * @param octaves The number of octaves above the baseFrequency the filter will sweep to when fully open.\n\t * @param sensitivity The decibel threshold sensitivity for the incoming signal. Normal range of -40 to 0.\n\t */\n\tconstructor(\n\t\tbaseFrequency?: Frequency,\n\t\toctaves?: Positive,\n\t\tsensitivity?: Decibels\n\t);\n\tconstructor(options?: Partial<AutoWahOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(AutoWah.getDefaults(), arguments, [\n\t\t\t\"baseFrequency\",\n\t\t\t\"octaves\",\n\t\t\t\"sensitivity\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.follower,\n\t\t});\n\t\tthis._sweepRange = new ScaleExp({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\texponent: 0.5,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis._inputBoost = new Gain({ context: this.context });\n\t\tthis._bandpass = new Filter({\n\t\t\tcontext: this.context,\n\t\t\trolloff: -48,\n\t\t\tfrequency: 0,\n\t\t\tQ: options.Q,\n\t\t});\n\t\tthis._peaking = new Filter({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"peaking\",\n\t\t});\n\t\tthis._peaking.gain.value = options.gain;\n\t\tthis.gain = this._peaking.gain;\n\t\tthis.Q = this._bandpass.Q;\n\n\t\t// the control signal path\n\t\tthis.effectSend.chain(\n\t\t\tthis._inputBoost,\n\t\t\tthis._follower,\n\t\t\tthis._sweepRange\n\t\t);\n\t\tthis._sweepRange.connect(this._bandpass.frequency);\n\t\tthis._sweepRange.connect(this._peaking.frequency);\n\t\t// the filtered path\n\t\tthis.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);\n\t\t// set the initial value\n\t\tthis._setSweepRange();\n\t\tthis.sensitivity = options.sensitivity;\n\n\t\treadOnly(this, [\"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): AutoWahOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbaseFrequency: 100,\n\t\t\toctaves: 6,\n\t\t\tsensitivity: 0,\n\t\t\tQ: 2,\n\t\t\tgain: 2,\n\t\t\tfollower: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * The number of octaves that the filter will sweep above the baseFrequency.\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The follower's smoothing time\n\t */\n\tget follower(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset follower(follower) {\n\t\tthis._follower.smoothing = follower;\n\t}\n\n\t/**\n\t * The base frequency from which the sweep will start from.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(baseFreq) {\n\t\tthis._baseFrequency = this.toFrequency(baseFreq);\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The sensitivity to control how responsive to the input signal the filter is.\n\t */\n\tget sensitivity(): Decibels {\n\t\treturn gainToDb(1 / this._inputBoost.gain.value);\n\t}\n\tset sensitivity(sensitivity) {\n\t\tthis._inputBoost.gain.value = 1 / dbToGain(sensitivity);\n\t}\n\n\t/**\n\t * sets the sweep range of the scaler\n\t */\n\tprivate _setSweepRange() {\n\t\tthis._sweepRange.min = this._baseFrequency;\n\t\tthis._sweepRange.max = Math.min(\n\t\t\tthis._baseFrequency * Math.pow(2, this._octaves),\n\t\t\tthis.context.sampleRate / 2\n\t\t);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._sweepRange.dispose();\n\t\tthis._bandpass.dispose();\n\t\tthis._peaking.dispose();\n\t\tthis._inputBoost.dispose();\n\t\treturn this;\n\t}\n}\n","import \"../core/worklet/SingleIOProcessor.worklet.js\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope.js\";\n\nexport const workletName = \"bit-crusher\";\n\nexport const bitCrusherWorklet = /* javascript */ `\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n`;\n\nregisterProcessor(workletName, bitCrusherWorklet);\n","import {\n\tToneAudioWorklet,\n\tToneAudioWorkletOptions,\n} from \"../core/worklet/ToneAudioWorklet.js\";\nimport { Effect, EffectOptions } from \"./Effect.js\";\nimport { Positive } from \"../core/type/Units.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { connectSeries } from \"../core/context/ToneAudioNode.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { workletName } from \"./BitCrusher.worklet.js\";\n\nexport interface BitCrusherOptions extends EffectOptions {\n\tbits: Positive;\n}\n\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n *\n * @category Effect\n */\nexport class BitCrusher extends Effect<BitCrusherOptions> {\n\treadonly name: string = \"BitCrusher\";\n\n\t/**\n\t * The bit depth of the effect\n\t * @min 1\n\t * @max 16\n\t */\n\treadonly bits: Param<\"positive\">;\n\n\t/**\n\t * The node which does the bit crushing effect. Runs in an AudioWorklet when possible.\n\t */\n\tprivate _bitCrusherWorklet: BitCrusherWorklet;\n\n\tconstructor(bits?: Positive);\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tBitCrusher.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"bits\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._bitCrusherWorklet = new BitCrusherWorklet({\n\t\t\tcontext: this.context,\n\t\t\tbits: options.bits,\n\t\t});\n\t\t// connect it up\n\t\tthis.connectEffect(this._bitCrusherWorklet);\n\n\t\tthis.bits = this._bitCrusherWorklet.bits;\n\t}\n\n\tstatic getDefaults(): BitCrusherOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbits: 4,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._bitCrusherWorklet.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface BitCrusherWorkletOptions extends ToneAudioWorkletOptions {\n\tbits: number;\n}\n\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nclass BitCrusherWorklet extends ToneAudioWorklet<BitCrusherWorkletOptions> {\n\treadonly name: string = \"BitCrusherWorklet\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\treadonly bits: Param<\"positive\">;\n\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tBitCrusherWorklet.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.bits = new Param<\"positive\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.bits,\n\t\t\tunits: \"positive\",\n\t\t\tminValue: 1,\n\t\t\tmaxValue: 16,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\t}\n\n\tstatic getDefaults(): BitCrusherWorkletOptions {\n\t\treturn Object.assign(ToneAudioWorklet.getDefaults(), {\n\t\t\tbits: 12,\n\t\t});\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst bits = node.parameters.get(\"bits\") as AudioParam;\n\t\tthis.bits.setParam(bits);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.bits.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect.js\";\nimport { Positive } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { WaveShaper } from \"../signal/WaveShaper.js\";\nimport { assert } from \"../core/util/Debug.js\";\n\nexport interface ChebyshevOptions extends EffectOptions {\n\torder: Positive;\n\toversample: OverSampleType;\n}\n\n/**\n * Chebyshev is a waveshaper which is good\n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones,\n * and order = 1 is no change.\n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect<ChebyshevOptions> {\n\treadonly name: string = \"Chebyshev\";\n\n\t/**\n\t * The private waveshaper node\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * holds onto the order of the filter\n\t */\n\tprivate _order: number;\n\n\t/**\n\t * @param order The order of the chebyshev polynomial. Normal range between 1-100.\n\t */\n\tconstructor(order?: Positive);\n\tconstructor(options?: Partial<ChebyshevOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tChebyshev.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"order\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\t\tthis._order = options.order;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.order = options.order;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): ChebyshevOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\torder: 1,\n\t\t\toversample: \"none\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * get the coefficient for that degree\n\t * @param  x the x value\n\t * @param  degree\n\t * @param  memo memoize the computed value. this speeds up computation greatly.\n\t */\n\tprivate _getCoefficient(\n\t\tx: number,\n\t\tdegree: number,\n\t\tmemo: Map<number, number>\n\t): number {\n\t\tif (memo.has(degree)) {\n\t\t\treturn memo.get(degree) as number;\n\t\t} else if (degree === 0) {\n\t\t\tmemo.set(degree, 0);\n\t\t} else if (degree === 1) {\n\t\t\tmemo.set(degree, x);\n\t\t} else {\n\t\t\tmemo.set(\n\t\t\t\tdegree,\n\t\t\t\t2 * x * this._getCoefficient(x, degree - 1, memo) -\n\t\t\t\t\tthis._getCoefficient(x, degree - 2, memo)\n\t\t\t);\n\t\t}\n\t\treturn memo.get(degree) as number;\n\t}\n\n\t/**\n\t * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming\n\t * signal through a Tone.WaveShaper. Must be an integer. The equations are in the form:\n\t * ```\n\t * order 2: 2x^2 + 1\n\t * order 3: 4x^3 + 3x\n\t * ```\n\t * @min 1\n\t * @max 100\n\t */\n\tget order(): Positive {\n\t\treturn this._order;\n\t}\n\tset order(order) {\n\t\tassert(Number.isInteger(order), \"'order' must be an integer\");\n\t\tthis._order = order;\n\t\tthis._shaper.setMap((x) => {\n\t\t\treturn this._getCoefficient(x, order, new Map());\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n\ninterface SplitOptions extends ToneAudioNodeOptions {\n\tchannels: number;\n}\n\n/**\n * Split splits an incoming signal into the number of given channels.\n *\n * @example\n * const split = new Tone.Split();\n * // stereoSignal.connect(split);\n * @category Component\n */\nexport class Split extends ToneAudioNode<SplitOptions> {\n\treadonly name: string = \"Split\";\n\n\t/**\n\t * The splitting node\n\t */\n\tprivate _splitter: ChannelSplitterNode;\n\n\treadonly input: ChannelSplitterNode;\n\treadonly output: ChannelSplitterNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: number);\n\tconstructor(options?: Partial<SplitOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Split.getDefaults(), arguments, [\n\t\t\t\"channels\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._splitter =\n\t\t\tthis.input =\n\t\t\tthis.output =\n\t\t\t\tthis.context.createChannelSplitter(options.channels);\n\t\tthis._internalChannels = [this._splitter];\n\t}\n\n\tstatic getDefaults(): SplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.disconnect();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Positive } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * const merge = new Tone.Merge().toDestination();\n * // routing a sine tone in the left channel\n * const osc = new Tone.Oscillator().connect(merge, 0, 0).start();\n * // and noise in the right channel\n * const noise = new Tone.Noise().connect(merge, 0, 1).start();;\n * @category Component\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\treadonly name: string = \"Merge\";\n\n\t/**\n\t * The merger node for the channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a single (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: Positive);\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\n\t\t\t\"channels\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._merger =\n\t\t\tthis.output =\n\t\t\tthis.input =\n\t\t\t\tthis.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n","import { EffectOptions } from \"./Effect.js\";\nimport {\n\tconnect,\n\tconnectSeries,\n\tOutputNode,\n\tToneAudioNode,\n} from \"../core/context/ToneAudioNode.js\";\nimport { CrossFade } from \"../component/channel/CrossFade.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { Split } from \"../component/channel/Split.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Merge } from \"../component/channel/Merge.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport type StereoEffectOptions = EffectOptions;\n\n/**\n * Base class for Stereo effects.\n */\nexport class StereoEffect<\n\tOptions extends StereoEffectOptions,\n> extends ToneAudioNode<Options> {\n\treadonly name: string = \"StereoEffect\";\n\n\treadonly input: Gain;\n\treadonly output: CrossFade;\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade;\n\n\t/**\n\t * The wet control, i.e. how much of the effected\n\t * will pass through to the output.\n\t */\n\treadonly wet: Signal<\"normalRange\">;\n\n\t/**\n\t * Split it\n\t */\n\tprotected _split: Split;\n\n\t/**\n\t * the stereo effect merger\n\t */\n\tprotected _merge: Merge;\n\n\tconstructor(options: StereoEffectOptions) {\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\t// force mono sources to be stereo\n\t\tthis.input.channelCount = 2;\n\t\tthis.input.channelCountMode = \"explicit\";\n\n\t\tthis._dryWet = this.output = new CrossFade({\n\t\t\tcontext: this.context,\n\t\t\tfade: options.wet,\n\t\t});\n\t\tthis.wet = this._dryWet.fade;\n\t\tthis._split = new Split({ context: this.context, channels: 2 });\n\t\tthis._merge = new Merge({ context: this.context, channels: 2 });\n\n\t\t// connections\n\t\tthis.input.connect(this._split);\n\t\t// dry wet connections\n\t\tthis.input.connect(this._dryWet.a);\n\t\tthis._merge.connect(this._dryWet.b);\n\t\treadOnly(this, [\"wet\"]);\n\t}\n\n\t/**\n\t * Connect the left part of the effect\n\t */\n\tprotected connectEffectLeft(...nodes: OutputNode[]): void {\n\t\tthis._split.connect(nodes[0], 0, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length - 1], this._merge, 0, 0);\n\t}\n\n\t/**\n\t * Connect the right part of the effect\n\t */\n\tprotected connectEffectRight(...nodes: OutputNode[]): void {\n\t\tthis._split.connect(nodes[0], 1, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length - 1], this._merge, 0, 1);\n\t}\n\n\tstatic getDefaults(): StereoEffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis._split.dispose();\n\t\tthis._merge.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect.js\";\nimport { NormalRange } from \"../core/type/Units.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Split } from \"../component/channel/Split.js\";\nimport { Merge } from \"../component/channel/Merge.js\";\n\nexport interface StereoFeedbackEffectOptions extends StereoEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Base class for stereo feedback effects where the effectReturn is fed back into the same channel.\n */\nexport class StereoFeedbackEffect<\n\tOptions extends StereoFeedbackEffectOptions,\n> extends StereoEffect<Options> {\n\t/**\n\t * The amount of feedback from the output\n\t * back into the input of the effect (routed\n\t * across left and right channels).\n\t */\n\treadonly feedback: Signal<\"normalRange\">;\n\n\t/**\n\t * the left side feedback\n\t */\n\tprotected _feedbackL: Gain;\n\n\t/**\n\t * the right side feedback\n\t */\n\tprotected _feedbackR: Gain;\n\n\t/**\n\t * Split the channels for feedback\n\t */\n\tprotected _feedbackSplit: Split;\n\n\t/**\n\t * Merge the channels for feedback\n\t */\n\tprotected _feedbackMerge: Merge;\n\n\tconstructor(options: StereoFeedbackEffectOptions) {\n\t\tsuper(options);\n\n\t\tthis.feedback = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis._feedbackL = new Gain({ context: this.context });\n\t\tthis._feedbackR = new Gain({ context: this.context });\n\n\t\tthis._feedbackSplit = new Split({ context: this.context, channels: 2 });\n\t\tthis._feedbackMerge = new Merge({ context: this.context, channels: 2 });\n\n\t\tthis._merge.connect(this._feedbackSplit);\n\t\tthis._feedbackMerge.connect(this._split);\n\n\t\t// the left output connected to the left input\n\t\tthis._feedbackSplit.connect(this._feedbackL, 0, 0);\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 0);\n\n\t\t// the right output connected to the right input\n\t\tthis._feedbackSplit.connect(this._feedbackR, 1, 0);\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 1);\n\n\t\t// the feedback control\n\t\tthis.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n\n\tstatic getDefaults(): StereoFeedbackEffectOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfeedback: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.feedback.dispose();\n\t\tthis._feedbackL.dispose();\n\t\tthis._feedbackR.dispose();\n\t\tthis._feedbackSplit.dispose();\n\t\tthis._feedbackMerge.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tStereoFeedbackEffect,\n\tStereoFeedbackEffectOptions,\n} from \"../effect/StereoFeedbackEffect.js\";\nimport {\n\tDegrees,\n\tFrequency,\n\tMilliseconds,\n\tNormalRange,\n\tSeconds,\n\tTime,\n} from \"../core/type/Units.js\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { Delay } from \"../core/context/Delay.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface ChorusOptions extends StereoFeedbackEffectOptions {\n\tfrequency: Frequency;\n\tdelayTime: Milliseconds;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n\tspread: Degrees;\n}\n\n/**\n * Chorus is a stereo chorus effect composed of a left and right delay with an {@link LFO} applied to the delayTime of each channel.\n * When {@link feedback} is set to a value larger than 0, you also get Flanger-type effects.\n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n * Read more on the chorus effect on [Sound On Sound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n *\n * @example\n * const chorus = new Tone.Chorus(4, 2.5, 0.5).toDestination().start();\n * const synth = new Tone.PolySynth().connect(chorus);\n * synth.triggerAttackRelease([\"C3\", \"E3\", \"G3\"], \"8n\");\n *\n * @category Effect\n */\nexport class Chorus extends StereoFeedbackEffect<ChorusOptions> {\n\treadonly name: string = \"Chorus\";\n\n\t/**\n\t * the depth of the chorus\n\t */\n\tprivate _depth: NormalRange;\n\n\t/**\n\t * the delayTime in seconds.\n\t */\n\tprivate _delayTime: Seconds;\n\n\t/**\n\t * the lfo which controls the delayTime\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * another LFO for the right side with a 180 degree phase diff\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * delay for left\n\t */\n\tprivate _delayNodeL: Delay;\n\n\t/**\n\t * delay for right\n\t */\n\tprivate _delayNodeR: Delay;\n\n\t/**\n\t * The frequency of the LFO which modulates the delayTime.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the LFO.\n\t * @param delayTime The delay of the chorus effect in ms.\n\t * @param depth The depth of the chorus.\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\tdelayTime?: Milliseconds,\n\t\tdepth?: NormalRange\n\t);\n\tconstructor(options?: Partial<ChorusOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Chorus.getDefaults(), arguments, [\n\t\t\t\"frequency\",\n\t\t\t\"delayTime\",\n\t\t\t\"depth\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._depth = options.depth;\n\t\tthis._delayTime = options.delayTime / 1000;\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180,\n\t\t});\n\t\tthis._delayNodeL = new Delay({ context: this.context });\n\t\tthis._delayNodeR = new Delay({ context: this.context });\n\t\tthis.frequency = this._lfoL.frequency;\n\t\treadOnly(this, [\"frequency\"]);\n\t\t// have one LFO frequency control the other\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\n\t\t// connections\n\t\tthis.connectEffectLeft(this._delayNodeL);\n\t\tthis.connectEffectRight(this._delayNodeR);\n\t\t// lfo setup\n\t\tthis._lfoL.connect(this._delayNodeL.delayTime);\n\t\tthis._lfoR.connect(this._delayNodeR.delayTime);\n\t\t// set the initial values\n\t\tthis.depth = this._depth;\n\t\tthis.type = options.type;\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): ChorusOptions {\n\t\treturn Object.assign(StereoFeedbackEffect.getDefaults(), {\n\t\t\tfrequency: 1.5,\n\t\t\tdelayTime: 3.5,\n\t\t\tdepth: 0.7,\n\t\t\ttype: \"sine\" as const,\n\t\t\tspread: 180,\n\t\t\tfeedback: 0,\n\t\t\twet: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * The depth of the effect. A depth of 1 makes the delayTime\n\t * modulate between 0 and 2*delayTime (centered around the delayTime).\n\t */\n\tget depth(): NormalRange {\n\t\treturn this._depth;\n\t}\n\tset depth(depth) {\n\t\tthis._depth = depth;\n\t\tconst deviation = this._delayTime * depth;\n\t\tthis._lfoL.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoL.max = this._delayTime + deviation;\n\t\tthis._lfoR.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoR.max = this._delayTime + deviation;\n\t}\n\n\t/**\n\t * The delayTime in milliseconds of the chorus. A larger delayTime\n\t * will give a more pronounced effect. Nominal range a delayTime\n\t * is between 2 and 20ms.\n\t */\n\tget delayTime(): Milliseconds {\n\t\treturn this._delayTime * 1000;\n\t}\n\tset delayTime(delayTime) {\n\t\tthis._delayTime = delayTime / 1000;\n\t\tthis.depth = this._depth;\n\t}\n\n\t/**\n\t * The oscillator type of the LFO.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase;\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - spread / 2;\n\t\tthis._lfoR.phase = spread / 2 + 90;\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport.\n\t * @see {@link LFO.sync}\n\t */\n\tsync(): this {\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._delayNodeL.dispose();\n\t\tthis._delayNodeR.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { WaveShaper } from \"../signal/WaveShaper.js\";\nimport { Effect, EffectOptions } from \"./Effect.js\";\n\nexport interface DistortionOptions extends EffectOptions {\n\tdistortion: number;\n\toversample: OverSampleType;\n}\n\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n * Read more about distortion on [Wikipedia](https://en.wikipedia.org/wiki/Distortion_(music).\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport class Distortion extends Effect<DistortionOptions> {\n\treadonly name: string = \"Distortion\";\n\n\t/**\n\t * The waveshaper which does the distortion\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * Stores the distortion value\n\t */\n\tprivate _distortion: number;\n\n\t/**\n\t * @param distortion The amount of distortion (nominal range of 0-1)\n\t */\n\tconstructor(distortion?: number);\n\tconstructor(options?: Partial<DistortionOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tDistortion.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"distortion\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\n\t\tthis._distortion = options.distortion;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.distortion = options.distortion;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): DistortionOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdistortion: 0.4,\n\t\t\toversample: \"none\" as OverSampleType,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of distortion. Nominal range is between 0 and 1.\n\t */\n\tget distortion(): number {\n\t\treturn this._distortion;\n\t}\n\tset distortion(amount) {\n\t\tthis._distortion = amount;\n\t\tconst k = amount * 100;\n\t\tconst deg = Math.PI / 180;\n\t\tthis._shaper.setMap((x) => {\n\t\t\tif (Math.abs(x) < 0.001) {\n\t\t\t\t// should output 0 when input is 0\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn ((3 + k) * x * 20 * deg) / (Math.PI + k * Math.abs(x));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { NormalRange } from \"../core/type/Units.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Effect, EffectOptions } from \"./Effect.js\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n *\n * NOTE: Feedback effects require at least one DelayNode to be in the feedback cycle.\n */\nexport abstract class FeedbackEffect<\n\tOptions extends FeedbackEffectOptions,\n> extends Effect<Options> {\n\treadonly name: string = \"FeedbackEffect\";\n\n\t/**\n\t * the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<\"normalRange\">;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n","import { Delay } from \"../core/context/Delay.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { NormalRange, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect.js\";\n\nexport interface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new Tone.MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\treadonly name: string = \"FeedbackDelay\";\n\n\t/**\n\t * the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t * The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFeedbackDelay.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"delayTime\", \"feedback\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tconnectSeries,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90.\n * Here the `offset90` phase is offset by +90 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [\n\t\t\t0.6923878, 0.9360654322959, 0.988229522686, 0.9987488452737,\n\t\t];\n\t\tconst allpassBank2Values = [\n\t\t\t0.4021921162426, 0.856171088242, 0.9722909545651, 0.9952884791278,\n\t\t];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter(\n\t\t\t[0.0, 1.0],\n\t\t\t[1.0, 0.0]\n\t\t);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(\n\t\t\tthis.input,\n\t\t\t...this._bank0,\n\t\t\tthis._oneSampleDelay,\n\t\t\tthis.output\n\t\t);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map((value) => {\n\t\t\tconst coefficients = [\n\t\t\t\t[value * value, 0, -1],\n\t\t\t\t[1, 0, -(value * value)],\n\t\t\t];\n\t\t\treturn this.context.createIIRFilter(\n\t\t\t\tcoefficients[0],\n\t\t\t\tcoefficients[1]\n\t\t\t);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach((f) => f.disconnect());\n\t\tthis._bank1.forEach((f) => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n","import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass.js\";\nimport { Frequency } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Effect, EffectOptions } from \"../effect/Effect.js\";\nimport { Add } from \"../signal/Add.js\";\nimport { Multiply } from \"../signal/Multiply.js\";\nimport { Negate } from \"../signal/Negate.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { Oscillator } from \"../source/oscillator/Oscillator.js\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode.js\";\n\nexport interface FrequencyShifterOptions extends EffectOptions {\n\tfrequency: Frequency;\n}\n\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport class FrequencyShifter extends Effect<FrequencyShifterOptions> {\n\treadonly name: string = \"FrequencyShifter\";\n\n\t/**\n\t * The ring modulators carrier frequency. This frequency determines\n\t * by how many Hertz the input signal will be shifted up or down. Default is 0.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The ring modulators sine carrier\n\t */\n\tprivate _sine: ToneOscillatorNode;\n\n\t/**\n\t * The ring modulators cosine carrier\n\t */\n\tprivate _cosine: Oscillator;\n\n\t/**\n\t * The sine multiply operator\n\t */\n\tprivate _sineMultiply: Multiply;\n\n\t/**\n\t * The cosine multiply operator\n\t */\n\tprivate _cosineMultiply: Multiply;\n\n\t/**\n\t * The negate operator\n\t */\n\tprivate _negate: Negate;\n\n\t/**\n\t * The final add operator\n\t */\n\tprivate _add: Add;\n\n\t/**\n\t * The phase shifter to create the initial 90 phase offset\n\t */\n\tprivate _phaseShifter: PhaseShiftAllpass;\n\n\t/**\n\t * @param frequency The incoming signal is shifted by this frequency value.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<FrequencyShifterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFrequencyShifter.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"frequency\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tminValue: -this.context.sampleRate / 2,\n\t\t\tmaxValue: this.context.sampleRate / 2,\n\t\t});\n\n\t\tthis._sine = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._cosine = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: -90,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._sineMultiply = new Multiply({ context: this.context });\n\t\tthis._cosineMultiply = new Multiply({ context: this.context });\n\t\tthis._negate = new Negate({ context: this.context });\n\t\tthis._add = new Add({ context: this.context });\n\n\t\tthis._phaseShifter = new PhaseShiftAllpass({ context: this.context });\n\t\tthis.effectSend.connect(this._phaseShifter);\n\n\t\t// connect the carrier frequency signal to the two oscillators\n\t\tthis.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n\t\tthis._phaseShifter.offset90.connect(this._cosineMultiply);\n\t\tthis._cosine.connect(this._cosineMultiply.factor);\n\n\t\tthis._phaseShifter.connect(this._sineMultiply);\n\t\tthis._sine.connect(this._sineMultiply.factor);\n\t\tthis._sineMultiply.connect(this._negate);\n\n\t\tthis._cosineMultiply.connect(this._add);\n\t\tthis._negate.connect(this._add.addend);\n\n\t\tthis._add.connect(this.effectReturn);\n\n\t\t// start the oscillators at the same time\n\t\tconst now = this.immediate();\n\t\tthis._sine.start(now);\n\t\tthis._cosine.start(now);\n\t}\n\n\tstatic getDefaults(): FrequencyShifterOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._add.dispose();\n\t\tthis._cosine.dispose();\n\t\tthis._cosineMultiply.dispose();\n\t\tthis._negate.dispose();\n\t\tthis._phaseShifter.dispose();\n\t\tthis._sine.dispose();\n\t\tthis._sineMultiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect.js\";\nimport { Frequency, NormalRange } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter.js\";\n\nexport interface FreeverbOptions extends StereoEffectOptions {\n\tdampening: Frequency;\n\troomSize: NormalRange;\n}\n\n/**\n * An array of comb filter delay values from Freeverb implementation\n */\nconst combFilterTunings = [\n\t1557 / 44100,\n\t1617 / 44100,\n\t1491 / 44100,\n\t1422 / 44100,\n\t1277 / 44100,\n\t1356 / 44100,\n\t1188 / 44100,\n\t1116 / 44100,\n];\n\n/**\n * An array of allpass filter frequency values from Freeverb implementation\n */\nconst allpassFilterFrequencies = [225, 556, 441, 341];\n\n/**\n * Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n * Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).\n * Freeverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using {@link Reverb}.\n * @example\n * const freeverb = new Tone.Freeverb().toDestination();\n * freeverb.dampening = 1000;\n * // routing synth through the reverb\n * const synth = new Tone.NoiseSynth().connect(freeverb);\n * synth.triggerAttackRelease(0.05);\n * @category Effect\n */\nexport class Freeverb extends StereoEffect<FreeverbOptions> {\n\treadonly name: string = \"Freeverb\";\n\n\t/**\n\t * The roomSize value between 0 and 1. A larger roomSize will result in a longer decay.\n\t */\n\treadonly roomSize: Signal<\"normalRange\">;\n\n\t/**\n\t * the comb filters\n\t */\n\tprivate _combFilters: LowpassCombFilter[] = [];\n\n\t/**\n\t * the allpass filters on the left\n\t */\n\tprivate _allpassFiltersL: BiquadFilterNode[] = [];\n\n\t/**\n\t * the allpass filters on the right\n\t */\n\tprivate _allpassFiltersR: BiquadFilterNode[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t * @param dampening The cutoff frequency of a lowpass filter as part of the reverb.\n\t */\n\tconstructor(roomSize?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: Partial<FreeverbOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tFreeverb.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"roomSize\", \"dampening\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\t// make the allpass filters on the right\n\t\tthis._allpassFiltersL = allpassFilterFrequencies.map((freq) => {\n\t\t\tconst allpassL = this.context.createBiquadFilter();\n\t\t\tallpassL.type = \"allpass\";\n\t\t\tallpassL.frequency.value = freq;\n\t\t\treturn allpassL;\n\t\t});\n\n\t\t// make the allpass filters on the left\n\t\tthis._allpassFiltersR = allpassFilterFrequencies.map((freq) => {\n\t\t\tconst allpassR = this.context.createBiquadFilter();\n\t\t\tallpassR.type = \"allpass\";\n\t\t\tallpassR.frequency.value = freq;\n\t\t\treturn allpassR;\n\t\t});\n\n\t\t// make the comb filters\n\t\tthis._combFilters = combFilterTunings.map((delayTime, index) => {\n\t\t\tconst lfpf = new LowpassCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdampening: options.dampening,\n\t\t\t\tdelayTime,\n\t\t\t});\n\t\t\tif (index < combFilterTunings.length / 2) {\n\t\t\t\tthis.connectEffectLeft(lfpf, ...this._allpassFiltersL);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(lfpf, ...this._allpassFiltersR);\n\t\t\t}\n\t\t\tthis.roomSize.connect(lfpf.resonance);\n\t\t\treturn lfpf;\n\t\t});\n\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): FreeverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.7,\n\t\t\tdampening: 3000,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of dampening of the reverberant signal.\n\t */\n\n\tget dampening(): Frequency {\n\t\treturn this._combFilters[0].dampening;\n\t}\n\tset dampening(d) {\n\t\tthis._combFilters.forEach((c) => (c.dampening = d));\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFiltersL.forEach((al) => al.disconnect());\n\t\tthis._allpassFiltersR.forEach((ar) => ar.disconnect());\n\t\tthis._combFilters.forEach((cf) => cf.dispose());\n\t\tthis.roomSize.dispose();\n\t\treturn this;\n\t}\n}\n","import { NormalRange } from \"../core/type/Units.js\";\nimport { StereoEffect, StereoEffectOptions } from \"./StereoEffect.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Scale } from \"../signal/Scale.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { FeedbackCombFilter } from \"../component/filter/FeedbackCombFilter.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface JCReverbOptions extends StereoEffectOptions {\n\troomSize: NormalRange;\n}\n\n/**\n * an array of the comb filter delay time values\n */\nconst combFilterDelayTimes = [\n\t1687 / 25000,\n\t1601 / 25000,\n\t2053 / 25000,\n\t2251 / 25000,\n];\n\n/**\n * the resonances of each of the comb filters\n */\nconst combFilterResonances = [0.773, 0.802, 0.753, 0.733];\n\n/**\n * the allpass filter frequencies\n */\nconst allpassFilterFreqs = [347, 113, 37];\n\n/**\n * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n * tuned by John Chowning in 1970.\n * It is made up of three allpass filters and four {@link FeedbackCombFilter}.\n * JCReverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using {@link Reverb}.\n * @example\n * const reverb = new Tone.JCReverb(0.4).toDestination();\n * const delay = new Tone.FeedbackDelay(0.5);\n * // connecting the synth to reverb through delay\n * const synth = new Tone.DuoSynth().chain(delay, reverb);\n * synth.triggerAttackRelease(\"A4\", \"8n\");\n *\n * @category Effect\n */\nexport class JCReverb extends StereoEffect<JCReverbOptions> {\n\treadonly name: string = \"JCReverb\";\n\n\t/**\n\t * Room size control values.\n\t */\n\treadonly roomSize: Signal<\"normalRange\">;\n\n\t/**\n\t * Scale the room size\n\t */\n\tprivate _scaleRoomSize: Scale;\n\n\t/**\n\t * a series of allpass filters\n\t */\n\tprivate _allpassFilters: BiquadFilterNode[] = [];\n\n\t/**\n\t * parallel feedback comb filters\n\t */\n\tprivate _feedbackCombFilters: FeedbackCombFilter[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t */\n\tconstructor(roomSize?: NormalRange);\n\tconstructor(options?: Partial<JCReverbOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tJCReverb.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"roomSize\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis._scaleRoomSize = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: -0.733,\n\t\t\tmax: 0.197,\n\t\t});\n\n\t\t// make the allpass filters\n\t\tthis._allpassFilters = allpassFilterFreqs.map((freq) => {\n\t\t\tconst allpass = this.context.createBiquadFilter();\n\t\t\tallpass.type = \"allpass\";\n\t\t\tallpass.frequency.value = freq;\n\t\t\treturn allpass;\n\t\t});\n\n\t\t// and the comb filters\n\t\tthis._feedbackCombFilters = combFilterDelayTimes.map(\n\t\t\t(delayTime, index) => {\n\t\t\t\tconst fbcf = new FeedbackCombFilter({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tdelayTime,\n\t\t\t\t});\n\t\t\t\tthis._scaleRoomSize.connect(fbcf.resonance);\n\t\t\t\tfbcf.resonance.value = combFilterResonances[index];\n\t\t\t\tif (index < combFilterDelayTimes.length / 2) {\n\t\t\t\t\tthis.connectEffectLeft(...this._allpassFilters, fbcf);\n\t\t\t\t} else {\n\t\t\t\t\tthis.connectEffectRight(...this._allpassFilters, fbcf);\n\t\t\t\t}\n\t\t\t\treturn fbcf;\n\t\t\t}\n\t\t);\n\n\t\t// chain the allpass filters together\n\t\tthis.roomSize.connect(this._scaleRoomSize);\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): JCReverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFilters.forEach((apf) => apf.disconnect());\n\t\tthis._feedbackCombFilters.forEach((fbcf) => fbcf.dispose());\n\t\tthis.roomSize.dispose();\n\t\tthis._scaleRoomSize.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tStereoFeedbackEffect,\n\tStereoFeedbackEffectOptions,\n} from \"./StereoFeedbackEffect.js\";\nimport { NormalRange } from \"../core/type/Units.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface StereoXFeedbackEffectOptions\n\textends StereoFeedbackEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Just like a {@link StereoFeedbackEffect}, but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +-----+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit     | |\n * +-->                          +----->        +---->                          +---+ |\n * |                                                                                  |\n * +--------------------------------+ feedbackR <-------------------------------------+\n * ```\n */\nexport class StereoXFeedbackEffect<\n\tOptions extends StereoXFeedbackEffectOptions,\n> extends StereoFeedbackEffect<Options> {\n\tconstructor(options: StereoXFeedbackEffectOptions) {\n\t\tsuper(options);\n\t\t// the left output connected to the right input\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 1);\n\n\t\t// the left output connected to the right input\n\t\tthis._feedbackR.disconnect();\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 0);\n\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n}\n","import {\n\tStereoXFeedbackEffect,\n\tStereoXFeedbackEffectOptions,\n} from \"./StereoXFeedbackEffect.js\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Delay } from \"../core/context/Delay.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface PingPongDelayOptions extends StereoXFeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Seconds;\n}\n\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new Tone.MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\nexport class PingPongDelay extends StereoXFeedbackEffect<PingPongDelayOptions> {\n\treadonly name: string = \"PingPongDelay\";\n\n\t/**\n\t * the delay node on the left side\n\t */\n\tprivate _leftDelay: Delay;\n\n\t/**\n\t * the delay node on the right side\n\t */\n\tprivate _rightDelay: Delay;\n\n\t/**\n\t * the predelay on the right side\n\t */\n\tprivate _rightPreDelay: Delay;\n\n\t/**\n\t * the delay time signal\n\t */\n\treadonly delayTime: Signal<\"time\">;\n\n\t/**\n\t * @param delayTime The delayTime between consecutive echos.\n\t * @param feedback The amount of the effected signal which is fed back through the delay.\n\t */\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<PingPongDelayOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPingPongDelay.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"delayTime\", \"feedback\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._leftDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightPreDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\t// connect it up\n\t\tthis.connectEffectLeft(this._leftDelay);\n\t\tthis.connectEffectRight(this._rightPreDelay, this._rightDelay);\n\t\tthis.delayTime.fan(\n\t\t\tthis._leftDelay.delayTime,\n\t\t\tthis._rightDelay.delayTime,\n\t\t\tthis._rightPreDelay.delayTime\n\t\t);\n\t\t// rearranged the feedback to be after the rightPreDelay\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._rightDelay);\n\t\treadOnly(this, [\"delayTime\"]);\n\t}\n\n\tstatic getDefaults(): PingPongDelayOptions {\n\t\treturn Object.assign(StereoXFeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._leftDelay.dispose();\n\t\tthis._rightDelay.dispose();\n\t\tthis._rightPreDelay.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Interval, Seconds, Time } from \"../core/type/Units.js\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { Delay } from \"../core/context/Delay.js\";\nimport { CrossFade } from \"../component/channel/CrossFade.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions.js\";\n\nexport interface PitchShiftOptions extends FeedbackEffectOptions {\n\tpitch: Interval;\n\twindowSize: Seconds;\n\tdelayTime: Time;\n}\n\n/**\n * PitchShift does near-realtime pitch shifting to the incoming signal.\n * The effect is achieved by speeding up or slowing down the delayTime\n * of a DelayNode using a sawtooth wave.\n * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n * @category Effect\n */\nexport class PitchShift extends FeedbackEffect<PitchShiftOptions> {\n\treadonly name: string = \"PitchShift\";\n\n\t/**\n\t * The pitch signal\n\t */\n\tprivate _frequency: Signal<\"frequency\">;\n\n\t/**\n\t * Uses two DelayNodes to cover up the jump in the sawtooth wave.\n\t */\n\tprivate _delayA: Delay;\n\n\t/**\n\t * The first LFO.\n\t */\n\tprivate _lfoA: LFO;\n\n\t/**\n\t * The second DelayNode\n\t */\n\tprivate _delayB: Delay;\n\n\t/**\n\t * The second LFO.\n\t */\n\tprivate _lfoB: LFO;\n\n\t/**\n\t * Cross fade quickly between the two delay lines to cover up the jump in the sawtooth wave\n\t */\n\tprivate _crossFade: CrossFade;\n\n\t/**\n\t * LFO which alternates between the two delay lines to cover up the disparity in the\n\t * sawtooth wave.\n\t */\n\tprivate _crossFadeLFO: LFO;\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _feedbackDelay: Delay;\n\n\t/**\n\t * The amount of delay on the input signal\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Hold the current pitch\n\t */\n\tprivate _pitch: Interval;\n\n\t/**\n\t * Hold the current windowSize\n\t */\n\tprivate _windowSize;\n\n\t/**\n\t * @param pitch The interval to transpose the incoming signal by.\n\t */\n\tconstructor(pitch?: Interval);\n\tconstructor(options?: Partial<PitchShiftOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPitchShift.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"pitch\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._frequency = new Signal({ context: this.context });\n\t\tthis._delayA = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._lfoA = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\",\n\t\t}).connect(this._delayA.delayTime);\n\t\tthis._delayB = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._lfoB = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\",\n\t\t\tphase: 180,\n\t\t}).connect(this._delayB.delayTime);\n\t\tthis._crossFade = new CrossFade({ context: this.context });\n\t\tthis._crossFadeLFO = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\ttype: \"triangle\",\n\t\t\tphase: 90,\n\t\t}).connect(this._crossFade.fade);\n\t\tthis._feedbackDelay = new Delay({\n\t\t\tdelayTime: options.delayTime,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis.delayTime = this._feedbackDelay.delayTime;\n\t\treadOnly(this, \"delayTime\");\n\t\tthis._pitch = options.pitch;\n\n\t\tthis._windowSize = options.windowSize;\n\n\t\t// connect the two delay lines up\n\t\tthis._delayA.connect(this._crossFade.a);\n\t\tthis._delayB.connect(this._crossFade.b);\n\t\t// connect the frequency\n\t\tthis._frequency.fan(\n\t\t\tthis._lfoA.frequency,\n\t\t\tthis._lfoB.frequency,\n\t\t\tthis._crossFadeLFO.frequency\n\t\t);\n\t\t// route the input\n\t\tthis.effectSend.fan(this._delayA, this._delayB);\n\t\tthis._crossFade.chain(this._feedbackDelay, this.effectReturn);\n\t\t// start the LFOs at the same time\n\t\tconst now = this.now();\n\t\tthis._lfoA.start(now);\n\t\tthis._lfoB.start(now);\n\t\tthis._crossFadeLFO.start(now);\n\t\t// set the initial value\n\t\tthis.windowSize = this._windowSize;\n\t}\n\n\tstatic getDefaults(): PitchShiftOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tpitch: 0,\n\t\t\twindowSize: 0.1,\n\t\t\tdelayTime: 0,\n\t\t\tfeedback: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Repitch the incoming signal by some interval (measured in semi-tones).\n\t * @example\n\t * const pitchShift = new Tone.PitchShift().toDestination();\n\t * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();\n\t * pitchShift.pitch = -12; // down one octave\n\t * pitchShift.pitch = 7; // up a fifth\n\t */\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset pitch(interval) {\n\t\tthis._pitch = interval;\n\t\tlet factor = 0;\n\t\tif (interval < 0) {\n\t\t\tthis._lfoA.min = 0;\n\t\t\tthis._lfoA.max = this._windowSize;\n\t\t\tthis._lfoB.min = 0;\n\t\t\tthis._lfoB.max = this._windowSize;\n\t\t\tfactor = intervalToFrequencyRatio(interval - 1) + 1;\n\t\t} else {\n\t\t\tthis._lfoA.min = this._windowSize;\n\t\t\tthis._lfoA.max = 0;\n\t\t\tthis._lfoB.min = this._windowSize;\n\t\t\tthis._lfoB.max = 0;\n\t\t\tfactor = intervalToFrequencyRatio(interval) - 1;\n\t\t}\n\t\tthis._frequency.value = factor * (1.2 / this._windowSize);\n\t}\n\n\t/**\n\t * The window size corresponds roughly to the sample length in a looping sampler.\n\t * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n\t * signal, but larger values will result in smoother pitch shifting for larger intervals.\n\t * A nominal range of 0.03 to 0.1 is recommended.\n\t */\n\tget windowSize(): Seconds {\n\t\treturn this._windowSize;\n\t}\n\tset windowSize(size) {\n\t\tthis._windowSize = this.toSeconds(size);\n\t\tthis.pitch = this._pitch;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._frequency.dispose();\n\t\tthis._delayA.dispose();\n\t\tthis._delayB.dispose();\n\t\tthis._lfoA.dispose();\n\t\tthis._lfoB.dispose();\n\t\tthis._crossFade.dispose();\n\t\tthis._crossFadeLFO.dispose();\n\t\tthis._feedbackDelay.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect.js\";\nimport { Frequency, Hertz, Positive } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface PhaserOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\toctaves: Positive;\n\tstages: Positive;\n\tQ: Positive;\n\tbaseFrequency: Frequency;\n}\n\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport class Phaser extends StereoEffect<PhaserOptions> {\n\treadonly name: string = \"Phaser\";\n\n\t/**\n\t * the lfo which controls the frequency on the left side\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * the lfo which controls the frequency on the right side\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * the base modulation frequency\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * the octaves of the phasing\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * The quality factor of the filters\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersL: BiquadFilterNode[];\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersR: BiquadFilterNode[];\n\n\t/**\n\t * the frequency of the effect\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The speed of the phasing.\n\t * @param octaves The octaves of the effect.\n\t * @param baseFrequency The base frequency of the filters.\n\t */\n\tconstructor(\n\t\tfrequency?: Frequency,\n\t\toctaves?: Positive,\n\t\tbaseFrequency?: Frequency\n\t);\n\tconstructor(options?: Partial<PhaserOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Phaser.getDefaults(), arguments, [\n\t\t\t\"frequency\",\n\t\t\t\"octaves\",\n\t\t\t\"baseFrequency\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.Q,\n\t\t\tunits: \"positive\",\n\t\t});\n\t\tthis._filtersL = this._makeFilters(options.stages, this._lfoL);\n\t\tthis._filtersR = this._makeFilters(options.stages, this._lfoR);\n\n\t\tthis.frequency = this._lfoL.frequency;\n\t\tthis.frequency.value = options.frequency;\n\n\t\t// connect them up\n\t\tthis.connectEffectLeft(...this._filtersL);\n\t\tthis.connectEffectRight(...this._filtersR);\n\t\t// control the frequency with one LFO\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\t\t// set the options\n\t\tthis.baseFrequency = options.baseFrequency;\n\t\tthis.octaves = options.octaves;\n\t\t// start the lfo\n\t\tthis._lfoL.start();\n\t\tthis._lfoR.start();\n\t\treadOnly(this, [\"frequency\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): PhaserOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 0.5,\n\t\t\toctaves: 3,\n\t\t\tstages: 10,\n\t\t\tQ: 10,\n\t\t\tbaseFrequency: 350,\n\t\t});\n\t}\n\n\tprivate _makeFilters(\n\t\tstages: number,\n\t\tconnectToFreq: LFO\n\t): BiquadFilterNode[] {\n\t\tconst filters: BiquadFilterNode[] = [];\n\t\t// make all the filters\n\t\tfor (let i = 0; i < stages; i++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = \"allpass\";\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tconnectToFreq.connect(filter.frequency);\n\t\t\tfilters.push(filter);\n\t\t}\n\t\treturn filters;\n\t}\n\n\t/**\n\t * The number of octaves the phase goes above the baseFrequency\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tconst max = this._baseFrequency * Math.pow(2, octaves);\n\t\tthis._lfoL.max = max;\n\t\tthis._lfoR.max = max;\n\t}\n\n\t/**\n\t * The the base frequency of the filters.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._baseFrequency = this.toFrequency(freq);\n\t\tthis._lfoL.min = this._baseFrequency;\n\t\tthis._lfoR.min = this._baseFrequency;\n\t\tthis.octaves = this._octaves;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.Q.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._filtersL.forEach((f) => f.disconnect());\n\t\tthis._filtersR.forEach((f) => f.disconnect());\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { Merge } from \"../component/channel/Merge.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Seconds, Time } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { Noise } from \"../source/Noise.js\";\nimport { Effect, EffectOptions } from \"./Effect.js\";\nimport { OfflineContext } from \"../core/context/OfflineContext.js\";\nimport { noOp } from \"../core/util/Interface.js\";\nimport { assertRange } from \"../core/util/Debug.js\";\n\nexport interface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until {@link ready} resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either {@link decay}\n\t * or {@link preDelay} are set, you have to wait until {@link ready} resolves\n\t * before the IR is generated with the latest values.\n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\n\t\t\t\"decay\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tconst decayTime = this.toSeconds(options.decay);\n\t\tassertRange(decayTime, 0.001);\n\t\tthis._decay = decayTime;\n\n\t\tconst preDelayTime = this.toSeconds(options.preDelay);\n\t\tassertRange(preDelayTime, 0);\n\t\tthis._preDelay = preDelayTime;\n\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(\n\t\t\t2,\n\t\t\tthis._decay + this._preDelay,\n\t\t\tthis.context.sampleRate\n\t\t);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(\n\t\t\t0,\n\t\t\tthis._preDelay,\n\t\t\tthis.decay\n\t\t);\n\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Split } from \"./Split.js\";\nimport { Add } from \"../../signal/Add.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Subtract } from \"../../signal/Subtract.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n\nexport type MidSideSplitOptions = ToneAudioNodeOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels).\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n * @category Component\n */\nexport class MidSideSplit extends ToneAudioNode<MidSideSplitOptions> {\n\treadonly name: string = \"MidSideSplit\";\n\n\treadonly input: Split;\n\n\t/**\n\t * There is no output node, use either {@link mid} or {@link side} outputs.\n\t */\n\treadonly output: undefined;\n\t/**\n\t * Split the incoming signal into left and right channels\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * Sums the left and right channels\n\t */\n\tprivate _midAdd: Add;\n\n\t/**\n\t * Subtract left and right channels.\n\t */\n\tprivate _sideSubtract: Subtract;\n\n\t/**\n\t * The \"mid\" output. `(Left+Right)/sqrt(2)`\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" output. `(Left-Right)/sqrt(2)`\n\t */\n\treadonly side: ToneAudioNode;\n\n\tconstructor(options?: Partial<MidSideSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideSplit.getDefaults(), arguments));\n\n\t\tthis._split = this.input = new Split({\n\t\t\tchannels: 2,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._midAdd = new Add({ context: this.context });\n\t\tthis.mid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\t\tthis._sideSubtract = new Subtract({ context: this.context });\n\t\tthis.side = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\n\t\tthis._split.connect(this._midAdd, 0);\n\t\tthis._split.connect(this._midAdd.addend, 1);\n\t\tthis._split.connect(this._sideSubtract, 0);\n\t\tthis._split.connect(this._sideSubtract.subtrahend, 1);\n\t\tthis._midAdd.connect(this.mid);\n\t\tthis._sideSubtract.connect(this.side);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midAdd.dispose();\n\t\tthis._sideSubtract.dispose();\n\t\tthis._split.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Merge } from \"./Merge.js\";\nimport { Add } from \"../../signal/Add.js\";\nimport { Multiply } from \"../../signal/Multiply.js\";\nimport { Subtract } from \"../../signal/Subtract.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n\nexport type MidSideMergeOptions = ToneAudioNodeOptions;\n\n/**\n * MidSideMerge merges the mid and side signal after they've been separated by {@link MidSideSplit}\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n * @category Component\n */\nexport class MidSideMerge extends ToneAudioNode<MidSideMergeOptions> {\n\treadonly name: string = \"MidSideMerge\";\n\n\t/**\n\t * There is no input, connect sources to either {@link mid} or {@link side} inputs.\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The merged signal\n\t */\n\treadonly output: Merge;\n\n\t/**\n\t * Merge the incoming signal into left and right channels\n\t */\n\tprivate _merge: Merge;\n\n\t/**\n\t * The \"mid\" input.\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" input.\n\t */\n\treadonly side: ToneAudioNode;\n\n\t/**\n\t * Recombine the mid/side into Left\n\t */\n\tprivate _left: Add;\n\n\t/**\n\t * Recombine the mid/side into Right\n\t */\n\tprivate _right: Subtract;\n\n\t/**\n\t * Multiply the right by sqrt(1/2)\n\t */\n\tprivate _leftMult: Multiply;\n\n\t/**\n\t * Multiply the left by sqrt(1/2)\n\t */\n\tprivate _rightMult: Multiply;\n\n\tconstructor(options?: Partial<MidSideMergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideMerge.getDefaults(), arguments));\n\t\tthis.mid = new Gain({ context: this.context });\n\t\tthis.side = new Gain({ context: this.context });\n\t\tthis._left = new Add({ context: this.context });\n\t\tthis._leftMult = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\t\tthis._right = new Subtract({ context: this.context });\n\t\tthis._rightMult = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\t\tthis._merge = this.output = new Merge({ context: this.context });\n\n\t\tthis.mid.fan(this._left);\n\t\tthis.side.connect(this._left.addend);\n\t\tthis.mid.connect(this._right);\n\t\tthis.side.connect(this._right.subtrahend);\n\t\tthis._left.connect(this._leftMult);\n\t\tthis._right.connect(this._rightMult);\n\t\tthis._leftMult.connect(this._merge, 0, 0);\n\t\tthis._rightMult.connect(this._merge, 0, 1);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._leftMult.dispose();\n\t\tthis._rightMult.dispose();\n\t\tthis._left.dispose();\n\t\tthis._right.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect.js\";\nimport { MidSideSplit } from \"../component/channel/MidSideSplit.js\";\nimport { MidSideMerge } from \"../component/channel/MidSideMerge.js\";\nimport { OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode.js\";\n\nexport type MidSideEffectOptions = EffectOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal\n * (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels)\n * and effects them separately before being recombined.\n * Applies a Mid/Side seperation and recombination.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * This is a base-class for Mid/Side Effects.\n * @category Effect\n */\nexport abstract class MidSideEffect<\n\tOptions extends MidSideEffectOptions,\n> extends Effect<Options> {\n\treadonly name: string = \"MidSideEffect\";\n\n\t/**\n\t * The mid/side split\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\n\t/**\n\t * The mid/side merge\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\n\t/**\n\t * The mid send. Connect to mid processing\n\t */\n\tprotected _midSend: ToneAudioNode;\n\n\t/**\n\t * The side send. Connect to side processing\n\t */\n\tprotected _sideSend: ToneAudioNode;\n\n\t/**\n\t * The mid return connection\n\t */\n\tprotected _midReturn: ToneAudioNode;\n\n\t/**\n\t * The side return connection\n\t */\n\tprotected _sideReturn: ToneAudioNode;\n\n\tconstructor(options: MidSideEffectOptions) {\n\t\tsuper(options);\n\n\t\tthis._midSideMerge = new MidSideMerge({ context: this.context });\n\t\tthis._midSideSplit = new MidSideSplit({ context: this.context });\n\t\tthis._midSend = this._midSideSplit.mid;\n\t\tthis._sideSend = this._midSideSplit.side;\n\t\tthis._midReturn = this._midSideMerge.mid;\n\t\tthis._sideReturn = this._midSideMerge.side;\n\n\t\t// the connections\n\t\tthis.effectSend.connect(this._midSideSplit);\n\t\tthis._midSideMerge.connect(this.effectReturn);\n\t}\n\n\t/**\n\t * Connect the mid chain of the effect\n\t */\n\tprotected connectEffectMid(...nodes: OutputNode[]): void {\n\t\tthis._midSend.chain(...nodes, this._midReturn);\n\t}\n\n\t/**\n\t * Connect the side chain of the effect\n\t */\n\tprotected connectEffectSide(...nodes: OutputNode[]): void {\n\t\tthis._sideSend.chain(...nodes, this._sideReturn);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\tthis._midSend.dispose();\n\t\tthis._sideSend.dispose();\n\t\tthis._midReturn.dispose();\n\t\tthis._sideReturn.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tMidSideEffect,\n\tMidSideEffectOptions,\n} from \"../effect/MidSideEffect.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { Multiply } from \"../signal/Multiply.js\";\nimport { Subtract } from \"../signal/Subtract.js\";\nimport { NormalRange } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\nimport { connect } from \"../core/context/ToneAudioNode.js\";\n\nexport interface StereoWidenerOptions extends MidSideEffectOptions {\n\twidth: NormalRange;\n}\n\n/**\n * Applies a width factor to the mid/side seperation.\n * 0 is all mid and 1 is all side.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * ```\n * Mid *= 2*(1-width)<br>\n * Side *= 2*width\n * ```\n * @category Effect\n */\nexport class StereoWidener extends MidSideEffect<StereoWidenerOptions> {\n\treadonly name: string = \"StereoWidener\";\n\n\t/**\n\t * The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change.\n\t */\n\treadonly width: Signal<\"normalRange\">;\n\n\t/**\n\t * Two times the (1-width) for the mid channel\n\t */\n\tprivate _twoTimesWidthMid: Multiply;\n\n\t/**\n\t * Two times the width for the side channel\n\t */\n\tprivate _twoTimesWidthSide: Multiply;\n\n\t/**\n\t * Mid multiplier\n\t */\n\tprivate _midMult: Multiply;\n\n\t/**\n\t * 1 - width\n\t */\n\tprivate _oneMinusWidth: Subtract;\n\n\t/**\n\t * Side multiplier\n\t */\n\tprivate _sideMult: Multiply;\n\n\t/**\n\t * @param width The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.\n\t */\n\tconstructor(width?: NormalRange);\n\tconstructor(options?: Partial<StereoWidenerOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tStereoWidener.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"width\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.width,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\treadOnly(this, [\"width\"]);\n\t\tthis._twoTimesWidthMid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._twoTimesWidthSide = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._midMult = new Multiply({ context: this.context });\n\t\tthis._twoTimesWidthMid.connect(this._midMult.factor);\n\t\tthis.connectEffectMid(this._midMult);\n\n\t\tthis._oneMinusWidth = new Subtract({ context: this.context });\n\t\tthis._oneMinusWidth.connect(this._twoTimesWidthMid);\n\t\tconnect(this.context.getConstant(1), this._oneMinusWidth);\n\t\tthis.width.connect(this._oneMinusWidth.subtrahend);\n\n\t\tthis._sideMult = new Multiply({ context: this.context });\n\t\tthis.width.connect(this._twoTimesWidthSide);\n\t\tthis._twoTimesWidthSide.connect(this._sideMult.factor);\n\t\tthis.connectEffectSide(this._sideMult);\n\t}\n\n\tstatic getDefaults(): StereoWidenerOptions {\n\t\treturn Object.assign(MidSideEffect.getDefaults(), {\n\t\t\twidth: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.width.dispose();\n\t\tthis._midMult.dispose();\n\t\tthis._sideMult.dispose();\n\t\tthis._twoTimesWidthMid.dispose();\n\t\tthis._twoTimesWidthSide.dispose();\n\t\tthis._oneMinusWidth.dispose();\n\t\treturn this;\n\t}\n}\n","import { StereoEffect, StereoEffectOptions } from \"./StereoEffect.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { Gain } from \"../core/context/Gain.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { Degrees, Frequency, NormalRange, Time } from \"../core/type/Units.js\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface TremoloOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n\tspread: Degrees;\n}\n\n/**\n * Tremolo modulates the amplitude of an incoming signal using an {@link LFO}.\n * The effect is a stereo effect where the modulation phase is inverted in each channel.\n *\n * @example\n * // create a tremolo and start it's LFO\n * const tremolo = new Tone.Tremolo(9, 0.75).toDestination().start();\n * // route an oscillator through the tremolo and start it\n * const oscillator = new Tone.Oscillator().connect(tremolo).start();\n *\n * @category Effect\n */\nexport class Tremolo extends StereoEffect<TremoloOptions> {\n\treadonly name: string = \"Tremolo\";\n\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeL: Gain;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeR: Gain;\n\n\t/**\n\t * The frequency of the tremolo.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The depth of the effect. A depth of 0, has no effect\n\t * on the amplitude, and a depth of 1 makes the amplitude\n\t * modulate fully between 0 and 1.\n\t */\n\treadonly depth: Signal<\"normalRange\">;\n\n\t/**\n\t * @param frequency The rate of the effect.\n\t * @param depth The depth of the effect.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<TremoloOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Tremolo.getDefaults(), arguments, [\n\t\t\t\"frequency\",\n\t\t\t\"depth\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._amplitudeL = new Gain({ context: this.context });\n\t\tthis._amplitudeR = new Gain({ context: this.context });\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.frequency,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.depth = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.depth,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.connectEffectLeft(this._amplitudeL);\n\t\tthis.connectEffectRight(this._amplitudeR);\n\t\tthis._lfoL.connect(this._amplitudeL.gain);\n\t\tthis._lfoR.connect(this._amplitudeR.gain);\n\t\tthis.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n\t\tthis.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): TremoloOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 10,\n\t\t\ttype: \"sine\" as const,\n\t\t\tdepth: 0.5,\n\t\t\tspread: 180,\n\t\t});\n\t}\n\n\t/**\n\t * Start the tremolo.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the tremolo.\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the effect to the transport.\n\t */\n\tsync(): this {\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase; // 180\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - spread / 2;\n\t\tthis._lfoR.phase = spread / 2 + 90;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._amplitudeL.dispose();\n\t\tthis._amplitudeR.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import { Effect, EffectOptions } from \"./Effect.js\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface.js\";\nimport { Frequency, NormalRange, Seconds } from \"../core/type/Units.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults.js\";\nimport { LFO } from \"../source/oscillator/LFO.js\";\nimport { Delay } from \"../core/context/Delay.js\";\nimport { Signal } from \"../signal/Signal.js\";\nimport { Param } from \"../core/context/Param.js\";\nimport { readOnly } from \"../core/util/Interface.js\";\n\nexport interface VibratoOptions extends EffectOptions {\n\tmaxDelay: Seconds;\n\tfrequency: Frequency;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n}\n/**\n * A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n * modulates the delayTime of the delay, causing the pitch to rise and fall.\n * @category Effect\n */\nexport class Vibrato extends Effect<VibratoOptions> {\n\treadonly name: string = \"Vibrato\";\n\t/**\n\t * The delay node used for the vibrato effect\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t * The LFO used to control the vibrato\n\t */\n\tprivate _lfo: LFO;\n\n\t/**\n\t * The frequency of the vibrato\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The depth of the vibrato.\n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * @param frequency The frequency of the vibrato.\n\t * @param depth The amount the pitch is modulated.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<VibratoOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Vibrato.getDefaults(), arguments, [\n\t\t\t\"frequency\",\n\t\t\t\"depth\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 0,\n\t\t\tmax: options.maxDelay,\n\t\t\tfrequency: options.frequency,\n\t\t\tphase: -90, // offse the phase so the resting position is in the center\n\t\t})\n\t\t\t.start()\n\t\t\t.connect(this._delayNode.delayTime);\n\t\tthis.frequency = this._lfo.frequency;\n\t\tthis.depth = this._lfo.amplitude;\n\n\t\tthis.depth.value = options.depth;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.effectSend.chain(this._delayNode, this.effectReturn);\n\t}\n\n\tstatic getDefaults(): VibratoOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tmaxDelay: 0.005,\n\t\t\tfrequency: 5,\n\t\t\tdepth: 0.1,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * Type of oscillator attached to the Vibrato.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Split } from \"../channel/Split.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { assert, assertRange } from \"../../core/util/Debug.js\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n\tchannels: number;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analysers: AnalyserNode[] = [];\n\n\t/**\n\t * Input and output are a gain node\n\t */\n\tprivate _gain: Gain;\n\n\t/**\n\t * The channel splitter node\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffers: Float32Array[] = [];\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tAnalyser.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"type\", \"size\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.input =\n\t\t\tthis.output =\n\t\t\tthis._gain =\n\t\t\t\tnew Gain({ context: this.context });\n\t\tthis._split = new Split({\n\t\t\tcontext: this.context,\n\t\t\tchannels: options.channels,\n\t\t});\n\t\tthis.input.connect(this._split);\n\n\t\tassertRange(options.channels, 1);\n\n\t\t// create the analysers\n\t\tfor (let channel = 0; channel < options.channels; channel++) {\n\t\t\tthis._analysers[channel] = this.context.createAnalyser();\n\t\t\tthis._split.connect(this._analysers[channel], channel, 0);\n\t\t}\n\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t\tthis.smoothing = options.smoothing;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings. If {@link channels} = 1,\n\t * it will return a Float32Array. If {@link channels} > 1, it will\n\t * return an array of Float32Arrays where each index in the array\n\t * represents the analysis done on a channel.\n\t */\n\tgetValue(): Float32Array | Float32Array[] {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tconst buffer = this._buffers[index];\n\t\t\tif (this._type === \"fft\") {\n\t\t\t\tanalyser.getFloatFrequencyData(buffer);\n\t\t\t} else if (this._type === \"waveform\") {\n\t\t\t\tanalyser.getFloatTimeDomainData(buffer);\n\t\t\t}\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn this._buffers[0];\n\t\t} else {\n\t\t\treturn this._buffers;\n\t\t}\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analysers[0].frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tanalyser.fftSize = size * 2;\n\t\t\tthis._buffers[index] = new Float32Array(size);\n\t\t});\n\t}\n\n\t/**\n\t * The number of channels the analyser does the analysis on. Channel\n\t * separation is done using {@link Split}\n\t */\n\tget channels(): number {\n\t\treturn this._analysers.length;\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tassert(\n\t\t\ttype === \"waveform\" || type === \"fft\",\n\t\t\t`Analyser: invalid type: ${type}`\n\t\t);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analysers[0].smoothingTimeConstant;\n\t}\n\tset smoothing(val: NormalRange) {\n\t\tthis._analysers.forEach((a) => (a.smoothingTimeConstant = val));\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analysers.forEach((a) => a.disconnect());\n\t\tthis._split.dispose();\n\t\tthis._gain.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Analyser } from \"./Analyser.js\";\n\nexport type MeterBaseOptions = ToneAudioNodeOptions;\n\n/**\n * The base class for Metering classes.\n */\nexport class MeterBase<\n\tOptions extends MeterBaseOptions,\n> extends ToneAudioNode<Options> {\n\treadonly name: string = \"MeterBase\";\n\n\t/**\n\t * The signal to be analysed\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The output is just a pass through of the input\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The analyser node for the incoming signal\n\t */\n\tprotected _analyser: Analyser;\n\n\tconstructor(options?: Partial<MeterBaseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MeterBase.getDefaults(), arguments));\n\n\t\tthis.input =\n\t\t\tthis.output =\n\t\t\tthis._analyser =\n\t\t\t\tnew Analyser({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tsize: 256,\n\t\t\t\t\ttype: \"waveform\",\n\t\t\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n","import { gainToDb } from \"../../core/type/Conversions.js\";\nimport { NormalRange } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase.js\";\nimport { warn } from \"../../core/util/Debug.js\";\nimport { Analyser } from \"./Analyser.js\";\n\nexport interface MeterOptions extends MeterBaseOptions {\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n\tchannelCount: number;\n}\n\n/**\n * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n * of an input signal. It can also get the raw value of the input signal.\n * Setting `normalRange` to `true` will covert the output to a range of\n * 0-1. See an example using a graphical display\n * [here](https://tonejs.github.io/examples/meter).\n * @see {@link DCMeter}.\n *\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * setInterval(() => console.log(meter.getValue()), 100);\n * @category Component\n */\nexport class Meter extends MeterBase<MeterOptions> {\n\treadonly name: string = \"Meter\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * A value from between 0 and 1 where 0 represents no time averaging with the last analysis frame.\n\t */\n\tsmoothing: number;\n\n\t/**\n\t * The previous frame's value for each channel.\n\t */\n\tprivate _rms: number[];\n\n\t/**\n\t * @param smoothing The amount of smoothing applied between frames.\n\t */\n\tconstructor(smoothing?: NormalRange);\n\tconstructor(options?: Partial<MeterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Meter.getDefaults(), arguments, [\n\t\t\t\"smoothing\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.input =\n\t\t\tthis.output =\n\t\t\tthis._analyser =\n\t\t\t\tnew Analyser({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tsize: 256,\n\t\t\t\t\ttype: \"waveform\",\n\t\t\t\t\tchannels: options.channelCount,\n\t\t\t\t});\n\n\t\t(this.smoothing = options.smoothing),\n\t\t\t(this.normalRange = options.normalRange);\n\t\tthis._rms = new Array(options.channelCount);\n\t\tthis._rms.fill(0);\n\t}\n\n\tstatic getDefaults(): MeterOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsmoothing: 0.8,\n\t\t\tnormalRange: false,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Use {@link getValue} instead. For the previous getValue behavior, use DCMeter.\n\t * @deprecated\n\t */\n\tgetLevel(): number | number[] {\n\t\twarn(\"'getLevel' has been changed to 'getValue'\");\n\t\treturn this.getValue();\n\t}\n\n\t/**\n\t * Get the current value of the incoming signal.\n\t * Output is in decibels when {@link normalRange} is `false`.\n\t * If {@link channels} = 1, then the output is a single number\n\t * representing the value of the input signal. When {@link channels} > 1,\n\t * then each channel is returned as a value in a number array.\n\t */\n\tgetValue(): number | number[] {\n\t\tconst aValues = this._analyser.getValue();\n\t\tconst channelValues =\n\t\t\tthis.channels === 1\n\t\t\t\t? [aValues as Float32Array]\n\t\t\t\t: (aValues as Float32Array[]);\n\t\tconst vals = channelValues.map((values, index) => {\n\t\t\tconst totalSquared = values.reduce(\n\t\t\t\t(total, current) => total + current * current,\n\t\t\t\t0\n\t\t\t);\n\t\t\tconst rms = Math.sqrt(totalSquared / values.length);\n\t\t\t// the rms can only fall at the rate of the smoothing\n\t\t\t// but can jump up instantly\n\t\t\tthis._rms[index] = Math.max(rms, this._rms[index] * this.smoothing);\n\t\t\treturn this.normalRange\n\t\t\t\t? this._rms[index]\n\t\t\t\t: gainToDb(this._rms[index]);\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn vals[0];\n\t\t} else {\n\t\t\treturn vals;\n\t\t}\n\t}\n\n\t/**\n\t * The number of channels of analysis.\n\t */\n\tget channels(): number {\n\t\treturn this._analyser.channels;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode } from \"../../core/context/ToneAudioNode.js\";\nimport { dbToGain } from \"../../core/type/Conversions.js\";\nimport { Hertz, NormalRange, PowerOfTwo } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase.js\";\nimport { assert } from \"../../core/util/Debug.js\";\n\nexport interface FFTOptions extends MeterBaseOptions {\n\tsize: PowerOfTwo;\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n}\n\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * Read more about FFT algorithms on [Wikipedia] (https://en.wikipedia.org/wiki/Fast_Fourier_transform).\n * @category Component\n */\nexport class FFT extends MeterBase<FFTOptions> {\n\treadonly name: string = \"FFT\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<FFTOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(FFT.getDefaults(), arguments, [\n\t\t\t\"size\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.normalRange = options.normalRange;\n\t\tthis._analyser.type = \"fft\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): FFTOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalRange: false,\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the current frequency data from the connected audio source.\n\t * Returns the frequency data of length {@link size} as a Float32Array of decibel values.\n\t */\n\tgetValue(): Float32Array {\n\t\tconst values = this._analyser.getValue() as Float32Array;\n\t\treturn values.map((v) => (this.normalRange ? dbToGain(v) : v));\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by {@link getValue} (i.e. the number of\n\t * frequency bins). Large FFT sizes may be costly to compute.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothing;\n\t}\n\tset smoothing(val) {\n\t\tthis._analyser.smoothing = val;\n\t}\n\n\t/**\n\t * Returns the frequency value in hertz of each of the indices of the FFT's {@link getValue} response.\n\t * @example\n\t * const fft = new Tone.FFT(32);\n\t * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n\t */\n\tgetFrequencyOfIndex(index: number): Hertz {\n\t\tassert(\n\t\t\t0 <= index && index < this.size,\n\t\t\t`index must be greater than or equal to 0 and less than ${this.size}`\n\t\t);\n\t\treturn (index * this.context.sampleRate) / (this.size * 2);\n\t}\n}\n","import { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase.js\";\n\nexport type DCMeterOptions = MeterBaseOptions;\n\n/**\n * DCMeter gets the raw value of the input signal at the current time.\n * @see {@link Meter}.\n *\n * @example\n * const meter = new Tone.DCMeter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\nexport class DCMeter extends MeterBase<DCMeterOptions> {\n\treadonly name: string = \"DCMeter\";\n\n\tconstructor(options?: Partial<DCMeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DCMeter.getDefaults(), arguments));\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis._analyser.size = 256;\n\t}\n\n\t/**\n\t * Get the signal value of the incoming signal\n\t */\n\tgetValue(): number {\n\t\tconst value = this._analyser.getValue() as Float32Array;\n\t\treturn value[0];\n\t}\n}\n","import { PowerOfTwo } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase.js\";\n\nexport interface WaveformOptions extends MeterBaseOptions {\n\t/**\n\t * The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tsize: PowerOfTwo;\n}\n\n/**\n * Get the current waveform data of the connected audio source.\n * @category Component\n */\nexport class Waveform extends MeterBase<WaveformOptions> {\n\treadonly name: string = \"Waveform\";\n\n\t/**\n\t * @param size The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<WaveformOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tWaveform.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"size\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): WaveformOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Return the waveform for the current time as a Float32Array where each value in the array\n\t * represents a sample in the waveform.\n\t */\n\tgetValue(): Float32Array {\n\t\treturn this._analyser.getValue() as Float32Array;\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by {@link getValue}.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n}\n","import { BaseContext } from \"../../core/context/BaseContext.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\n\nexport interface SoloOptions extends ToneAudioNodeOptions {\n\tsolo: boolean;\n}\n\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode<SoloOptions> {\n\treadonly name: string = \"Solo\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param solo If the connection should be initially solo'ed.\n\t */\n\tconstructor(solo?: boolean);\n\tconstructor(options?: Partial<SoloOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Solo.getDefaults(), arguments, [\n\t\t\t\"solo\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tif (!Solo._allSolos.has(this.context)) {\n\t\t\tSolo._allSolos.set(this.context, new Set());\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).add(this);\n\n\t\t// set initially\n\t\tthis.solo = options.solo;\n\t}\n\n\tstatic getDefaults(): SoloOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsolo: false,\n\t\t});\n\t}\n\n\t/**\n\t * Hold all of the solo'ed tracks belonging to a specific context\n\t */\n\tprivate static _allSolos: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Hold the currently solo'ed instance(s)\n\t */\n\tprivate static _soloed: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Isolates this instance and mutes all other instances of Solo.\n\t * Only one instance can be soloed at a time. A soloed\n\t * instance will report `solo=false` when another instance is soloed.\n\t */\n\tget solo(): boolean {\n\t\treturn this._isSoloed();\n\t}\n\tset solo(solo) {\n\t\tif (solo) {\n\t\t\tthis._addSolo();\n\t\t} else {\n\t\t\tthis._removeSolo();\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).forEach((instance) =>\n\t\t\tinstance._updateSolo()\n\t\t);\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed\n\t */\n\tget muted(): boolean {\n\t\treturn this.input.gain.value === 0;\n\t}\n\n\t/**\n\t * Add this to the soloed array\n\t */\n\tprivate _addSolo(): void {\n\t\tif (!Solo._soloed.has(this.context)) {\n\t\t\tSolo._soloed.set(this.context, new Set());\n\t\t}\n\t\t(Solo._soloed.get(this.context) as Set<Solo>).add(this);\n\t}\n\n\t/**\n\t * Remove this from the soloed array\n\t */\n\tprivate _removeSolo(): void {\n\t\tif (Solo._soloed.has(this.context)) {\n\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).delete(this);\n\t\t}\n\t}\n\n\t/**\n\t * Is this on the soloed array\n\t */\n\tprivate _isSoloed(): boolean {\n\t\treturn (\n\t\t\tSolo._soloed.has(this.context) &&\n\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).has(this)\n\t\t);\n\t}\n\n\t/**\n\t * Returns true if no one is soloed\n\t */\n\tprivate _noSolos(): boolean {\n\t\t// either does not have any soloed added\n\t\treturn (\n\t\t\t!Solo._soloed.has(this.context) ||\n\t\t\t// or has a solo set but doesn't include any items\n\t\t\t(Solo._soloed.has(this.context) &&\n\t\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).size === 0)\n\t\t);\n\t}\n\n\t/**\n\t * Solo the current instance and unsolo all other instances.\n\t */\n\tprivate _updateSolo(): void {\n\t\tif (this._isSoloed()) {\n\t\t\tthis.input.gain.value = 1;\n\t\t} else if (this._noSolos()) {\n\t\t\t// no one is soloed\n\t\t\tthis.input.gain.value = 1;\n\t\t} else {\n\t\t\tthis.input.gain.value = 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).delete(this);\n\t\tthis._removeSolo();\n\t\treturn this;\n\t}\n}\n","import { readOnly } from \"../../core/util/Interface.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { AudioRange, Decibels } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Panner } from \"./Panner.js\";\nimport { Volume } from \"./Volume.js\";\n\nexport interface PanVolOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tmute: boolean;\n\tchannelCount: number;\n}\n\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\nexport class PanVol extends ToneAudioNode<PanVolOptions> {\n\treadonly name: string = \"PanVol\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The panning node\n\t */\n\tprivate _panner: Panner;\n\n\t/**\n\t * The L/R panning control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param pan the initial pan\n\t * @param volume The output volume.\n\t */\n\tconstructor(pan?: AudioRange, volume?: Decibels);\n\tconstructor(options?: Partial<PanVolOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(PanVol.getDefaults(), arguments, [\n\t\t\t\"pan\",\n\t\t\t\"volume\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._panner = this.input = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tchannelCount: options.channelCount,\n\t\t});\n\t\tthis.pan = this._panner.pan;\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\n\t\t// connections\n\t\tthis._panner.connect(this._volume);\n\t\tthis.mute = options.mute;\n\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): PanVolOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\tthis.pan.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Decibels } from \"../../core/type/Units.js\";\nimport {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Solo } from \"./Solo.js\";\nimport { PanVol } from \"./PanVol.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\n\nexport interface ChannelOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tsolo: boolean;\n\tmute: boolean;\n\tchannelCount: number;\n}\n\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls.\n * @see {@link PanVol} and {@link Solo}\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\nexport class Channel extends ToneAudioNode<ChannelOptions> {\n\treadonly name: string = \"Channel\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The soloing interface\n\t */\n\tprivate _solo: Solo;\n\n\t/**\n\t * The panning and volume node\n\t */\n\tprivate _panVol: PanVol;\n\n\t/**\n\t * The L/R panning control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The output volume.\n\t * @param pan the initial pan\n\t */\n\tconstructor(volume?: Decibels, pan?: AudioRange);\n\tconstructor(options?: Partial<ChannelOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Channel.getDefaults(), arguments, [\n\t\t\t\"volume\",\n\t\t\t\"pan\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._solo = this.input = new Solo({\n\t\t\tsolo: options.solo,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._panVol = this.output = new PanVol({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tvolume: options.volume,\n\t\t\tmute: options.mute,\n\t\t\tchannelCount: options.channelCount,\n\t\t});\n\t\tthis.pan = this._panVol.pan;\n\t\tthis.volume = this._panVol.volume;\n\n\t\tthis._solo.connect(this._panVol);\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): ChannelOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tmute: false,\n\t\t\tsolo: false,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Solo/unsolo the channel. Soloing is only relative to other {@link Channel}s and {@link Solo} instances\n\t */\n\tget solo(): boolean {\n\t\treturn this._solo.solo;\n\t}\n\tset solo(solo) {\n\t\tthis._solo.solo = solo;\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed,\n\t * or the channel is muted\n\t */\n\tget muted(): boolean {\n\t\treturn this._solo.muted || this.mute;\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._panVol.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._panVol.mute = mute;\n\t}\n\n\t/**\n\t * Store the send/receive channels by name.\n\t */\n\tprivate static buses: Map<string, Gain> = new Map();\n\n\t/**\n\t * Get the gain node belonging to the bus name. Create it if\n\t * it doesn't exist\n\t * @param name The bus name\n\t */\n\tprivate _getBus(name: string): Gain {\n\t\tif (!Channel.buses.has(name)) {\n\t\t\tChannel.buses.set(name, new Gain({ context: this.context }));\n\t\t}\n\t\treturn Channel.buses.get(name) as Gain;\n\t}\n\n\t/**\n\t * Send audio to another channel using a string. `send` is a lot like\n\t * {@link connect}, except it uses a string instead of an object. This can\n\t * be useful in large applications to decouple sections since {@link send}\n\t * and {@link receive} can be invoked separately in order to connect an object\n\t * @param name The channel name to send the audio\n\t * @param volume The amount of the signal to send.\n\t * \tDefaults to 0db, i.e. send the entire signal\n\t * @returns Returns the gain node of this connection.\n\t */\n\tsend(name: string, volume: Decibels = 0): Gain<\"decibels\"> {\n\t\tconst bus = this._getBus(name);\n\t\tconst sendKnob = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tgain: volume,\n\t\t});\n\t\tthis.connect(sendKnob);\n\t\tsendKnob.connect(bus);\n\t\treturn sendKnob;\n\t}\n\n\t/**\n\t * Receive audio from a channel which was connected with {@link send}.\n\t * @param name The channel name to receive audio from.\n\t */\n\treceive(name: string): this {\n\t\tconst bus = this._getBus(name);\n\t\tbus.connect(this);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panVol.dispose();\n\t\tthis.pan.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._solo.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Merge } from \"./Merge.js\";\n\nexport type MonoOptions = ToneAudioNodeOptions;\n\n/**\n * Mono coerces the incoming mono or stereo signal into a mono signal\n * where both left and right channels have the same value. This can be useful\n * for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).\n * @category Component\n */\nexport class Mono extends ToneAudioNode<MonoOptions> {\n\treadonly name: string = \"Mono\";\n\n\t/**\n\t * merge the signal\n\t */\n\tprivate _merge: Merge;\n\n\t/**\n\t * The summed output of the multiple inputs\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * The stereo signal to sum to mono\n\t */\n\treadonly input: Gain;\n\n\tconstructor(options?: Partial<MonoOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Mono.getDefaults(), arguments));\n\n\t\tthis.input = new Gain({ context: this.context });\n\n\t\tthis._merge = this.output = new Merge({\n\t\t\tchannels: 2,\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tthis.input.connect(this._merge, 0, 0);\n\t\tthis.input.connect(this._merge, 0, 1);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merge.dispose();\n\t\tthis.input.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Frequency, Positive } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly, writable } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Filter } from \"../filter/Filter.js\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * Split the incoming signal into three bands (low, mid, high)\n * with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n * @category Component\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\treadonly name: string = \"MultibandSplit\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t * The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param lowFrequency the low/mid crossover frequency\n\t * @param highFrequency the mid/high crossover frequency\n\t */\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMultibandSplit.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"lowFrequency\", \"highFrequency\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Degrees, GainFactor } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport \"../../core/context/Listener.js\";\n\nexport interface Panner3DOptions extends ToneAudioNodeOptions {\n\tconeInnerAngle: Degrees;\n\tconeOuterAngle: Degrees;\n\tconeOuterGain: GainFactor;\n\tdistanceModel: DistanceModelType;\n\tmaxDistance: number;\n\torientationX: number;\n\torientationY: number;\n\torientationZ: number;\n\tpanningModel: PanningModelType;\n\tpositionX: number;\n\tpositionY: number;\n\tpositionZ: number;\n\trefDistance: number;\n\trolloffFactor: number;\n}\n\n/**\n * A spatialized panner node which supports equalpower or HRTF panning.\n * @category Component\n */\nexport class Panner3D extends ToneAudioNode<Panner3DOptions> {\n\treadonly name: string = \"Panner3D\";\n\n\t/**\n\t * The panning object\n\t */\n\tprivate _panner: PannerNode;\n\treadonly input: PannerNode;\n\treadonly output: PannerNode;\n\n\treadonly positionX: Param<\"number\">;\n\treadonly positionY: Param<\"number\">;\n\treadonly positionZ: Param<\"number\">;\n\n\treadonly orientationX: Param<\"number\">;\n\treadonly orientationY: Param<\"number\">;\n\treadonly orientationZ: Param<\"number\">;\n\n\t/**\n\t * @param positionX The initial x position.\n\t * @param positionY The initial y position.\n\t * @param positionZ The initial z position.\n\t */\n\tconstructor(positionX: number, positionY: number, positionZ: number);\n\tconstructor(options?: Partial<Panner3DOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tPanner3D.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"positionX\", \"positionY\", \"positionZ\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._panner = this.input = this.output = this.context.createPanner();\n\t\t// set some values\n\t\tthis.panningModel = options.panningModel;\n\t\tthis.maxDistance = options.maxDistance;\n\t\tthis.distanceModel = options.distanceModel;\n\t\tthis.coneOuterGain = options.coneOuterGain;\n\t\tthis.coneOuterAngle = options.coneOuterAngle;\n\t\tthis.coneInnerAngle = options.coneInnerAngle;\n\t\tthis.refDistance = options.refDistance;\n\t\tthis.rolloffFactor = options.rolloffFactor;\n\n\t\tthis.positionX = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionX,\n\t\t\tvalue: options.positionX,\n\t\t});\n\t\tthis.positionY = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionY,\n\t\t\tvalue: options.positionY,\n\t\t});\n\t\tthis.positionZ = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionZ,\n\t\t\tvalue: options.positionZ,\n\t\t});\n\t\tthis.orientationX = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationX,\n\t\t\tvalue: options.orientationX,\n\t\t});\n\t\tthis.orientationY = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationY,\n\t\t\tvalue: options.orientationY,\n\t\t});\n\t\tthis.orientationZ = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationZ,\n\t\t\tvalue: options.orientationZ,\n\t\t});\n\t}\n\n\tstatic getDefaults(): Panner3DOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconeInnerAngle: 360,\n\t\t\tconeOuterAngle: 360,\n\t\t\tconeOuterGain: 0,\n\t\t\tdistanceModel: \"inverse\" as DistanceModelType,\n\t\t\tmaxDistance: 10000,\n\t\t\torientationX: 0,\n\t\t\torientationY: 0,\n\t\t\torientationZ: 0,\n\t\t\tpanningModel: \"equalpower\" as PanningModelType,\n\t\t\tpositionX: 0,\n\t\t\tpositionY: 0,\n\t\t\tpositionZ: 0,\n\t\t\trefDistance: 1,\n\t\t\trolloffFactor: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Sets the position of the source in 3d space.\n\t */\n\tsetPosition(x: number, y: number, z: number): this {\n\t\tthis.positionX.value = x;\n\t\tthis.positionY.value = y;\n\t\tthis.positionZ.value = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the orientation of the source in 3d space.\n\t */\n\tsetOrientation(x: number, y: number, z: number): this {\n\t\tthis.orientationX.value = x;\n\t\tthis.orientationY.value = y;\n\t\tthis.orientationZ.value = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The panning model. Either \"equalpower\" or \"HRTF\".\n\t */\n\tget panningModel(): PanningModelType {\n\t\treturn this._panner.panningModel;\n\t}\n\tset panningModel(val) {\n\t\tthis._panner.panningModel = val;\n\t}\n\n\t/**\n\t * A reference distance for reducing volume as source move further from the listener\n\t */\n\tget refDistance(): number {\n\t\treturn this._panner.refDistance;\n\t}\n\tset refDistance(val) {\n\t\tthis._panner.refDistance = val;\n\t}\n\n\t/**\n\t * Describes how quickly the volume is reduced as source moves away from listener.\n\t */\n\tget rolloffFactor(): number {\n\t\treturn this._panner.rolloffFactor;\n\t}\n\tset rolloffFactor(val) {\n\t\tthis._panner.rolloffFactor = val;\n\t}\n\n\t/**\n\t * The distance model used by,  \"linear\", \"inverse\", or \"exponential\".\n\t */\n\tget distanceModel(): DistanceModelType {\n\t\treturn this._panner.distanceModel;\n\t}\n\tset distanceModel(val) {\n\t\tthis._panner.distanceModel = val;\n\t}\n\n\t/**\n\t * The angle, in degrees, inside of which there will be no volume reduction\n\t */\n\tget coneInnerAngle(): Degrees {\n\t\treturn this._panner.coneInnerAngle;\n\t}\n\tset coneInnerAngle(val) {\n\t\tthis._panner.coneInnerAngle = val;\n\t}\n\n\t/**\n\t * The angle, in degrees, outside of which the volume will be reduced\n\t * to a constant value of coneOuterGain\n\t */\n\tget coneOuterAngle(): Degrees {\n\t\treturn this._panner.coneOuterAngle;\n\t}\n\tset coneOuterAngle(val) {\n\t\tthis._panner.coneOuterAngle = val;\n\t}\n\n\t/**\n\t * The gain outside of the coneOuterAngle\n\t */\n\tget coneOuterGain(): GainFactor {\n\t\treturn this._panner.coneOuterGain;\n\t}\n\tset coneOuterGain(val) {\n\t\tthis._panner.coneOuterGain = val;\n\t}\n\n\t/**\n\t * The maximum distance between source and listener,\n\t * after which the volume will not be reduced any further.\n\t */\n\tget maxDistance(): number {\n\t\treturn this._panner.maxDistance;\n\t}\n\tset maxDistance(val) {\n\t\tthis._panner.maxDistance = val;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.orientationX.dispose();\n\t\tthis.orientationY.dispose();\n\t\tthis.orientationZ.dispose();\n\t\tthis.positionX.dispose();\n\t\tthis.positionY.dispose();\n\t\tthis.positionZ.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { assert } from \"../../core/util/Debug.js\";\nimport { theWindow } from \"../../core/context/AudioContext.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { PlaybackState } from \"../../core/util/StateTimeline.js\";\n\nexport interface RecorderOptions extends ToneAudioNodeOptions {\n\tmimeType?: string;\n}\n\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox.\n * For a cross-browser shim, install [audio-recorder-polyfill](https://www.npmjs.com/package/audio-recorder-polyfill).\n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\nexport class Recorder extends ToneAudioNode<RecorderOptions> {\n\treadonly name = \"Recorder\";\n\n\t/**\n\t * Recorder uses the Media Recorder API\n\t */\n\tprivate _recorder: MediaRecorder;\n\n\t/**\n\t * MediaRecorder requires\n\t */\n\tprivate _stream: MediaStreamAudioDestinationNode;\n\n\treadonly input: Gain;\n\treadonly output: undefined;\n\n\tconstructor(options?: Partial<RecorderOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Recorder.getDefaults(), arguments);\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tassert(Recorder.supported, \"Media Recorder API is not available\");\n\n\t\tthis._stream = this.context.createMediaStreamDestination();\n\t\tthis.input.connect(this._stream);\n\t\tthis._recorder = new MediaRecorder(this._stream.stream, {\n\t\t\tmimeType: options.mimeType,\n\t\t});\n\t}\n\n\tstatic getDefaults(): RecorderOptions {\n\t\treturn ToneAudioNode.getDefaults();\n\t}\n\n\t/**\n\t * The mime type is the format that the audio is encoded in. For Chrome\n\t * that is typically webm encoded as \"vorbis\".\n\t */\n\tget mimeType(): string {\n\t\treturn this._recorder.mimeType;\n\t}\n\n\t/**\n\t * Test if your platform supports the Media Recorder API. If it's not available,\n\t * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n\t */\n\tstatic get supported(): boolean {\n\t\treturn theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n\t}\n\n\t/**\n\t * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._recorder.state === \"inactive\") {\n\t\t\treturn \"stopped\";\n\t\t} else if (this._recorder.state === \"paused\") {\n\t\t\treturn \"paused\";\n\t\t} else {\n\t\t\treturn \"started\";\n\t\t}\n\t}\n\n\t/**\n\t * Start/Resume the Recorder. Returns a promise which resolves\n\t * when the recorder has started.\n\t */\n\tasync start() {\n\t\tassert(this.state !== \"started\", \"Recorder is already started\");\n\t\tconst startPromise = new Promise<void>((done) => {\n\t\t\tconst handleStart = () => {\n\t\t\t\tthis._recorder.removeEventListener(\"start\", handleStart, false);\n\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"start\", handleStart, false);\n\t\t});\n\t\tif(this.state === \"stopped\") {\n\t\t\tthis._recorder.start();\n\t\t} else {\n\t\t\tthis._recorder.resume();\n\t\t}\n\t\treturn await startPromise;\n\t}\n\n\t/**\n\t * Stop the recorder. Returns a promise with the recorded content until this point\n\t * encoded as {@link mimeType}\n\t */\n\tasync stop(): Promise<Blob> {\n\t\tassert(this.state !== \"stopped\", \"Recorder is not started\");\n\t\tconst dataPromise: Promise<Blob> = new Promise((done) => {\n\t\t\tconst handleData = (e: BlobEvent) => {\n\t\t\t\tthis._recorder.removeEventListener(\n\t\t\t\t\t\"dataavailable\",\n\t\t\t\t\thandleData,\n\t\t\t\t\tfalse\n\t\t\t\t);\n\n\t\t\t\tdone(e.data);\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"dataavailable\", handleData, false);\n\t\t});\n\t\tthis._recorder.stop();\n\t\treturn await dataPromise;\n\t}\n\n\t/**\n\t * Pause the recorder\n\t */\n\tpause(): this {\n\t\tassert(this.state === \"started\", \"Recorder must be started\");\n\t\tthis._recorder.pause();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._stream.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n\nexport interface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * const comp = new Tone.Compressor(-30, 3);\n * @category Component\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\treadonly name: string = \"Compressor\";\n\n\t/**\n\t * the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode =\n\t\tthis.context.createDynamicsCompressor();\n\treadonly input = this._compressor;\n\treadonly output = this._compressor;\n\n\t/**\n\t * The decibel value above which the compression will start taking effect.\n\t * @min -100\n\t * @max 0\n\t */\n\treadonly threshold: Param<\"decibels\">;\n\n\t/**\n\t * The amount of time (in seconds) to reduce the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly attack: Param<\"time\">;\n\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly release: Param<\"time\">;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t * @min 0\n\t * @max 40\n\t */\n\treadonly knee: Param<\"decibels\">;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t * @min 1\n\t * @max 20\n\t */\n\treadonly ratio: Param<\"positive\">;\n\n\t/**\n\t * @param threshold The value above which the compression starts to be applied.\n\t * @param ratio The gain reduction ratio.\n\t */\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tCompressor.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"threshold\", \"ratio\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis.threshold = new Param({\n\t\t\tminValue: this._compressor.threshold.minValue,\n\t\t\tmaxValue: this._compressor.threshold.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.threshold,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\n\t\tthis.attack = new Param({\n\t\t\tminValue: this._compressor.attack.minValue,\n\t\t\tmaxValue: this._compressor.attack.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\n\t\tthis.release = new Param({\n\t\t\tminValue: this._compressor.release.minValue,\n\t\t\tmaxValue: this._compressor.release.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\n\t\tthis.knee = new Param({\n\t\t\tminValue: this._compressor.knee.minValue,\n\t\t\tmaxValue: this._compressor.knee.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.knee,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\n\t\tthis.ratio = new Param({\n\t\t\tminValue: this._compressor.ratio.minValue,\n\t\t\tmaxValue: this._compressor.ratio.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.ratio,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.003,\n\t\t\tknee: 30,\n\t\t\tratio: 12,\n\t\t\trelease: 0.25,\n\t\t\tthreshold: -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): Decibels {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Decibels, Time } from \"../../core/type/Units.js\";\nimport { GreaterThan } from \"../../signal/GreaterThan.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { Follower } from \"../analysis/Follower.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { dbToGain, gainToDb } from \"../../core/type/Conversions.js\";\n\nexport interface GateOptions extends ToneAudioNodeOptions {\n\tthreshold: Decibels;\n\tsmoothing: Time;\n}\n\n/**\n * Gate only passes a signal through when the incoming\n * signal exceeds a specified threshold. It uses {@link Follower} to follow the ampltiude\n * of the incoming signal and compares it to the {@link threshold} value using {@link GreaterThan}.\n *\n * @example\n * const gate = new Tone.Gate(-30, 0.2).toDestination();\n * const mic = new Tone.UserMedia().connect(gate);\n * // the gate will only pass through the incoming\n * // signal when it's louder than -30db\n * @category Component\n */\nexport class Gate extends ToneAudioNode<GateOptions> {\n\treadonly name: string = \"Gate\";\n\n\treadonly input: ToneAudioNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * Follow the incoming signal\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * Test if it's greater than the threshold\n\t */\n\tprivate _gt: GreaterThan;\n\n\t/**\n\t * Gate the incoming signal when it does not exceed the threshold\n\t */\n\tprivate _gate: Gain;\n\n\t/**\n\t * @param threshold The threshold above which the gate will open.\n\t * @param smoothing The follower's smoothing time\n\t */\n\tconstructor(threshold?: Decibels, smoothing?: Time);\n\tconstructor(options?: Partial<GateOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Gate.getDefaults(), arguments, [\n\t\t\t\"threshold\",\n\t\t\t\"smoothing\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.smoothing,\n\t\t});\n\t\tthis._gt = new GreaterThan({\n\t\t\tcontext: this.context,\n\t\t\tvalue: dbToGain(options.threshold),\n\t\t});\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis._gate = this.output = new Gain({ context: this.context });\n\n\t\t// connections\n\t\tthis.input.connect(this._gate);\n\t\t// the control signal\n\t\tthis.input.chain(this._follower, this._gt, this._gate.gain);\n\t}\n\n\tstatic getDefaults(): GateOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.1,\n\t\t\tthreshold: -40,\n\t\t});\n\t}\n\n\t/**\n\t * The threshold of the gate in decibels\n\t */\n\tget threshold(): Decibels {\n\t\treturn gainToDb(this._gt.value);\n\t}\n\tset threshold(thresh) {\n\t\tthis._gt.value = dbToGain(thresh);\n\t}\n\n\t/**\n\t * The attack/decay speed of the gate.\n\t * @see {@link Follower.smoothing}\n\t */\n\tget smoothing(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset smoothing(smoothingTime) {\n\t\tthis._follower.smoothing = smoothingTime;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._gt.dispose();\n\t\tthis._gate.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Decibels } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Compressor } from \"./Compressor.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport { readOnly } from \"../../core/util/Interface.js\";\n\nexport interface LimiterOptions extends ToneAudioNodeOptions {\n\tthreshold: Decibels;\n}\n\n/**\n * Limiter will limit the loudness of an incoming signal.\n * Under the hood it's composed of a {@link Compressor} with a fast attack\n * and release and max compression ratio.\n *\n * @example\n * const limiter = new Tone.Limiter(-20).toDestination();\n * const oscillator = new Tone.Oscillator().connect(limiter);\n * oscillator.start();\n * @category Component\n */\nexport class Limiter extends ToneAudioNode<LimiterOptions> {\n\treadonly name: string = \"Limiter\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The compressor which does the limiting\n\t */\n\tprivate _compressor: Compressor;\n\n\treadonly threshold: Param<\"decibels\">;\n\n\t/**\n\t * @param threshold The threshold above which the gain reduction is applied.\n\t */\n\tconstructor(threshold?: Decibels);\n\tconstructor(options?: Partial<LimiterOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(Limiter.getDefaults(), arguments, [\n\t\t\t\"threshold\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis._compressor =\n\t\t\tthis.input =\n\t\t\tthis.output =\n\t\t\t\tnew Compressor({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tratio: 20,\n\t\t\t\t\tattack: 0.003,\n\t\t\t\t\trelease: 0.01,\n\t\t\t\t\tthreshold: options.threshold,\n\t\t\t\t});\n\n\t\tthis.threshold = this._compressor.threshold;\n\t\treadOnly(this, \"threshold\");\n\t}\n\n\tstatic getDefaults(): LimiterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tthreshold: -12,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal.\n\t */\n\tget reduction(): Decibels {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.dispose();\n\t\tthis.threshold.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tInputNode,\n\tOutputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Compressor, CompressorOptions } from \"./Compressor.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { MidSideSplit } from \"../channel/MidSideSplit.js\";\nimport { MidSideMerge } from \"../channel/MidSideMerge.js\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface.js\";\n\nexport interface MidSideCompressorOptions extends ToneAudioNodeOptions {\n\tmid: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tside: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MidSideCompressor applies two different compressors to the {@link mid}\n * and {@link side} signal components of the input.\n * @see {@link MidSideSplit} and {@link MidSideMerge}.\n * @category Component\n */\nexport class MidSideCompressor extends ToneAudioNode<MidSideCompressorOptions> {\n\treadonly name: string = \"MidSideCompressor\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Split the incoming signal into Mid/Side\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\n\t/**\n\t * Merge the compressed signal back into a single stream\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\n\t/**\n\t * The compression applied to the mid signal\n\t */\n\treadonly mid: Compressor;\n\n\t/**\n\t * The compression applied to the side signal\n\t */\n\treadonly side: Compressor;\n\n\tconstructor(options?: RecursivePartial<MidSideCompressorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMidSideCompressor.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._midSideSplit = this.input = new MidSideSplit({\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._midSideMerge = this.output = new MidSideMerge({\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis.mid = new Compressor(\n\t\t\tObject.assign(options.mid, { context: this.context })\n\t\t);\n\t\tthis.side = new Compressor(\n\t\t\tObject.assign(options.side, { context: this.context })\n\t\t);\n\n\t\tthis._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);\n\t\tthis._midSideSplit.side.chain(this.side, this._midSideMerge.side);\n\t\treadOnly(this, [\"mid\", \"side\"]);\n\t}\n\n\tstatic getDefaults(): MidSideCompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmid: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16,\n\t\t\t},\n\t\t\tside: {\n\t\t\t\tratio: 6,\n\t\t\t\tthreshold: -30,\n\t\t\t\trelease: 0.25,\n\t\t\t\tattack: 0.03,\n\t\t\t\tknee: 10,\n\t\t\t},\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tInputNode,\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Compressor, CompressorOptions } from \"./Compressor.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface.js\";\nimport { Frequency } from \"../../core/type/Units.js\";\nimport { MultibandSplit } from \"../channel/MultibandSplit.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\n\nexport interface MultibandCompressorOptions extends ToneAudioNodeOptions {\n\tmid: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tlow: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\thigh: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * A compressor with separate controls over low/mid/high dynamics.\n * @see {@link Compressor} and {@link MultibandSplit}\n *\n * @example\n * const multiband = new Tone.MultibandCompressor({\n * \tlowFrequency: 200,\n * \thighFrequency: 1300,\n * \tlow: {\n * \t\tthreshold: -12\n * \t}\n * });\n * @category Component\n */\nexport class MultibandCompressor extends ToneAudioNode<MultibandCompressorOptions> {\n\treadonly name: string = \"MultibandCompressor\";\n\n\treadonly input: InputNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * Split the incoming signal into high/mid/low\n\t */\n\tprivate _splitter: MultibandSplit;\n\n\t/**\n\t * low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The compressor applied to the low frequencies\n\t */\n\treadonly low: Compressor;\n\n\t/**\n\t * The compressor applied to the mid frequencies\n\t */\n\treadonly mid: Compressor;\n\n\t/**\n\t * The compressor applied to the high frequencies\n\t */\n\treadonly high: Compressor;\n\n\tconstructor(options?: RecursivePartial<MultibandCompressorOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tMultibandCompressor.getDefaults(),\n\t\t\targuments\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._splitter = this.input = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t\thighFrequency: options.highFrequency,\n\t\t});\n\t\tthis.lowFrequency = this._splitter.lowFrequency;\n\t\tthis.highFrequency = this._splitter.highFrequency;\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis.low = new Compressor(\n\t\t\tObject.assign(options.low, { context: this.context })\n\t\t);\n\t\tthis.mid = new Compressor(\n\t\t\tObject.assign(options.mid, { context: this.context })\n\t\t);\n\t\tthis.high = new Compressor(\n\t\t\tObject.assign(options.high, { context: this.context })\n\t\t);\n\n\t\t// connect the compressor\n\t\tthis._splitter.low.chain(this.low, this.output);\n\t\tthis._splitter.mid.chain(this.mid, this.output);\n\t\tthis._splitter.high.chain(this.high, this.output);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandCompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tlowFrequency: 250,\n\t\t\thighFrequency: 2000,\n\t\t\tlow: {\n\t\t\t\tratio: 6,\n\t\t\t\tthreshold: -30,\n\t\t\t\trelease: 0.25,\n\t\t\t\tattack: 0.03,\n\t\t\t\tknee: 10,\n\t\t\t},\n\t\t\tmid: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16,\n\t\t\t},\n\t\t\thigh: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16,\n\t\t\t},\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.output.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain.js\";\nimport { Param } from \"../../core/context/Param.js\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { Decibels, Frequency } from \"../../core/type/Units.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { readOnly, writable } from \"../../core/util/Interface.js\";\nimport { Signal } from \"../../signal/Signal.js\";\nimport { MultibandSplit } from \"../channel/MultibandSplit.js\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * EQ3 provides 3 equalizer bins: Low/Mid/High.\n * @category Component\n */\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\treadonly name: string = \"EQ3\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t * the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * Splits the input into three outputs\n\t */\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t * The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the high signals\n\t */\n\tprivate _highGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<\"decibels\">;\n\n\t/**\n\t * The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\n\t\t\t\"low\",\n\t\t\t\"mid\",\n\t\t\t\"high\",\n\t\t]);\n\t\tsuper(options);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency = this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh: 0,\n\t\t\thighFrequency: 2500,\n\t\t\tlow: 0,\n\t\t\tlowFrequency: 400,\n\t\t\tmid: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n}\n","import {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../../core/context/ToneAudioNode.js\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer.js\";\nimport { optionsFromArguments } from \"../../core/util/Defaults.js\";\nimport { Gain } from \"../../core/context/Gain.js\";\nimport { noOp } from \"../../core/util/Interface.js\";\n\nexport interface ConvolverOptions extends ToneAudioNodeOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * // initializing the convolver with an impulse response\n * const convolver = new Tone.Convolver(\"./path/to/ir.wav\").toDestination();\n * @category Component\n */\nexport class Convolver extends ToneAudioNode<ConvolverOptions> {\n\treadonly name: string = \"Convolver\";\n\n\t/**\n\t * The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param url The URL of the impulse response or the ToneAudioBuffer containing the impulse response.\n\t * @param onload The callback to invoke when the url is loaded.\n\t */\n\tconstructor(\n\t\turl?: string | AudioBuffer | ToneAudioBuffer,\n\t\tonload?: () => void\n\t);\n\tconstructor(options?: Partial<ConvolverOptions>);\n\tconstructor() {\n\t\tconst options = optionsFromArguments(\n\t\t\tConvolver.getDefaults(),\n\t\t\targuments,\n\t\t\t[\"url\", \"onload\"]\n\t\t);\n\t\tsuper(options);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, (buffer) => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\t// set if it's already loaded, set it immediately\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.input.chain(this._convolver, this.output);\n\t}\n\n\tstatic getDefaults(): ConvolverOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalize: true,\n\t\t\tonload: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t * The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.input.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.input.chain(this._convolver, this.output);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","export { getContext, setContext } from \"./core/Global.js\";\nimport { Context } from \"./core/context/Context.js\";\nexport * from \"./classes.js\";\nexport * from \"./version.js\";\nimport { getContext } from \"./core/Global.js\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer.js\";\nexport { start } from \"./core/Global.js\";\nimport { Seconds } from \"./core/type/Units.js\";\nexport { supported } from \"./core/context/AudioContext.js\";\nimport type { TransportClass } from \"./core/clock/Transport.js\";\nimport type { DestinationClass } from \"./core/context/Destination.js\";\nimport type { DrawClass } from \"./core/util/Draw.js\";\nimport type { ListenerClass } from \"./core/context/Listener.js\";\n\n/**\n * The current audio context time of the global {@link BaseContext}.\n * @see {@link Context.now}\n * @category Core\n */\nexport function now(): Seconds {\n\treturn getContext().now();\n}\n\n/**\n * The current audio context time of the global {@link Context} without the {@link Context.lookAhead}\n * @see {@link Context.immediate}\n * @category Core\n */\nexport function immediate(): Seconds {\n\treturn getContext().immediate();\n}\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * @see {@link TransportClass}\n * @category Core\n * @deprecated Use {@link getTransport} instead\n */\nexport const Transport = getContext().transport;\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * @see {@link TransportClass}\n * @category Core\n */\nexport function getTransport(): TransportClass {\n\treturn getContext().transport;\n}\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * @see {@link DestinationClass}\n * @category Core\n * @deprecated Use {@link getDestination} instead\n */\nexport const Destination = getContext().destination;\n\n/**\n * @deprecated Use {@link getDestination} instead\n */\nexport const Master = getContext().destination;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * @see {@link DestinationClass}\n * @category Core\n */\nexport function getDestination(): DestinationClass {\n\treturn getContext().destination;\n}\n\n/**\n * The {@link ListenerClass} belonging to the global Tone.js Context.\n * @category Core\n * @deprecated Use {@link getListener} instead\n */\nexport const Listener = getContext().listener;\n\n/**\n * The {@link ListenerClass} belonging to the global Tone.js Context.\n * @category Core\n */\nexport function getListener(): ListenerClass {\n\treturn getContext().listener;\n}\n\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * @see {@link DrawClass}\n * @category Core\n * @deprecated Use {@link getDraw} instead\n */\nexport const Draw = getContext().draw;\n\n/**\n * Get the singleton attached to the global context.\n * Draw is used to synchronize the draw frame with the Transport's callbacks.\n * @see {@link DrawClass}\n * @category Core\n */\nexport function getDraw(): DrawClass {\n\treturn getContext().draw;\n}\n\n/**\n * A reference to the global context\n * @see {@link Context}\n * @deprecated Use {@link getContext} instead\n */\nexport const context = getContext();\n\n/**\n * Promise which resolves when all of the loading promises are resolved.\n * Alias for static {@link ToneAudioBuffer.loaded} method.\n * @category Core\n */\nexport function loaded() {\n\treturn ToneAudioBuffer.loaded();\n}\n\n// this fills in name changes from 13.x to 14.x\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers.js\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource.js\";\n/** @deprecated Use {@link ToneAudioBuffer} */\nexport const Buffer: typeof ToneAudioBuffer = ToneAudioBuffer;\n/** @deprecated Use {@link ToneAudioBuffers} */\nexport const Buffers: typeof ToneAudioBuffers = ToneAudioBuffers;\n/** @deprecated Use {@link ToneBufferSource} */\nexport const BufferSource: typeof ToneBufferSource = ToneBufferSource;\n"],"names":["exports","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","value","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","_getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","undefined","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","interpolateValue","theoreticIndex","lowerIndex","floor","upperIndex","ceil","getValueCurveValueAtTime","isSetTargetAutomationEvent","AutomationEventList","this","_automationEvents","_currenTime","_defaultValue","key","Symbol","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","push","getValue","ratio","max","fraction","i","factor","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","indexOfNextEvent","indexOfCurrentEvent","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","factory","require","module","r","a","e","n","Array","__esModule","isArray","TypeError","toPropertyKey","_defineProperties","t","o","enumerable","configurable","writable","Object","defineProperty","prototype","l","u","f","call","next","done","arrayWithHoles","iterableToArrayLimit","unsupportedIterableToArray","nonIterableRest","_typeof","toPrimitive","String","Number","constructor","arrayLikeToArray","toString","name","from","test","version","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_CONNECTIONS_STORE","WeakMap","AUDIO_NODE_STORE","AUDIO_PARAM_CONNECTIONS_STORE","AUDIO_PARAM_STORE","CONTEXT_STORE","EVENT_LISTENERS","CYCLE_COUNTERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","source","url","importStatements","sourceWithoutImportStatements","replace","result","match","unresolvedUrl","importStatementWithResolvedUrl","URL","join","verifyParameterDescriptors","parameterDescriptors","verifyProcessorCtor","processorCtor","constructible","Proxy","_unused","isConstructible","getValueForKey","map","get","pickElementFromSet","set","predicate","matchingElements","filter","matchingElement","delete","deletePassiveInputConnectionToAudioNode","passiveInputs","output","input","passiveInputConnections","matchingConnection","passiveInputConnection","size","getEventListenersOfAudioNode","audioNode","setInternalStateToActive","has","add","forEach","eventListener","isAudioWorkletNode","setInternalStateToPassive","setInternalStateToPassiveWhenNecessary","activeInputs","every","connections","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","isOwnedByContext","nativeAudioNode","nativeContext","context","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","copyToChannel","Float32Array","createIndexSizeError","DOMException","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","err","code","numberOfChannels","MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isActiveAudioNode","buffer","loop","loopEnd","loopStart","playbackRate","getAudioNodeConnections","getAudioParamConnections","audioParam","deactivateActiveAudioNodeInputConnections","trace","includes","audioParams","isAudioBufferSourceNode","parameters","isBiquadFilterNode","Q","detune","frequency","gain","isConstantSourceNode","offset","isGainNode","isOscillatorNode","isStereoPannerNode","pan","audioParamConnections","_ref2","deactivateAudioGraph","destination","isValidLatencyHint","latencyHint","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","outputConnection","insertElementInSet","element","ignoreDuplicates","lmnt","addActiveInputConnectionToAudioParam","activeInputConnection","addPassiveInputConnectionToAudioParam","Set","isNativeAudioNodeFaker","nativeAudioNodeOrNativeAudioNodeFaker","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","fakeNativeDestinationAudioNode","inputs","connect","deleteActiveInputConnection","activeInputConnections","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioParam","disconnectNativeAudioNodeFromNativeAudioNode","disconnect","getNativeAudioNode","getNativeAudioParam","isPartOfACycle","isPassiveAudioNode","testAudioNodeDisconnectMethodSupport","nativeAudioContext","nativeAudioWorkletNodeConstructor","Promise","resolve","analyzer","createScriptProcessor","dummy","createGain","ones","createBuffer","channelData","createBufferSource","onaudioprocess","event","chnnlDt","inputBuffer","some","sample","stop","start","visitEachAudioNodeOnce","cycles","visitor","counts","Map","cycle","count","isNativeAudioNode","nativeAudioNodeOrAudioParam","wrapAudioNodeDisconnectMethod","arguments","returnValue","connectionsToDestination","connection","bind","destinationOrOutput","apply","clear","filteredConnections","addConnectionToAudioParamOfAudioContext","isOffline","outputs","eventListeners","isActive","nativeAudioParam","partialConnection","deleteActiveInputConnectionToAudioParam","deleteInputsOfAudioNode","listener","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","ReadOnlyMap","_map","entries","callback","thisArg","keys","numberOfInputs","numberOfOutputs","parameterData","processorOptions","copyFromChannel","parent","channelNumber","bufferOffset","byteLength","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","processBuffer","async","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","numberOfInputChannels","numberOfOutputChannels","reduce","sum","processedBuffer","sampleRate","audioNodeConnections","audioWorkletProcessor","getAudioWorkletProcessor","nodeToProcessorMap","nativeAudioWorkletNode","prmtrs","_objectSpread","k","potentiallyEmptyInputs","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","colno","filename","lineno","message","disableNormalization","detachArrayBuffer","arrayBuffer","port1","port2","MessageChannel","closeAndResolve","onmessage","close","postMessage","delayTime","maxDelayTime","getOutputAudioNodeAtIndex","outputAudioNodes","outputAudioNode","attack","knee","release","threshold","createInvalidStateError","createInvalidAccessError","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","testPromiseSupport","uint32Array","Uint32Array","promise","decodeAudioData","catch","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","nativeAnalyserNode","getFloatTimeDomainData","assignNativeAudioNodeAudioParamValue","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","when","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","computeBufferSize","baseLatency","min","round","log2","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","clonedAudioWorkletNodeOptions","reject","data","onmessageerror","cloneAudioWorkletNodeOptions","createNativeBiquadFilterNode","nativeBiquadFilterNode","createBiquadFilter","createNativeChannelSplitterNode","nativeChannelSplitterNode","createChannelSplitter","channelSplitterNode","wrapChannelSplitterNode","interceptConnections","original","interceptor","createNativeDelayNode","nativeDelayNode","createDelay","createNativeGainNode","nativeGainNode","divide","b","denominator","multiply","evaluatePolynomial","coefficient","z","createNativeScriptProcessorNode","bufferSize","createNotSupportedError","periodicWave","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","positionX","positionY","positionZ","refDistance","rolloffFactor","createUnknownError","curve","oversample","getFirstSample","isDCCurve","overwriteAccessors","object","property","createGetter","createSetter","hasOwnProperty","getPrototypeOf","getOwnPropertyDescriptor","setValueAtTimeUntilPossible","setValueAtTime","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","nativeAudioBufferSourceNode","createOscillator","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","testDomExceptionConstructorSupport","testTransferablesSupport","ArrayBuffer","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","removeEventListener","addEventListener","isStopped","wrapEventListener","descriptor","defineProperties","currentTarget","handleEvent","addActiveInputConnectionToAudioNode","createAddActiveInputConnectionToAudioNode","addPassiveInputConnectionToAudioNode","createAddPassiveInputConnectionToAudioNode","deleteActiveInputConnectionToAudioNode","createDeleteActiveInputConnectionToAudioNode","audioNodeTailTimeStore","getAudioNodeTailTime","_a","createGetAudioNodeTailTime","cacheTestResult","ongoingTests","testResults","tester","cachedTestResult","ongoingTest","synchronousTestResult","then","finalTestResult","createCacheTestResult","window","createNativeAnalyserNode","createNativeAnalyserNodeFactory","createAnalyser","byteTimeDomainData","Uint8Array","getByteTimeDomainData","wrapAnalyserNodeGetFloatTimeDomainDataMethod","getAudioNodeRenderer","renderer","createGetAudioNodeRenderer","renderInputsOfAudioNode","createRenderInputsOfAudioNode","all","audioNodeRenderer","renderedNativeAudioNode","render","allRenderingPromises","renderingPromises","createAnalyserNodeRenderer","createAnalyserNodeRendererFactory","renderedNativeAnalyserNodes","renderedNativeAnalyserNode","createAnalyserNode","getNativeContext","contextStore","nativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOfflineAudioContextConstructor","isNativeOfflineAudioContext","anything","createIsNativeOfflineAudioContext","audioParamAudioNodeStore","eventTargetConstructor","_nativeEventTarget","_listeners","wrappedEventListener","createEventTargetConstructor","nativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioContextConstructor","isNativeAudioContext","createIsNativeAudioContext","AudioNode","createIsNativeAudioNode","isNativeAudioParam","AudioParam","createIsNativeAudioParam","AudioWorkletNode","createNativeAudioWorkletNodeConstructor","audioNodeConstructor","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","createIncrementCycleCounter","decrementCycleCounter","detectCycles","super","_context","_nativeAudioNode","state","isPassive","maxValue","destinations","deleteAnyConnection","audioNodeConnectionsOfSource","deleteConnectionAtOutput","deleteConnectionToDestination","audioNodeConnectionsStore","createAddConnectionToAudioNode","tailTimeTimeoutIds","tailTime","tailTimeTimeoutId","clearTimeout","setTimeout","createIncrementCycleCounterFactory","cycleCounters","cycleCounter","nativeDestinationAudioParam","createDecrementCycleCounter","createDetectCycles","chain","nextLink","isDelayNode","mergedCycles","nestedCycles","concat","analyserNodeConstructor","createAnalyserNodeConstructor","audionNodeConstructor","mergedOptions","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getFloatFrequencyData","audioBufferStore","nativeAudioBufferConstructor","AudioBuffer","createNativeAudioBufferConstructor","convertNumberToUnsignedLong","unit32Array","wrapAudioBufferCopyChannelMethods","createWrapAudioBufferCopyChannelMethods","channelNumberAsNumber","audioBufferLength","destinationLength","sourceLength","wrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferCopyChannelMethodsOutOfBounds","audioBufferConstructor","createAudioBufferConstructor","testNativeAudioBufferConstructorSupport","hasInstance","instance","createTestAudioBufferConstructorSupport","addSilentConnection","createAddSilentConnection","renderInputsOfAudioParam","createRenderInputsOfAudioParam","connectAudioParam","createConnectAudioParam","createNativeAudioBufferSourceNode","createNativeAudioBufferSourceNodeFactory","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioBufferSourceNodeStopMethodNullifiedBufferSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioBufferSourceNodeStopMethodNullifiedBuffer","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","clampedOffset","nullifiedBuffer","createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer","renderAutomation","createRenderAutomation","getAudioParamRenderer","replay","createGetAudioParamRenderer","createAudioBufferSourceNodeRenderer","createAudioBufferSourceNodeRendererFactory","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioParam","createAudioParamFactory","addAudioParamConnections","audioParamStore","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","minValue","automationEventList","audioParamRenderer","currentTime","cancelAndHoldAtTime","flush","previousLastEvent","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","isFinite","setTargetAtTime","convertedValues","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","audioParamConnectionsStore","audioBufferSourceNodeConstructor","createAudioBufferSourceNodeConstructor","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","onended","wrappedListener","nativeOnEnded","resetInternalStateToPassive","audioDestinationNodeConstructor","createAudioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","renderedNativeAudioDestinationNodes","renderedNativeAudioDestinationNode","createAudioDestinationNode","createNativeAudioDestinationNodeFactory","isNodeOfNativeOfflineAudioContext","gainNode","createBiquadFilterNodeRenderer","createBiquadFilterNodeRendererFactory","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","setAudioNodeTailTime","createSetAudioNodeTailTime","biquadFilterNodeConstructor","createBiquadFilterNodeConstructor","_Q","_detune","_frequency","_gain","log10","_nativeBiquadFilterNode","getFrequencyResponse","frequencyHz","magResponse","phaseResponse","monitorConnections","createMonitorConnections","whenConnected","whenDisconnected","wasDisconnected","wasConnected","isDisconnected","wrapChannelMergerNode","createWrapChannelMergerNode","channelMergerNode","audioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelMergerNodeFactory","nativeChannelMergerNode","createChannelMerger","createChannelMergerNodeRenderer","createChannelMergerNodeRendererFactory","renderedNativeAudioNodes","createAudioNode","channelMergerNodeConstructor","createChannelMergerNodeConstructor","createChannelSplitterNodeRenderer","createChannelSplitterNodeRendererFactory","channelSplitterNodeConstructor","createChannelSplitterNodeConstructor","sanitizeChannelSplitterOptions","createNativeConstantSourceNodeFaker","createNativeConstantSourceNodeFakerFactory","audioNodeOptions","_objectWithoutProperties","_excluded","nativeConstantSourceNodeFaker","createNativeConstantSourceNode","createNativeConstantSourceNodeFactory","createConstantSource","nativeConstantSourceNode","createConstantSourceNodeRenderer","createConstantSourceNodeRendererFactory","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","constantSourceNodeConstructor","createConstantSourceNodeConstructor","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","createNativeConvolverNode","createNativeConvolverNodeFactory","nativeConvolverNode","createConvolver","normalize","createConvolverNodeRenderer","createConvolverNodeRendererFactory","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","convolverNodeConstructor","createConvolverNodeConstructor","_nativeConvolverNode","createDelayNodeRenderer","createDelayNodeRendererFactory","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","delayNodeConstructor","createDelayNodeConstructor","_delayTime","createNativeDynamicsCompressorNode","nativeDynamicsCompressorNode","createDynamicsCompressor","createNativeDynamicsCompressorNodeFactory","createDynamicsCompressorNodeRenderer","createDynamicsCompressorNodeRendererFactory","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","dynamicsCompressorNodeConstructor","createDynamicsCompressorNodeConstructor","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createGainNodeRenderer","createGainNodeRendererFactory","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","gainNodeConstructor","createGainNodeConstructor","createNativeIIRFilterNodeFaker","createNativeIIRFilterNodeFakerFactory","convertedFeedback","Float64Array","convertedFeedforward","scriptProcessorNode","bufferIndexes","xBuffers","yBuffers","fill","outputBuffer","nyquist","nativeIIRFilterNodeFaker","omega","PI","cos","sin","response","sqrt","atan2","renderNativeOfflineAudioContext","createRenderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","oncomplete","startRendering","createTestOfflineAudioContextCurrentTimeSupport","createIIRFilterNodeRenderer","createIIRFilterNodeRendererFactory","filteredBufferPromise","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","partialOfflineAudioContext","filterFullBuffer","filteredBuffer","createNativeIIRFilterNode","createNativeIIRFilterNodeFactory","iIRFilterNodeConstructor","createIIRFilterNodeConstructor","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createAudioListener","createAudioListenerFactory","nativeListener","forwardX","forwardY","forwardZ","upX","upY","upZ","createFakeAudioParams","isScriptProcessorNodeCreated","lastOrientation","lastPosition","createScriptProcessorNode","orientation","setOrientation","positon","setPosition","createSetOrientation","createSetPosition","createFakeAudioParam","initialValue","setValue","constantSourceNode","_len","args","_key","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","_len7","_key7","unrenderedAudioWorkletNodeStore","minimalBaseAudioContextConstructor","createMinimalBaseAudioContextConstructor","_nativeContext","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createNativeOscillatorNode","createNativeOscillatorNodeFactory","nativeOscillatorNode","setPeriodicWave","createOscillatorNodeRenderer","createOscillatorNodeRendererFactory","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","oscillatorNodeConstructor","createOscillatorNodeConstructor","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createConnectedNativeAudioBufferSourceNode","createConnectedNativeAudioBufferSourceNodeFactory","createNativeWaveShaperNodeFaker","createNativeWaveShaperNodeFakerFactory","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","invertGainNode","outputGainNode","revertGainNode","disconnectNativeAudioBufferSourceNode","isConnected","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","centerIndex","createNativeWaveShaperNode","createNativeWaveShaperNodeFactory","nativeWaveShaperNode","automationRate","createNativePannerNodeFaker","createNativePannerNodeFakerFactory","pannerNode","createPanner","SINGLE_CHANNEL_OPTIONS","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePannerNode","nativePannerNode","createNativePannerNodeFactory","createPannerNodeRenderer","createPannerNodeRendererFactory","renderedBufferPromise","renderedNativeGainNodeOrNativePannerNode","commonAudioNodeOptions","commonNativePannerNodeOptions","nativePannerNodeIsOwnedByContext","nativeConstantSourceNodes","channelDatas","gateGainNode","partialPannerNode","pannerNodeConstructor","createPannerNodeConstructor","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createNativePeriodicWave","imag","real","convertedImag","convertedReal","nativePeriodicWave","createPeriodicWave","createNativePeriodicWaveFactory","periodicWaveConstructor","createPeriodicWaveConstructor","periodicWaveStore","sanitizePeriodicWaveOptions","PeriodicWave","nativeStereoPannerNodeFakerFactory","createNativeStereoPannerNodeFakerFactory","CURVE_SIZE","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","buildInternalGraphForMono","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","connectGraph","disconnectGraph","buildInternalGraphForStereo","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","createNativeStereoPannerNode","createNativeStereoPannerNodeFactory","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createStereoPannerNodeRenderer","createStereoPannerNodeRendererFactory","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","stereoPannerNodeConstructor","createStereoPannerNodeConstructor","_pan","createWaveShaperNodeRenderer","createWaveShaperNodeRendererFactory","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","waveShaperNodeConstructor","createWaveShaperNodeConstructor","_isCurveNullified","_nativeWaveShaperNode","isSecureContext","createIsSecureContext","fn","currentFrame","createExposeCurrentFrameAndCurrentTime","backupOfflineAudioContextStore","getOrCreateBackupOfflineAudioContext","createGetOrCreateBackupOfflineAudioContext","backupOfflineAudioContext","addAudioWorkletModule","createAddAudioWorkletModule","evaluateSource","fetchSource","ongoingRequests","resolvedRequests","testAudioWorkletProcessorPostMessageSupport","moduleURL","credentials","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","audioWorklet","absoluteUrl","wrappedSource","evaluateAudioWorkletGlobalScope","_AWGS","SyntaxError","trim","nodeNameToProcessorConstructorMap","isSupportingPostMessage","currentIndex","patchedAudioWorkletProcessor","memberDefinition","bufferRegistration","blob","Blob","createObjectURL","addModule","nativeContextOrBackupOfflineAudioContext","finally","revokeObjectURL","updatedResolvedRequestsOfContext","updatedOngoingRequestsOfContext","head","document","script","createElement","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","src","location","href","onload","appendChild","createEvaluateSource","createAbortError","fetch","ok","text","createFetchSource","createTestAudioWorkletProcessorPostMessageSupport","offlineAudioContext","isEmittingMessageEvents","isEmittingProcessorErrorEvents","audioWorkletNode","oscillator","port","onprocessorerror","isNativeContext","createIsNativeContext","createDecodeAudioData","createDataCloneError","createEncodingError","detachedArrayBuffers","anyContext","audioData","complete","_unused2","fail","baseAudioContextConstructor","createBaseAudioContextConstructor","_audioWorklet","constraints","successCallback","errorCallback","mediaElementAudioSourceNodeConstructor","createMediaElementAudioSourceNodeConstructor","createNativeMediaElementAudioSourceNode","nativeMediaElementAudioSourceNode","_nativeMediaElementAudioSourceNode","mediaElement","createMediaElementSource","mediaStreamAudioDestinationNodeConstructor","createMediaStreamAudioDestinationNodeConstructor","createNativeMediaStreamAudioDestinationNode","nativeMediaStreamAudioDestinationNode","_nativeMediaStreamAudioDestinationNode","stream","createMediaStreamDestination","mediaStreamAudioSourceNodeConstructor","createMediaStreamAudioSourceNodeConstructor","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","mediaStream","audioStreamTracks","getAudioTracks","sort","id","filteredAudioStreamTracks","createMediaStreamSource","MediaStream","createNativeMediaStreamTrackAudioSourceNode","createNativeMediaStreamTrackAudioSourceNodeFactory","mediaStreamTrack","createMediaStreamTrackSource","kind","mediaStreamTrackAudioSourceNodeConstructor","createMediaStreamTrackAudioSourceNodeConstructor","audioContextConstructor","createAudioContextConstructor","_baseLatency","_nativeAudioContext","_nativeGainNode","_state","revokeState","resume","resolvePromise","suspend","getUnrenderedAudioWorkletNodes","unrenderedAudioWorkletNodes","createGetUnrenderedAudioWorkletNodes","addUnrenderedAudioWorkletNode","createAddUnrenderedAudioWorkletNode","connectMultipleOutputs","createConnectMultipleOutputs","deleteUnrenderedAudioWorkletNode","createDeleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","createDisconnectMultipleOutputs","activeAudioWorkletNodeInputsStore","getActiveAudioWorkletNodeInputs","createGetActiveAudioWorkletNodeInputs","createNativeAudioWorkletNodeFaker","createNativeAudioWorkletNodeFakerFactory","numberOfParameters","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","patchedEventListener","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","disconnectOutputsGraph","outputChannelMergerNode","activeInputIndexes","_ref3","_ref4","disconnectFakeGraph","connectFakeGraph","createNativeAudioWorkletNode","createNativeAudioWorkletNodeFactory","testClonabilityOfAudioWorkletNodeOptions","createAudioWorkletNodeRenderer","createAudioWorkletNodeRendererFactory","processedBufferPromise","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","renderBuffer","nm","getBackupOfflineAudioContext","createGetBackupOfflineAudioContext","setActiveAudioWorkletNodeInputs","createSetActiveAudioWorkletNodeInputs","audioWorkletNodeConstructor","createAudioWorkletNodeConstructor","sanitizeAudioWorkletNodeOptions","testAudioWorkletNodeOptionsClonability","_nativeAudioWorkletNode","_onprocessorerror","_parameters","nativeOnProcessorError","createNativeOfflineAudioContext","createMinimalAudioContextConstructor","createCreateNativeOfflineAudioContext","createStartRendering","offlineAudioContextConstructor","createMinimalOfflineAudioContextConstructor","createOfflineAudioContextConstructor","c","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","isAnyAudioContext","createIsAnyAudioContext","isAnyAudioNode","createIsAnyAudioNode","audioNodeStore","isAnyAudioParam","createIsAnyAudioParam","isAnyOfflineAudioContext","createIsAnyOfflineAudioContext","isSupported","testAudioBufferCopyChannelMethodsSubarraySupport","testAudioContextCloseMethodSupport","testAudioContextDecodeAudioDataMethodTypeErrorSupport","testAudioContextOptionsSupport","testAudioNodeConnectMethodSupport","testAudioWorkletProcessorNoOutputsSupport","testChannelMergerNodeChannelCountSupport","testConstantSourceNodeAccurateSchedulingSupport","testConvolverNodeBufferReassignabilitySupport","testConvolverNodeChannelCountSupport","testDomExceptionContrucorSupport","testIsSecureContextSupport","testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","testStereoPannerNodeDefaultValueSupport","createIsSupportedPromise","createTestAudioBufferCopyChannelMethodsSubarraySupport","audioContext","isAudioContextClosable","createTestAudioContextCloseMethodSupport","isPending","createTestAudioContextDecodeAudioDataMethodTypeErrorSupport","createTestAudioContextOptionsSupport","createTestAudioNodeConnectMethodSupport","createTestAudioWorkletProcessorNoOutputsSupport","isCallingProcess","createTestChannelMergerNodeChannelCountSupport","POSITIVE_INFINITY","createTestConstantSourceNodeAccurateSchedulingSupport","createTestConvolverNodeBufferReassignabilitySupport","createTestConvolverNodeChannelCountSupport","createTestIsSecureContextSupport","createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport","stereoPanner","createTestStereoPannerNodeDefaultValueSupport","isUndef","arg","isDefined","isFunction","isNumber","isObject","isBoolean","isString","isNote","assert","statement","assertRange","gte","lte","Infinity","assertContextRunning","warn","isInsideScheduledCallback","printedScheduledWarning","enterScheduledCallback","insideCallback","assertUsedScheduleTime","defaultLogger","console","setLogger","logger","log","theWindow","self","hasAudioContext","Ticker","updateInterval","contextSampleRate","_callback","_type","_minimumUpdateInterval","_createClock","_createWorker","_updateInterval","toFixed","blobUrl","worker","Worker","_worker","_createTimeout","_timeout","_disposeClock","terminate","interval","dispose","isAudioParam","isOfflineAudioContext","isAudioContext","noCopy","isAudioBuffer","deepMerge","sources","shift","assign","optionsFromArguments","defaults","argsArray","objKey","opts","Reflect","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","prop","Tone","debug","_wasDisposed","getDefaults","TONE_DEBUG_CLASS","disposed","EPSILON","GT","GTE","EQ","LT","abs","clamp","Timeline","_timeline","memory","increasing","valueOf","lastValue","_search","diff","remove","param","peek","getAfter","getBefore","len","cancel","after","cancelBefore","previousEvent","beginning","end","midPoint","nextEvent","_iterate","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","forEachFrom","forEachAtTime","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","Emitter","on","split","eventName","_events","once","_this","boundCallback","off","eventList","emit","mixin","constr","BaseContext","toJSON","Context","_constants","_timeouts","_timeoutIds","_initialized","_closeStarted","_workletPromise","_latencyHint","stdAudioContext","createAudioContext","_ticker","clockSource","_timeoutLoop","_b","lookAhead","initialize","ctx","feedForward","transport","_transport","draw","_draw","d","createAudioWorkletNode","stdAudioWorkletNode","BaseAudioContext","rawContext","workletsAreReady","_lookAhead","now","immediate","getConstant","val","arr","constant","timeout","clearInterval","setInterval","intervalFn","readOnly","str","noOp","ToneAudioBuffer","reverse","load","_buffer","getContext","loaded","_reversed","_reverse","doneLoading","downloads","fromArray","isMultidimensional","channels","multiChannelArray","toMono","chanNum","toArray","outputArray","numChannels","channelArray","ret","startSamples","endSamples","retBuffer","subarray","rev","fromUrl","baseUrl","endsWith","supportsType","extensions","extension","canPlayType","OfflineContext","stdOfflineAudioContext","_currentTime","_duration","_renderClock","asynchronous","yieldEvery","dummyContext","_numberOfChannels","_sampleRate","_numberOfInputs","_numberOfOutputs","_maxDelayTime","_feedForward","_feedback","_real","_imag","_constraints","_stream","_element","_audioData","_name","_options","_url","_fn","_id","_interval","_val","_d","globalContext","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","TimeBaseClass","units","defaultUnits","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","m","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","s","_secondsToUnits","samples","tr","q","total","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","toSamples","toMilliseconds","TimeClass","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","toBarsBeatsSixteenths","quarterTime","quarters","measures","sixteenths","sixteenthString","Time","FrequencyClass","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","transpose","harmonize","intervals","toNote","scaleIndexToNote","cbbb","cbb","cx","dbbb","dbb","dx","ebbb","ebb","eb","ex","fbbb","fbb","fb","fx","gbbb","gbb","gb","g","gx","abbb","abb","ab","ax","bbbb","bbb","bb","bx","Frequency","TransportTimeClass","TransportTime","ToneWithContext","defaultContext","sampleTime","blockTime","_getPartialProperties","props","attribute","member","StateTimeline","initial","_initial","setStateAtTime","getValueAtTime","getLastState","getNextState","Param","overridden","_minOutput","_param","_swappable","swappable","_initialValue","convert","_minValue","_maxValue","_toType","_is","_assertRange","_fromType","computedTime","JSON","stringify","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","setRampPoint","currentVal","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","scaling","startingValue","segTime","valueAtTime","rampTo","subdivisions","setParam","t0","v0","v1","t1","ToneAudioNode","_internalChannels","_isAudioNode","node","_getInternalNodes","nodeList","_setChannelProperties","_getChannelProperties","toDestination","toMaster","nodes","connectSeries","fan","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","fanIn","Gain","_gainNode","OneShotSource","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","_startGain","fadeInTime","_stopGain","cancelStop","fadeOutTime","additionalTail","_stopSource","disposeCallback","requestIdleCallback","ToneConstantSource","_source","Signal","override","_constantSource","connectSignal","signal","outputNum","inputNum","TickParam","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","delta","sol1","ticksToTime","timeToTicks","computedDuration","startTicks","TickSignal","TickSource","_tickOffset","_ticksAtTime","_secondsAtTime","setTicksAtTime","pause","stopEvent","memoizedEvent","tmpEvent","lastState","elapsedTicks","eventToMemoize","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","forEachTickBetween","lastStateEvent","maxStartTime","nextTickTime","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","Delay","maxDelayInSeconds","maxDelay","_maxDelay","_delayNode","Volume","volume","_unmutedVolume","mute","DestinationClass","ListenerClass","Offline","callback_1","duration_1","originalContext","bufferPromise","ToneAudioBuffers","_buffers","_loadingCount","urls","_bufferLoaded","substring","MidiClass","Midi","TicksClass","Ticks","DrawClass","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","schedule","requestAnimationFrame","cancelAnimationFrame","IntervalTimeline","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes","traverse","searchAfter","high","_left","_right","height","point","TimelineValue","SignalOperator","WaveShaper","_shaper","mapping","setMap","normalized","oversampling","Pow","_exponentScaler","_expFunc","_exponent","exponent","TransportEvent","_eventId","_remainderTime","_once","floatTime","invoke","tickDuration","TransportRepeatEvent","_currentId","_nextId","_nextTick","_boundRestart","_restart","_createEvents","_createEvent","scheduleOnce","TransportClass","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","position","remainingTicks","syncSignal","sourceValue","scaleFactor","scaleBefore","reciprocal","scaleAfter","ratioSignal","unsyncSignal","syncedSignal","Source","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","sched","_start","restart","_stop","sync","stateEvent","startOffset","unsync","ToneBufferSource","_sourceStarted","_sourceStopped","computedOffset","loopDuration","computedDur","Noise","_noiseBuffers","rate","random","BUFFER_LENGTH","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","UserMedia","open","labelOrId","supported","devices","enumerateDevices","_device","find","device","label","deviceId","audio","echoCancellation","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","mediaStreamNode","_mediaStream","track","active","groupId","generateWaveform","ToneOscillatorNode","_oscillator","Oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","_wave","syncFrequency","unsyncFrequency","_getCachedPeriodicWave","_periodicWaveCache","description","_phase","arrayA","arrayB","oscProps","isBasicType","cache","wave","_getRealImaginary","p","partial","exec","fullPartials","v","periodicWaveSize","piFactor","_inverseFFT","getInitialValue","twoPi","asArray","AudioToGain","_norm","Multiply","_mult","AMOscillator","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","FMOscillator","modulationIndex","PulseOscillator","_widthGate","_thresh","width","_triangle","carrierType","FatOscillator","_oscillators","_spread","spread","_forEach","osc","step","PWMOscillator","sourceType","_scale","_pulse","modulationFrequency","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","OmniOscillator","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc","sType","mType","Add","_sum","addend","Scale","_add","_min","_max","_setRange","Zero","LFO","_stoppedValue","_clampValue","_amplitudeGain","amplitude","_stoppedSignal","_zeros","_a2g","_scaler","_setStoppedValue","currentMin","currentMax","range","valueMap","propertyKey","newValue","timeRange","Player","_activeSources","_onload","autostart","_onSourceEnd","origDuration","implicitEnd","seek","__decorate","Players","_players","player","stopAll","GrainPlayer","_tick","grainSize","_grainSize","_overlap","overlap","_onstop","Abs","_abs","GainToAudio","Negate","_multiply","Subtract","_neg","subtrahend","GreaterThanZero","GreaterThan","_subtract","_gtz","comparator","ScaleExp","_exp","SyncedSignal","_lastVal","_onTick","_syncedCallback","_anchorValue","Envelope","_sig","decay","sustain","attackCurve","releaseCurve","decayCurve","_getCurve","direction","curveName","EnvelopeCurves","_setCurve","curveDef","_attackCurve","_releaseCurve","_decayCurve","triggerAttack","velocity","currentValue","decayValue","decayStart","triggerRelease","triggerAttackRelease","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","curveLen","cosineCurve","rippleCurve","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","Instrument","_original_triggerAttack","_original_triggerRelease","_syncedRelease","_syncState","_syncMethod","changed","timePosition","originalMethod","Monophonic","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedFrequency","getLevelAtTime","portTime","AmplitudeEnvelope","Synth","envelope","computedAttack","computedDecay","ModulationSynth","modulation","modulationEnvelope","AMSynth","BiquadFilter","_filter","freqValues","magValues","phaseValues","filterClone","Filter","_filters","rolloff","_rolloff","rolloffNum","possibilities","cascadingCount","totalResponse","FrequencyEnvelope","_octaves","octaves","_baseFrequency","baseFrequency","MonoSynth","filterEnvelope","DuoSynth","voice0","voice1","_vibrato","vibratoRate","_vibratoGain","vibratoAmount","FMSynth","inharmRatios","MetalSynth","_freqMultipliers","_amplitude","_highpass","mult","_filterFreqScaler","resonance","freqMult","MembraneSynth","pitchDecay","hertz","maxNote","NoiseSynth","noise","workletContext","addToWorklet","classOrFunction","registerProcessor","classDesc","processor","ToneAudioWorklet","workletOptions","_audioWorkletName","_dummyGain","_dummyParam","_worklet","onReady","workletName","FeedbackCombFilter","OnePoleFilter","_createFilter","oldFilter","a0","fq","LowpassCombFilter","_combFilter","_lowpass","dampening","PluckSynth","_noise","attackNoise","_lfcf","delayAmount","PolySynth","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","releaseAll","voice","maxPolyphony","_dummyVoice","_getNextAvailableVoice","_collectGarbage","activeVoices","_makeVoiceAvailable","activeVoiceIndex","firstAvail","_triggerAttack","notes","midiNote","released","_triggerRelease","_scheduleEvent","durationSeconds","sanitizedOptions","Sampler","urlMap","mid","_findClosest","midiFloat","remainder","difference","closestNote","ToneEvent","_startOffset","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","prob","variation","rescheduleTime","lastEvent","Loop","_event","iterations","iters","Part","events","_startNote","at","timeInTicks","_restartEvent","_setAll","attr","_testLoopBoundries","upPatternGen","numValues","downPatternGen","infiniteGen","gen","alternatingGenerator","directionUp","jumpUp","stepIndex","jumpDown","randomOnce","copy","PatternGenerator","pattern","randomIndex","randomGen","randomWalk","Pattern","_values","_pattern","Sequence","_part","_seqCallback","_eventsArray","_subdivision","_createSequence","_eventsUpdated","_indexTime","_rescheduleSequence","sequence","eventOffset","CrossFade","_panner","_split","_g2a","fade","Effect","_dryWet","wet","effectSend","effectReturn","connectEffect","effect","LFOEffect","_lfo","depth","AutoFilter","oct","Panner","AutoPanner","Follower","smoothing","_smoothing","AutoWah","_follower","follower","_sweepRange","_inputBoost","_bandpass","_peaking","_setSweepRange","sensitivity","baseFreq","BitCrusher","_bitCrusherWorklet","BitCrusherWorklet","bits","Chebyshev","_order","order","_getCoefficient","degree","memo","isInteger","Split","_splitter","Merge","_merger","StereoEffect","_merge","connectEffectLeft","connectEffectRight","StereoFeedbackEffect","_feedbackL","_feedbackR","_feedbackSplit","_feedbackMerge","Chorus","_depth","_lfoL","_lfoR","_delayNodeL","_delayNodeR","deviation","Distortion","_distortion","distortion","deg","FeedbackEffect","_feedbackGain","FeedbackDelay","PhaseShiftAllpass","offset90","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","bankValues","coefficients","FrequencyShifter","_sine","_cosine","_sineMultiply","_cosineMultiply","_negate","_phaseShifter","combFilterTunings","allpassFilterFrequencies","Freeverb","_combFilters","_allpassFiltersL","_allpassFiltersR","roomSize","allpassL","allpassR","lfpf","al","ar","cf","combFilterDelayTimes","combFilterResonances","allpassFilterFreqs","JCReverb","_allpassFilters","_feedbackCombFilters","_scaleRoomSize","allpass","fbcf","apf","StereoXFeedbackEffect","PingPongDelay","_leftDelay","_rightDelay","_rightPreDelay","PitchShift","_delayA","_lfoA","_delayB","_lfoB","_crossFade","_crossFadeLFO","_feedbackDelay","_pitch","_windowSize","windowSize","Phaser","_filtersL","_makeFilters","stages","_filtersR","connectToFreq","filters","Reverb","_convolver","ready","decayTime","_decay","preDelayTime","preDelay","_preDelay","generate","previousReady","noiseL","noiseR","merge","renderPromise","MidSideSplit","_midAdd","SQRT1_2","_sideSubtract","side","MidSideMerge","_leftMult","_rightMult","MidSideEffect","_midSideMerge","_midSideSplit","_midSend","_sideSend","_midReturn","_sideReturn","connectEffectMid","connectEffectSide","StereoWidener","_twoTimesWidthMid","_twoTimesWidthSide","_midMult","_oneMinusWidth","_sideMult","Tremolo","_amplitudeL","_amplitudeR","Vibrato","Analyser","_analysers","analyser","MeterBase","_analyser","Meter","normalRange","_rms","getLevel","aValues","vals","totalSquared","rms","FFT","getFrequencyOfIndex","DCMeter","Waveform","Solo","_allSolos","solo","_isSoloed","_addSolo","_removeSolo","_updateSolo","muted","_soloed","_noSolos","PanVol","Channel","_solo","_panVol","_getBus","buses","send","bus","sendKnob","receive","Mono","MultibandSplit","_lowMidFilter","lowFrequency","highFrequency","Panner3D","Recorder","_recorder","MediaRecorder","mimeType","startPromise","handleStart","dataPromise","handleData","Compressor","_compressor","Gate","_gt","_gate","thresh","smoothingTime","Limiter","MidSideCompressor","MultibandCompressor","EQ3","_multibandSplit","_lowGain","_midGain","_highGain","Convolver","buff","norm","Transport","getTransport","Destination","Master","getDestination","Listener","getListener","Draw","getDraw","Buffer","Buffers","BufferSource"],"sourceRoot":""}